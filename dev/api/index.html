<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MultiScaleTreeGraph.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/MultiScaleTreeGraph.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultiScaleTreeGraph.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../get_started/">Getting started</a></li><li><span class="tocitem">The MTG format</span><ul><li><a class="tocitem" href="../the_mtg/mtg_concept/">Concept</a></li><li><a class="tocitem" href="../the_mtg/mtg_format/">File format</a></li><li><a class="tocitem" href="../the_mtg/our_implementation/">Our implementation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/0.read_write/">Read and Write MTGs</a></li><li><a class="tocitem" href="../tutorials/1.manipulate_node/">Manipulate nodes</a></li><li><a class="tocitem" href="../tutorials/2.descendants_ancestors_filters/">Computing</a></li><li><a class="tocitem" href="../tutorials/3.transform_mtg/">Transform an MTG</a></li><li><a class="tocitem" href="../tutorials/4.convert_mtg/">Converting MTGs</a></li><li><a class="tocitem" href="../tutorials/5.plotting/">Plotting</a></li><li><a class="tocitem" href="../tutorials/6.add_remove_nodes/">Add/remove nodes</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiScaleTreeGraph.jl-functions"><a class="docs-heading-anchor" href="#MultiScaleTreeGraph.jl-functions">MultiScaleTreeGraph.jl functions</a><a id="MultiScaleTreeGraph.jl-functions-1"></a><a class="docs-heading-anchor-permalink" href="#MultiScaleTreeGraph.jl-functions" title="Permalink"></a></h1><p>Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you&#39;ll be directed to the function help.</p><ul><li><a href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a></li><li><a href="#MetaGraphsNext.MetaGraph-Tuple{Node}"><code>MetaGraphsNext.MetaGraph</code></a></li><li><a href="#MultiScaleTreeGraph.AbstractNodeMTG"><code>MultiScaleTreeGraph.AbstractNodeMTG</code></a></li><li><a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MultiScaleTreeGraph.MutableNodeMTG</code></a></li><li><a href="#MultiScaleTreeGraph.Node"><code>MultiScaleTreeGraph.Node</code></a></li><li><a href="#MultiScaleTreeGraph.NodeMTG"><code>MultiScaleTreeGraph.NodeMTG</code></a></li><li><a href="#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}"><code>Base.append!</code></a></li><li><a href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.length-Tuple{Node}"><code>Base.length</code></a></li><li><a href="#Base.print-Tuple{Node}"><code>Base.print</code></a></li><li><a href="#DataFrames.transform"><code>DataFrames.transform</code></a></li><li><a href="#DataFrames.transform!"><code>DataFrames.transform!</code></a></li><li><a href="#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M&lt;:AbstractNodeMTG"><code>MultiScaleTreeGraph.addchild!</code></a></li><li><a href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>MultiScaleTreeGraph.ancestors</code></a></li><li><a href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>MultiScaleTreeGraph.branching_order!</code></a></li><li><a href="#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MultiScaleTreeGraph.check_filters</code></a></li><li><a href="#MultiScaleTreeGraph.children-Tuple{Node}"><code>MultiScaleTreeGraph.children</code></a></li><li><a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>MultiScaleTreeGraph.clean_cache!</code></a></li><li><a href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>MultiScaleTreeGraph.coordinates!</code></a></li><li><a href="#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_node!</code></a></li><li><a href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_nodes!</code></a></li><li><a href="#MultiScaleTreeGraph.descendants"><code>MultiScaleTreeGraph.descendants</code></a></li><li><a href="#MultiScaleTreeGraph.descendants!"><code>MultiScaleTreeGraph.descendants!</code></a></li><li><a href="#MultiScaleTreeGraph.descendants_!-NTuple{10, Any}"><code>MultiScaleTreeGraph.descendants_!</code></a></li><li><a href="#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.expand_node!</code></a></li><li><a href="#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}"><code>MultiScaleTreeGraph.extend_pos</code></a></li><li><a href="#MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.filter_fun_nothing</code></a></li><li><a href="#MultiScaleTreeGraph.get_attributes-Tuple{Any}"><code>MultiScaleTreeGraph.get_attributes</code></a></li><li><a href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>MultiScaleTreeGraph.get_classes</code></a></li><li><a href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>MultiScaleTreeGraph.get_description</code></a></li><li><a href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>MultiScaleTreeGraph.get_features</code></a></li><li><a href="#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}"><code>MultiScaleTreeGraph.get_leading_tabs</code></a></li><li><a href="#MultiScaleTreeGraph.get_node-Tuple{Node, String}"><code>MultiScaleTreeGraph.get_node</code></a></li><li><a href="#MultiScaleTreeGraph.get_printing-Tuple{Node}"><code>MultiScaleTreeGraph.get_printing</code></a></li><li><a href="#MultiScaleTreeGraph.get_reference-Tuple{Any}"><code>MultiScaleTreeGraph.get_reference</code></a></li><li><a href="#MultiScaleTreeGraph.get_root-Tuple{Node}"><code>MultiScaleTreeGraph.get_root</code></a></li><li><a href="#MultiScaleTreeGraph.insert_child!"><code>MultiScaleTreeGraph.insert_child!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_children!"><code>MultiScaleTreeGraph.insert_children!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_generation!"><code>MultiScaleTreeGraph.insert_generation!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_generations!"><code>MultiScaleTreeGraph.insert_generations!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.insert_nodes!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_parent!"><code>MultiScaleTreeGraph.insert_parent!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_parents!"><code>MultiScaleTreeGraph.insert_parents!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_sibling!"><code>MultiScaleTreeGraph.insert_sibling!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_siblings!"><code>MultiScaleTreeGraph.insert_siblings!</code></a></li><li><a href="#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}"><code>MultiScaleTreeGraph.is_filtered</code></a></li><li><a href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>MultiScaleTreeGraph.is_segment!</code></a></li><li><a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>MultiScaleTreeGraph.isleaf</code></a></li><li><a href="#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>MultiScaleTreeGraph.isroot</code></a></li><li><a href="#MultiScaleTreeGraph.issection-Tuple{Any, Any}"><code>MultiScaleTreeGraph.issection</code></a></li><li><a href="#MultiScaleTreeGraph.issection-Tuple{Any}"><code>MultiScaleTreeGraph.issection</code></a></li><li><a href="#MultiScaleTreeGraph.max_id-Tuple{Any}"><code>MultiScaleTreeGraph.max_id</code></a></li><li><a href="#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}"><code>MultiScaleTreeGraph.mtg_coordinates_df</code></a></li><li><a href="#MultiScaleTreeGraph.new_child_link-Tuple{Any}"><code>MultiScaleTreeGraph.new_child_link</code></a></li><li><a href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>MultiScaleTreeGraph.new_id</code></a></li><li><a href="#MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}"><code>MultiScaleTreeGraph.new_node_MTG</code></a></li><li><a href="#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.next_line!</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves"><code>MultiScaleTreeGraph.nleaves</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves!"><code>MultiScaleTreeGraph.nleaves!</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}"><code>MultiScaleTreeGraph.nleaves_siblings!</code></a></li><li><a href="#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MultiScaleTreeGraph.node_attributes</code></a></li><li><a href="#MultiScaleTreeGraph.ordered_children-Tuple{Any}"><code>MultiScaleTreeGraph.ordered_children</code></a></li><li><a href="#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}"><code>MultiScaleTreeGraph.parse_MTG_node</code></a></li><li><a href="#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_MTG_node_attr</code></a></li><li><a href="#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}"><code>MultiScaleTreeGraph.parse_macro_args</code></a></li><li><a href="#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}"><code>MultiScaleTreeGraph.parse_mtg!</code></a></li><li><a href="#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_section!</code></a></li><li><a href="#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}"><code>MultiScaleTreeGraph.paste_mtg_node</code></a></li><li><a href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a></li><li><a href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a></li><li><a href="#MultiScaleTreeGraph.read_mtg"><code>MultiScaleTreeGraph.read_mtg</code></a></li><li><a href="#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}"><code>MultiScaleTreeGraph.rewrite_expr!</code></a></li><li><a href="#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}"><code>MultiScaleTreeGraph.rotate_point</code></a></li><li><a href="#MultiScaleTreeGraph.siblings-Tuple{Node}"><code>MultiScaleTreeGraph.siblings</code></a></li><li><a href="#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}"><code>MultiScaleTreeGraph.split_MTG_elements</code></a></li><li><a href="#MultiScaleTreeGraph.strip_comments"><code>MultiScaleTreeGraph.strip_comments</code></a></li><li><a href="#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.traverse!</code></a></li><li><a href="#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}"><code>MultiScaleTreeGraph.unsafe_getindex</code></a></li><li><a href="#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}"><code>MultiScaleTreeGraph.write_mtg</code></a></li><li><a href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_mtg!</code></a></li><li><a href="#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_node!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}" href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])</code></pre><p>Convert an MTG into a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>mtg::Node</code>: An mtg node (usually the root node).</li><li><code>key</code>: The key, or attribute name. Used to list the variables that must be added to the</li></ul><p><code>DataFrame</code>. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

DataFrame(mtg, :Length)
DataFrame(mtg, [:Length, :Width])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/conversion/DataFrame.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaGraphsNext.MetaGraph-Tuple{Node}" href="#MetaGraphsNext.MetaGraph-Tuple{Node}"><code>MetaGraphsNext.MetaGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MetaGraph(g::Node)</code></pre><p>Convert an MTG into a <a href="https://juliagraphs.org/MetaGraphsNext.jl/dev/">MetaGraph</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

MetaGraph(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/conversion/MetaGraph.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.AbstractNodeMTG" href="#MultiScaleTreeGraph.AbstractNodeMTG"><code>MultiScaleTreeGraph.AbstractNodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all types describing the MTG coding for a node.</p><p>See <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> and <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> for examples of implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.MutableNodeMTG" href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MultiScaleTreeGraph.MutableNodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeMTG(link, symbol, index, scale)
MutableNodeMTG(link, symbol, index, scale)</code></pre><p><strong>NodeMTG structure</strong></p><p>Builds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.</p><p><strong>Note</strong></p><ul><li>The symbol should match the possible values listed in the <code>SYMBOL</code> column of the <code>CLASSES</code> section</li></ul><p>in the mtg file if read from a file.</p><ul><li>The index is totaly free, and can be used as a way to <em>e.g.</em> keep track of the branching order.</li></ul><pre><code class="language-julia hljs">NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.Node" href="#MultiScaleTreeGraph.Node"><code>MultiScaleTreeGraph.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node(id::Int, MTG&lt;:AbstractNodeMTG, attributes)
Node(name::String, id::Int, MTG&lt;:AbstractNodeMTG, attributes)
Node(id::Int, parent::Node, MTG&lt;:AbstractNodeMTG, attributes)
Node(name::String, id::Int, parent::Node, MTG&lt;:AbstractNodeMTG, attributes)
Node(
    name::String,
    id::Int,
    parent::Node,
    children::Union{Nothing,Dict{Int,Node}},
    siblings::Union{Nothing,Dict{Int,Node}},
    MTG&lt;:AbstractNodeMTG,
    attributes
)</code></pre><p>Type that defines an MTG node (<em>i.e.</em> an element) with the name of the node, its unique id, its parent (only if its not the root node), children, MTG encoding (see <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a>) and attributes.</p><p>The node is an entry point to a Mutli-Scale Tree Graph, meaning we can move through the MTG from any of its node. The root node is the node without parent. A leaf node is a node without any children. Root and leaf nodes are used with their computer science meaning throughout the package, not in the biological sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L46-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.NodeMTG" href="#MultiScaleTreeGraph.NodeMTG"><code>MultiScaleTreeGraph.NodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeMTG(link, symbol, index, scale)
MutableNodeMTG(link, symbol, index, scale)</code></pre><p><strong>NodeMTG structure</strong></p><p>Builds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.</p><p><strong>Note</strong></p><ul><li>The symbol should match the possible values listed in the <code>SYMBOL</code> column of the <code>CLASSES</code> section</li></ul><p>in the mtg file if read from a file.</p><ul><li>The index is totaly free, and can be used as a way to <em>e.g.</em> keep track of the branching order.</li></ul><pre><code class="language-julia hljs">NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}" href="#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append!(node::Node{M&lt;:AbstractNodeMTG, &lt;:MutableNamedTuple}, attr)
append!(node::Node{M&lt;:AbstractNodeMTG, &lt;:Dict}, attr)</code></pre><p>Append new attributes to a node attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/append_attributes.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Any}" href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Integer}" href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing a Node using an integer will index in its children</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Node}" href="#Base.length-Tuple{Node}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the length of the subtree below the node (including it)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L190-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print-Tuple{Node}" href="#Base.print-Tuple{Node}"><code>Base.print</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print a node to io using an UTF-8 formatted representation of the <code>tree</code>. Most of the code from <a href="https://github.com/vh-d/DataTrees.jl/blob/master/src/printing.jl">DataTrees.jl</a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
mtg
# / 1: $
# └─ / 2: Individual
#    └─ / 3: Axis
#       └─ / 4: Internode
#          ├─ + 5: Leaf
#          └─ &lt; 6: Internode
#             └─ + 7: Leaf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/print_MTG/print.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform" href="#DataFrames.transform"><code>DataFrames.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(node::Node, args..., &lt;keyword arguments&gt;)
transform(node::Node, args..., &lt;keyword arguments&gt;)</code></pre><p>Transform (mutate) an MTG (<code>node</code>) in place (<code>transform!</code>) or on a copy (<code>transform</code>) to add attributes specified by <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</p></li><li><p><code>args::Any</code>: the transformations (see details)</p></li><li><p>&lt;keyword arguments&gt;:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>ignore_nothing = false</code>: filter-out the nodes with <code>nothing</code> values for the given</li></ul><p>attributes used as inputs (apply only to the form :var_name =&gt; ...)</p></li></ul><p><strong>Returns</strong></p><p><code>transform!</code>: Nothing, mutates the (sub-)tree in-place. <code>transform</code>: A mutated copy of <code>node</code>.</p><p><strong>Notes</strong></p><p>Carefull, <code>transform</code> is much slower than <code>transform!</code> because it makes a copy of the whole MTG each time.</p><p><strong>Details</strong></p><p>The interface of the function is inspired from the one used in <a href="https://dataframes.juliadata.org/stable/"><code>DataFrames.jl</code></a>, but adapted to an MTG.</p><p>The <code>args...</code> provided can be of the following forms:</p><ol><li>a <code>:var_name =&gt; :new_var_name</code> pair. This form is used to rename an attribute name</li><li>a <code>:var_name =&gt; function</code> or <code>[:var_name1, :var_name2...] =&gt; function</code> pair. The variables</li></ol><p>are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.</p><ol><li>a <code>:var_name =&gt; function =&gt; :new_var_name</code> form that does the same as the previous form</li></ol><p>but explicitly naming the resulting variable (can take several variables on left-hand side).</p><ol><li>a <code>function =&gt; :new_var_name</code> form that applies a function to a node and puts the results</li></ol><p>in a new attribute. This form is usually applied when searching ancestors or descendants values.</p><ol><li>a <code>function</code> form that applies a mutating function to a node, without expecting any output.</li></ol><p>This form is adapted when using a function that already mutates the node, without the need to return anything, <em>e.g.</em> <a href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>branching_order!</code></a>.</p><p>Carefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))
transform!(mtg,  x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf

# We can compute a new variable based on another. For example to know if the value of the
# `:Length` attribute is provided or not, we can do:
transform!(mtg, :Length =&gt; isnothing)
# To check the values we first call [`get_attributes`](@ref) to know the new variable name:
get_attributes(mtg)
# And then we get the values using [`descendants`](@ref)
descendants(mtg, :Length_isnothing, self = true)
# Or DataFrame:
DataFrame(mtg, :Length_isnothing)

# We can also set the attribute name ourselves like so:
transform!(mtg, :Length =&gt; isnothing =&gt; :no_length)
descendants(mtg, :no_length, self = true)

# We can provide anonymous functions if we want to:
transform!(mtg, :Length =&gt; (x -&gt; isnothing(x)) =&gt; :no_length)
descendants(mtg, :no_length, self = true)

# When a node does not have an attribute, it returns `nothing`. Most basic functions do not
# handle those very well, e.g.:
transform!(mtg, :Length =&gt; log)
# It does not work because some nodes have no value for `:Length`.
# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:
transform!(mtg, :Length =&gt; log =&gt; :log_length, ignore_nothing = true)
descendants(mtg, :log_length, self = true)

# Or you could handle these manually in your function if you prefer:
transform!(mtg, :Length =&gt; (x -&gt; x === nothing ? nothing : log(x)) =&gt; :log_length2)
descendants(mtg, :log_length2, self = true)

# Another way is to give a filtering function as an argument:
transform!(mtg, :Length =&gt; log =&gt; :log_length, filter_fun = x -&gt; x[:Length] !== nothing)

# We can use more than one attribute as input to our function like so:
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :volume,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
descendants(mtg, :volume, self = true)

# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.

# We can also chain operations, and they will be executed sequentially so we can use variables
# computed on the instruction just before:
density = 0.6
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :vol,
    :vol =&gt; (x -&gt; x * density) =&gt; :biomass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :biomass])

# We can also rename a variable like so:
transform!(
    mtg,
    :biomass =&gt; :mass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :mass])

# Finnaly, we can use variables from ancestors/descendants using the `function =&gt; :new_var` form:
function get_mass_descendants(x)
    masses = descendants(x, :mass, ignore_nothing = true)
    if length(masses) == 0
        nothing
    else
        sum(masses)
    end
end

transform!(
    mtg,
    get_mass_descendants =&gt; :mass_beared
)
DataFrame(mtg, [:mass, :mass_beared])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/transform.jl#L1-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(node::Node, args..., &lt;keyword arguments&gt;)
transform(node::Node, args..., &lt;keyword arguments&gt;)</code></pre><p>Transform (mutate) an MTG (<code>node</code>) in place (<code>transform!</code>) or on a copy (<code>transform</code>) to add attributes specified by <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</p></li><li><p><code>args::Any</code>: the transformations (see details)</p></li><li><p>&lt;keyword arguments&gt;:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>ignore_nothing = false</code>: filter-out the nodes with <code>nothing</code> values for the given</li></ul><p>attributes used as inputs (apply only to the form :var_name =&gt; ...)</p></li></ul><p><strong>Returns</strong></p><p><code>transform!</code>: Nothing, mutates the (sub-)tree in-place. <code>transform</code>: A mutated copy of <code>node</code>.</p><p><strong>Notes</strong></p><p>Carefull, <code>transform</code> is much slower than <code>transform!</code> because it makes a copy of the whole MTG each time.</p><p><strong>Details</strong></p><p>The interface of the function is inspired from the one used in <a href="https://dataframes.juliadata.org/stable/"><code>DataFrames.jl</code></a>, but adapted to an MTG.</p><p>The <code>args...</code> provided can be of the following forms:</p><ol><li>a <code>:var_name =&gt; :new_var_name</code> pair. This form is used to rename an attribute name</li><li>a <code>:var_name =&gt; function</code> or <code>[:var_name1, :var_name2...] =&gt; function</code> pair. The variables</li></ol><p>are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.</p><ol><li>a <code>:var_name =&gt; function =&gt; :new_var_name</code> form that does the same as the previous form</li></ol><p>but explicitly naming the resulting variable (can take several variables on left-hand side).</p><ol><li>a <code>function =&gt; :new_var_name</code> form that applies a function to a node and puts the results</li></ol><p>in a new attribute. This form is usually applied when searching ancestors or descendants values.</p><ol><li>a <code>function</code> form that applies a mutating function to a node, without expecting any output.</li></ol><p>This form is adapted when using a function that already mutates the node, without the need to return anything, <em>e.g.</em> <a href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>branching_order!</code></a>.</p><p>Carefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))
transform!(mtg,  x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf

# We can compute a new variable based on another. For example to know if the value of the
# `:Length` attribute is provided or not, we can do:
transform!(mtg, :Length =&gt; isnothing)
# To check the values we first call [`get_attributes`](@ref) to know the new variable name:
get_attributes(mtg)
# And then we get the values using [`descendants`](@ref)
descendants(mtg, :Length_isnothing, self = true)
# Or DataFrame:
DataFrame(mtg, :Length_isnothing)

# We can also set the attribute name ourselves like so:
transform!(mtg, :Length =&gt; isnothing =&gt; :no_length)
descendants(mtg, :no_length, self = true)

# We can provide anonymous functions if we want to:
transform!(mtg, :Length =&gt; (x -&gt; isnothing(x)) =&gt; :no_length)
descendants(mtg, :no_length, self = true)

# When a node does not have an attribute, it returns `nothing`. Most basic functions do not
# handle those very well, e.g.:
transform!(mtg, :Length =&gt; log)
# It does not work because some nodes have no value for `:Length`.
# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:
transform!(mtg, :Length =&gt; log =&gt; :log_length, ignore_nothing = true)
descendants(mtg, :log_length, self = true)

# Or you could handle these manually in your function if you prefer:
transform!(mtg, :Length =&gt; (x -&gt; x === nothing ? nothing : log(x)) =&gt; :log_length2)
descendants(mtg, :log_length2, self = true)

# Another way is to give a filtering function as an argument:
transform!(mtg, :Length =&gt; log =&gt; :log_length, filter_fun = x -&gt; x[:Length] !== nothing)

# We can use more than one attribute as input to our function like so:
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :volume,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
descendants(mtg, :volume, self = true)

# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.

# We can also chain operations, and they will be executed sequentially so we can use variables
# computed on the instruction just before:
density = 0.6
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :vol,
    :vol =&gt; (x -&gt; x * density) =&gt; :biomass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :biomass])

# We can also rename a variable like so:
transform!(
    mtg,
    :biomass =&gt; :mass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :mass])

# Finnaly, we can use variables from ancestors/descendants using the `function =&gt; :new_var` form:
function get_mass_descendants(x)
    masses = descendants(x, :mass, ignore_nothing = true)
    if length(masses) == 0
        nothing
    else
        sum(masses)
    end
end

transform!(
    mtg,
    get_mass_descendants =&gt; :mass_beared
)
DataFrame(mtg, [:mass, :mass_beared])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/transform.jl#L1-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M&lt;:AbstractNodeMTG" href="#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M&lt;:AbstractNodeMTG"><code>MultiScaleTreeGraph.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new child to a parent node, and add the parent node as the parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.ancestors-Tuple{Any, Any}" href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>MultiScaleTreeGraph.ancestors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ancestors(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the ancestors (basipetal).</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the parent only: <code>recursivity_level = 1</code>, for parent + grand-parent: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the root.</p><ul><li><code>ignore_nothing = false</code>: filter-out the nodes with <code>nothing</code> values for the given <code>key</code></li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing an example mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Using a leaf node from the mtg:
leaf_node = mtg.children[2].children[3].children[4].children[5]

ancestors(leaf_node, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
ancestors(leaf_node, :Length, type = Union{Nothing,Float64})

# Filter by scale:
ancestors(leaf_node, :XX, scale = 1, type = Float64)
ancestors(leaf_node, :Length, scale = 3, type = Float64)

# Filter by symbol:
ancestors(leaf_node, :Length, symbol = &quot;Internode&quot;)
ancestors(leaf_node, :Length, symbol = (&quot;Axis&quot;,&quot;Internode&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/ancestors.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.branching_order!-Tuple{Any}" href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>MultiScaleTreeGraph.branching_order!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">branching_order!(mtg; ascend = true)</code></pre><p>Compute the topological branching order of the nodes in an mtg.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the mtg, <em>e.g.</em> output from <code>read_mtg()</code></li><li><code>ascend</code>: If <code>true</code>, the order is computed from the base (acropetal), if <code>false</code>,</li></ul><p>it is computed from the tip (basipetal).</p><p><strong>Notes</strong></p><p>The order of a node is computed from the maximum order of their children when using the basipetal computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
branching_order!(mtg)
DataFrame(mtg, :branching_order)
# 7×2 DataFrame
#  Row │ tree                        branching_order
#      │ String                      Int64
# ─────┼───────────────────────────────────────────────
#    1 │ / 1: $                                      1
#    2 │ └─ / 2: Individual                          1
#    3 │    └─ / 3: Axis                             1
#    4 │       └─ / 4: Internode                     1
#    5 │          ├─ + 5: Leaf                       2
#    6 │          └─ &lt; 6: Internode                  1
#    7 │             └─ + 7: Leaf                    2

branching_order!(mtg, ascend = false)
DataFrame(mtg, :branching_order)
# 7×2 DataFrame
#  Row │ tree                        branching_order
#      │ String                      Int64
# ─────┼───────────────────────────────────────────────
#    1 │ / 1: $                                      2
#    2 │ └─ / 2: Individual                          2
#    3 │    └─ / 3: Axis                             2
#    4 │       └─ / 4: Internode                     2
#    5 │          ├─ + 5: Leaf                       1
#    6 │          └─ &lt; 6: Internode                  2
#    7 │             └─ + 7: Leaf                    1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/mutation_helpers.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T" href="#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MultiScaleTreeGraph.check_filters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_filters(node; scale = nothing, symbol = nothing, link = nothing)</code></pre><p>Check if the filters are consistant with the mtg onto which they are applied</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">check_filters(mtg, scale = 1)
check_filters(mtg, scale = (1,2))
check_filters(mtg, scale = (1,2), symbol = &quot;Leaf&quot;, link = &quot;&lt;&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/check_filters.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.children-Tuple{Node}" href="#MultiScaleTreeGraph.children-Tuple{Node}"><code>MultiScaleTreeGraph.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">children(node::Node)</code></pre><p>Return the immediate children of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.clean_cache!-Tuple{Any}" href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>MultiScaleTreeGraph.clean_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clean_cache!(mtg)</code></pre><p>Clean the cached variables in the mtg, usually added from <a href="#MultiScaleTreeGraph.descendants!"><code>descendants!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/descendants.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.coordinates!-Tuple{Any}" href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>MultiScaleTreeGraph.coordinates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordinates!(mtg; angle = 45; force = false)</code></pre><p>Compute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.</p><p><strong>Returns</strong></p><p>Nothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
coordinates!(mtg)
DataFrame(mtg, [:XX, :YY, :ZZ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/plot_MTG/coordinates.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.delete_node!-Tuple{Any}" href="#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete<em>node!(node; child</em>link<em>fun = new</em>child_link)</p><p>Delete a node and re-parent the children to its own parent.</p><p>If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.</p><p><code>child_link_fun</code> is a function that takes the child node of a deleted node as input and returns its new link. The default function is <a href="#MultiScaleTreeGraph.new_child_link-Tuple{Any}"><code>new_child_link</code></a>, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn&#39;t be modified, use the following function instead:</p><pre><code class="language-julia hljs">node -&gt; node.MTG.link</code></pre><p>The function returns the parent node (or the new root if the node is a root)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/delete_nodes.jl#L105-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.delete_nodes!-Tuple{Any}" href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete_nodes!(mtg::Node,&lt;keyword arguments&gt;)</p><p>Delete nodes in mtg following filters rules.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale to delete. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to delete. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to delete. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first deletion (<code>true</code>), or stop?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a></li></ul><p>to decide whether to delete a node or not.</p><ul><li><code>child_link_fun = new_child_link</code>: a function that takes the child node of a deleted node</li></ul><p>as input and returns its new link (see details).</p><p><strong>Notes</strong></p><ol><li>The function is acropetal, meaning it will apply the deletion from leaves to the root to ensure</li></ol><p>that one pass is enough and we don&#39;t repeat the process of visiting already visited children.</p><ol><li>The function does not do anything fancy, it let the user take care of its own rules when</li></ol><p>deleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.</p><ol><li>The package provides some pre-made functions for filtering. See for example <a href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>is_segment!</code></a></li></ol><p>to re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.</p><ol><li>The default function used for <code>child_link_fun</code> is <a href="#MultiScaleTreeGraph.new_child_link-Tuple{Any}"><code>new_child_link</code></a>, which tries to be</li></ol><p>clever considering the parent and child links. See its help page for more information. If the link shouldn&#39;t be modified, use the following function instead:</p><pre><code class="language-julia hljs">node -&gt; node.MTG.link</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

delete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2

# Delete the leaves:
delete_nodes!(mtg, symbol = &quot;Leaf&quot;)
# Delete the leaves and internodes:
delete_nodes!(mtg, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Make the mtg match field measurements made only at branching points for the scales 1 + 2:
mtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/delete_nodes.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants" href="#MultiScaleTreeGraph.descendants"><code>MultiScaleTreeGraph.descendants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">descendants(node::Node,key,&lt;keyword arguments&gt;)
descendants!(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the descendants (acropetal). The mutating version (<code>descendants!</code>) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a>). It also only works for trees with attributes of subtype of <code>AbstractDict</code>.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the first level children only: <code>recursivity_level = 1</code>, for children + grand-children: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.</p><ul><li><code>ignore_nothing = false</code>: filter-out the nodes with <code>nothing</code> values for the given <code>key</code></li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Tips</strong></p><p>To get the values of the leaves use <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> as the filtering function, e.g.: <code>descendants(mtg, :Width; filter_fun = isleaf)</code>.</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

descendants(mtg, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
descendants(mtg, :Length, type = Union{Nothing,Float64})

# Filter by scale:
descendants(mtg, :XX, scale = 1, type = Float64)
descendants(mtg, :Length, scale = 3, type = Float64)

# Filter by symbol:
descendants(mtg, :Length, symbol = &quot;Leaf&quot;)
descendants(mtg, :Length, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Filter by function, e.g. get the values for the leaves only:
descendants(mtg, :Width; filter_fun = isleaf)

# It is possible to cache the results in the mtg. This is wqy faster when using
# `@mutate_mtg` (note the `!` at the end of the function name):
@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = &quot;Internode&quot;)), symbol = &quot;Internode&quot;)

function compute_subtree_length(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? sum(length_descendants) : nothing
end

function compute_subtree_length!(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants!(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? length_descendants : nothing
end

@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = &quot;Internode&quot;)

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
compute_subtree_length!(mtg)
DataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])

# You can then clean the cach to avoid using too much memory:
clean_cache!(mtg)
mtg[1][1][1].attributes
mtg[1][1][1][2].attributes
DataFrame(mtg, [:Length, :subtree_length])

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
node = mtg
key = :Length
scale = nothing
symbol = nothing
link = nothing
all= true
self = false
filter_fun = nothing
recursivity_level = -1
type = Any

# compute_subtree_length!(mtg)

descendants!(mtg, :Length, self = true)
DataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])
DataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/descendants.jl#L159-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants!" href="#MultiScaleTreeGraph.descendants!"><code>MultiScaleTreeGraph.descendants!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">descendants(node::Node,key,&lt;keyword arguments&gt;)
descendants!(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the descendants (acropetal). The mutating version (<code>descendants!</code>) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a>). It also only works for trees with attributes of subtype of <code>AbstractDict</code>.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the first level children only: <code>recursivity_level = 1</code>, for children + grand-children: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.</p><ul><li><code>ignore_nothing = false</code>: filter-out the nodes with <code>nothing</code> values for the given <code>key</code></li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Tips</strong></p><p>To get the values of the leaves use <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> as the filtering function, e.g.: <code>descendants(mtg, :Width; filter_fun = isleaf)</code>.</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

descendants(mtg, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
descendants(mtg, :Length, type = Union{Nothing,Float64})

# Filter by scale:
descendants(mtg, :XX, scale = 1, type = Float64)
descendants(mtg, :Length, scale = 3, type = Float64)

# Filter by symbol:
descendants(mtg, :Length, symbol = &quot;Leaf&quot;)
descendants(mtg, :Length, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Filter by function, e.g. get the values for the leaves only:
descendants(mtg, :Width; filter_fun = isleaf)

# It is possible to cache the results in the mtg. This is wqy faster when using
# `@mutate_mtg` (note the `!` at the end of the function name):
@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = &quot;Internode&quot;)), symbol = &quot;Internode&quot;)

function compute_subtree_length(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? sum(length_descendants) : nothing
end

function compute_subtree_length!(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants!(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? length_descendants : nothing
end

@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = &quot;Internode&quot;)

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
compute_subtree_length!(mtg)
DataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])

# You can then clean the cach to avoid using too much memory:
clean_cache!(mtg)
mtg[1][1][1].attributes
mtg[1][1][1][2].attributes
DataFrame(mtg, [:Length, :subtree_length])

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
node = mtg
key = :Length
scale = nothing
symbol = nothing
link = nothing
all= true
self = false
filter_fun = nothing
recursivity_level = -1
type = Any

# compute_subtree_length!(mtg)

descendants!(mtg, :Length, self = true)
DataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])
DataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/descendants.jl#L159-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants_!-NTuple{10, Any}" href="#MultiScaleTreeGraph.descendants_!-NTuple{10, Any}"><code>MultiScaleTreeGraph.descendants_!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fast version of descendants_ that mutates the mtg nodes to cache the information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/descendants.jl#L108-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.expand_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Expand MTG line</strong></p><p>Expand the elements denoted by the syntactic sugar &quot;&lt;&lt;&quot;, &quot;&lt;.&lt;&quot;, &quot;++&quot; or &quot;+.+&quot;</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{String}</code>: A split MTG line (e.g. c(&quot;/P1&quot;,&quot;/A1&quot;))</li><li><code>line::Array{Int64,1}</code>: The current line index (mutated) in the file. Only</li></ul><p>used as information when erroring.</p><p><strong>Returns</strong></p><p>A Tuple of:</p><ul><li>the split MTG line with all nodes explicitly</li><li>the nodes with common attributes (when using <code>&lt;.&lt;</code> or <code>+.+</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;,r&quot;(?&lt;=.)(?=[&lt;/+])&quot;);
nodes, shared = MultiScaleTreeGraph.expand_node!(x,1)
(AbstractString[&quot;/A1&quot;, &quot;+U85&quot;, &quot;/U86&quot;, &quot;&lt;U87&quot;, &quot;&lt;U88&quot;, &quot;&lt;U89&quot;, &quot;&lt;U90&quot;, &quot;&lt;U91&quot;, &quot;&lt;U92&quot;, &quot;&lt;U93&quot;, &quot;&lt;U94&quot;, &quot;&lt;U95&quot;, &quot;&lt;U96&quot;, &quot;&lt;U97&quot;, &quot;+U98&quot;, &quot;+U99&quot;, &quot;+U100&quot;], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/expand_node.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.extend_pos-NTuple{5, Any}" href="#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}"><code>MultiScaleTreeGraph.extend_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new point after (x1,y1) using same direction and length relative to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/plot_MTG/coordinates.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}" href="#MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.filter_fun_nothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_fun_nothing(filter_fun, ignore_nothing)</code></pre><p>Returns a new filtering function that adds a filter on the key value for <code>nothing</code> if <code>ignore_nothing</code> is <code>true</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/filter/filter-funs.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_attributes-Tuple{Any}" href="#MultiScaleTreeGraph.get_attributes-Tuple{Any}"><code>MultiScaleTreeGraph.get_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_attributes(node)</code></pre><p>Get all attributes names available on the node and its children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_classes-Tuple{Any}" href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>MultiScaleTreeGraph.get_classes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_classes(mtg)</code></pre><p>Compute the mtg classes based on its content. Usefull after having mutating the mtg nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/update_sections.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_description-Tuple{Any}" href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>MultiScaleTreeGraph.get_description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_description(mtg)</code></pre><p>Returns <code>nothing</code>, because we can&#39;t really predict the description section from an mtg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/update_sections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_features-Tuple{Any}" href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>MultiScaleTreeGraph.get_features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_features(mtg)</code></pre><p>Compute the mtg features section based on its attributes. Usefull after having computed new attributes in the mtg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/update_sections.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}" href="#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}"><code>MultiScaleTreeGraph.get_leading_tabs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_leading_tabs(node)</code></pre><p>Get the number of tabulation the node should have when writting it to a file based on the topology of its parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/write_mtg.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_node-Tuple{Node, String}" href="#MultiScaleTreeGraph.get_node-Tuple{Node, String}"><code>MultiScaleTreeGraph.get_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_node(node::Node, name::String)
get_node(node::Node, id::Int)</code></pre><p>Get a node in an mtg by name or id. If names are not unique in the MTG, the function will return the first it finds.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
node_6 = get_node(mtg, &quot;node_6&quot;)
node_6_2 = get_node(mtg, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/get_node.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_printing-Tuple{Node}" href="#MultiScaleTreeGraph.get_printing-Tuple{Node}"><code>MultiScaleTreeGraph.get_printing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_printing(node::Node; leading::AbstractString = &quot;&quot;)</code></pre><p>Format the printing of the tree according to link: follow or branching</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/print_MTG/print.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_reference-Tuple{Any}" href="#MultiScaleTreeGraph.get_reference-Tuple{Any}"><code>MultiScaleTreeGraph.get_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_reference(node)</code></pre><p>Get the preceding &quot;^&quot; keyword if needed, <em>i.e.</em> in case we refer to the parent node in the same mtg file column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/write_mtg.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_root-Tuple{Node}" href="#MultiScaleTreeGraph.get_root-Tuple{Node}"><code>MultiScaleTreeGraph.get_root</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the root node of a tree, given any node in the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_child!" href="#MultiScaleTreeGraph.insert_child!"><code>MultiScaleTreeGraph.insert_child!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parent!(node, template, max_id = [new_id(node)])
insert_generation!(node, template, max_id = [new_id(node)])
insert_child!(node, template, max_id = [new_id(node)])
insert_sibling!(node, template, max_id = [new_id(node)])</code></pre><p>Insert a node in an MTG as:</p><ul><li>a new parent of node: <code>insert_parent!</code></li><li>a new child of node: <code>insert_child!</code></li><li>a new sibling of node: <code>insert_sibling!</code></li><li>a new child of node, but the children of node become the children of the inserted node:</li></ul><p><code>insert_generation!</code></p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: The node from which to insert a node (as its parent, child or sibling).</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li><li><code>max_id::Vector{Int64}</code>: The maximum id of the nodes in the MTG as a vector of length one.</li></ul><p>Used to compute the name of the inserted node. It is incremented in the function, and use by default the value from <a href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>new_id</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

template = MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1)
mtg = insert_parent!(mtg[1][1], template)
mtg

# The template can be a function that returns the template. For example a dummy example would
# be a function that uses the NodeMTG of the first child of the node:

mtg = insert_parent!(
    mtg[1][1],
    x -&gt; (
        link = x[1].MTG.link,
        symbol = x[1].MTG.symbol,
        index = x[1].MTG.index,
        scale = x[1].MTG.scale)
    )
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L203-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_children!" href="#MultiScaleTreeGraph.insert_children!"><code>MultiScaleTreeGraph.insert_children!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parents!(node::Node, template, &lt;keyword arguments&gt;)
insert_generations!(node::Node, template, &lt;keyword arguments&gt;)
insert_children!(node::Node, template, &lt;keyword arguments&gt;)
insert_siblings!(node::Node, template, &lt;keyword arguments&gt;)</code></pre><p>Insert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.</p><p>Insert nodes programmatically in an MTG as:</p><ul><li>new parents of the filtered nodes: <code>insert_parents!</code></li><li>new children of the filtered nodes: <code>insert_children!</code></li><li>new siblings of the filtered node: <code>insert_siblings!</code></li><li>new children of the filtered nodes, but the previous children of the filtered node become</li></ul><p>the children of the inserted node: <code>insert_generations!</code></p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale at which to insert. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol at which to insert. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with at which to insert. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first insertion (<code>true</code>), or stop.</li><li><code>filter_fun = nothing</code>: Any function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to decide</li></ul><p>on which node the insertion will be based on.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

# Insert new Shoot nodes before all scale 2 nodes:
mtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1), scale = 2)

mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_generation!" href="#MultiScaleTreeGraph.insert_generation!"><code>MultiScaleTreeGraph.insert_generation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parent!(node, template, max_id = [new_id(node)])
insert_generation!(node, template, max_id = [new_id(node)])
insert_child!(node, template, max_id = [new_id(node)])
insert_sibling!(node, template, max_id = [new_id(node)])</code></pre><p>Insert a node in an MTG as:</p><ul><li>a new parent of node: <code>insert_parent!</code></li><li>a new child of node: <code>insert_child!</code></li><li>a new sibling of node: <code>insert_sibling!</code></li><li>a new child of node, but the children of node become the children of the inserted node:</li></ul><p><code>insert_generation!</code></p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: The node from which to insert a node (as its parent, child or sibling).</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li><li><code>max_id::Vector{Int64}</code>: The maximum id of the nodes in the MTG as a vector of length one.</li></ul><p>Used to compute the name of the inserted node. It is incremented in the function, and use by default the value from <a href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>new_id</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

template = MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1)
mtg = insert_parent!(mtg[1][1], template)
mtg

# The template can be a function that returns the template. For example a dummy example would
# be a function that uses the NodeMTG of the first child of the node:

mtg = insert_parent!(
    mtg[1][1],
    x -&gt; (
        link = x[1].MTG.link,
        symbol = x[1].MTG.symbol,
        index = x[1].MTG.index,
        scale = x[1].MTG.scale)
    )
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L203-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_generations!" href="#MultiScaleTreeGraph.insert_generations!"><code>MultiScaleTreeGraph.insert_generations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parents!(node::Node, template, &lt;keyword arguments&gt;)
insert_generations!(node::Node, template, &lt;keyword arguments&gt;)
insert_children!(node::Node, template, &lt;keyword arguments&gt;)
insert_siblings!(node::Node, template, &lt;keyword arguments&gt;)</code></pre><p>Insert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.</p><p>Insert nodes programmatically in an MTG as:</p><ul><li>new parents of the filtered nodes: <code>insert_parents!</code></li><li>new children of the filtered nodes: <code>insert_children!</code></li><li>new siblings of the filtered node: <code>insert_siblings!</code></li><li>new children of the filtered nodes, but the previous children of the filtered node become</li></ul><p>the children of the inserted node: <code>insert_generations!</code></p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale at which to insert. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol at which to insert. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with at which to insert. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first insertion (<code>true</code>), or stop.</li><li><code>filter_fun = nothing</code>: Any function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to decide</li></ul><p>on which node the insertion will be based on.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

# Insert new Shoot nodes before all scale 2 nodes:
mtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1), scale = 2)

mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any, Any}" href="#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.insert_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Actual workhorse of insert<em>parents!, insert</em>generations!, insert<em>children!, insert</em>siblings!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_parent!" href="#MultiScaleTreeGraph.insert_parent!"><code>MultiScaleTreeGraph.insert_parent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parent!(node, template, max_id = [new_id(node)])
insert_generation!(node, template, max_id = [new_id(node)])
insert_child!(node, template, max_id = [new_id(node)])
insert_sibling!(node, template, max_id = [new_id(node)])</code></pre><p>Insert a node in an MTG as:</p><ul><li>a new parent of node: <code>insert_parent!</code></li><li>a new child of node: <code>insert_child!</code></li><li>a new sibling of node: <code>insert_sibling!</code></li><li>a new child of node, but the children of node become the children of the inserted node:</li></ul><p><code>insert_generation!</code></p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: The node from which to insert a node (as its parent, child or sibling).</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li><li><code>max_id::Vector{Int64}</code>: The maximum id of the nodes in the MTG as a vector of length one.</li></ul><p>Used to compute the name of the inserted node. It is incremented in the function, and use by default the value from <a href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>new_id</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

template = MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1)
mtg = insert_parent!(mtg[1][1], template)
mtg

# The template can be a function that returns the template. For example a dummy example would
# be a function that uses the NodeMTG of the first child of the node:

mtg = insert_parent!(
    mtg[1][1],
    x -&gt; (
        link = x[1].MTG.link,
        symbol = x[1].MTG.symbol,
        index = x[1].MTG.index,
        scale = x[1].MTG.scale)
    )
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L203-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_parents!" href="#MultiScaleTreeGraph.insert_parents!"><code>MultiScaleTreeGraph.insert_parents!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parents!(node::Node, template, &lt;keyword arguments&gt;)
insert_generations!(node::Node, template, &lt;keyword arguments&gt;)
insert_children!(node::Node, template, &lt;keyword arguments&gt;)
insert_siblings!(node::Node, template, &lt;keyword arguments&gt;)</code></pre><p>Insert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.</p><p>Insert nodes programmatically in an MTG as:</p><ul><li>new parents of the filtered nodes: <code>insert_parents!</code></li><li>new children of the filtered nodes: <code>insert_children!</code></li><li>new siblings of the filtered node: <code>insert_siblings!</code></li><li>new children of the filtered nodes, but the previous children of the filtered node become</li></ul><p>the children of the inserted node: <code>insert_generations!</code></p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale at which to insert. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol at which to insert. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with at which to insert. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first insertion (<code>true</code>), or stop.</li><li><code>filter_fun = nothing</code>: Any function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to decide</li></ul><p>on which node the insertion will be based on.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

# Insert new Shoot nodes before all scale 2 nodes:
mtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1), scale = 2)

mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_sibling!" href="#MultiScaleTreeGraph.insert_sibling!"><code>MultiScaleTreeGraph.insert_sibling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parent!(node, template, max_id = [new_id(node)])
insert_generation!(node, template, max_id = [new_id(node)])
insert_child!(node, template, max_id = [new_id(node)])
insert_sibling!(node, template, max_id = [new_id(node)])</code></pre><p>Insert a node in an MTG as:</p><ul><li>a new parent of node: <code>insert_parent!</code></li><li>a new child of node: <code>insert_child!</code></li><li>a new sibling of node: <code>insert_sibling!</code></li><li>a new child of node, but the children of node become the children of the inserted node:</li></ul><p><code>insert_generation!</code></p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: The node from which to insert a node (as its parent, child or sibling).</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li><li><code>max_id::Vector{Int64}</code>: The maximum id of the nodes in the MTG as a vector of length one.</li></ul><p>Used to compute the name of the inserted node. It is incremented in the function, and use by default the value from <a href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>new_id</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

template = MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1)
mtg = insert_parent!(mtg[1][1], template)
mtg

# The template can be a function that returns the template. For example a dummy example would
# be a function that uses the NodeMTG of the first child of the node:

mtg = insert_parent!(
    mtg[1][1],
    x -&gt; (
        link = x[1].MTG.link,
        symbol = x[1].MTG.symbol,
        index = x[1].MTG.index,
        scale = x[1].MTG.scale)
    )
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L203-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_siblings!" href="#MultiScaleTreeGraph.insert_siblings!"><code>MultiScaleTreeGraph.insert_siblings!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_parents!(node::Node, template, &lt;keyword arguments&gt;)
insert_generations!(node::Node, template, &lt;keyword arguments&gt;)
insert_children!(node::Node, template, &lt;keyword arguments&gt;)
insert_siblings!(node::Node, template, &lt;keyword arguments&gt;)</code></pre><p>Insert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.</p><p>Insert nodes programmatically in an MTG as:</p><ul><li>new parents of the filtered nodes: <code>insert_parents!</code></li><li>new children of the filtered nodes: <code>insert_children!</code></li><li>new siblings of the filtered node: <code>insert_siblings!</code></li><li>new children of the filtered nodes, but the previous children of the filtered node become</li></ul><p>the children of the inserted node: <code>insert_generations!</code></p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>template</code>:<ul><li>A template <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> or <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> used for the inserted node,</li><li>A NamedTuple with values for link, symbol, index, and scale</li><li>Or a function taking the node as input and returning said template</li></ul></li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale at which to insert. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol at which to insert. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with at which to insert. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first insertion (<code>true</code>), or stop.</li><li><code>filter_fun = nothing</code>: Any function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to decide</li></ul><p>on which node the insertion will be based on.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

# Insert new Shoot nodes before all scale 2 nodes:
mtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1), scale = 2)

mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.is_filtered-NTuple{5, Any}" href="#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}"><code>MultiScaleTreeGraph.is_filtered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_filtered(node, scale, symbol, link, filter_fun)</code></pre><p>Is a node filtered in ? Returns <code>true</code> if the node is kept, <code>false</code> if it is filtered-out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/check_filters.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.is_segment!-Tuple{Any}" href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>MultiScaleTreeGraph.is_segment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_segment(node)</code></pre><p>Checks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.</p><p>The function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.</p><p>See <a href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> for an example of application.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/filter/filter-funs.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.isleaf-Tuple{Node}" href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>MultiScaleTreeGraph.isleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isleaf(node::Node)</code></pre><p>Test whether a node is a leaf or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.isroot-Tuple{Node}" href="#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>MultiScaleTreeGraph.isroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isroot(node::Node)</code></pre><p>Return <code>true</code> if <code>node</code> is the root node (meaning, it has no parent).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.issection-Tuple{Any, Any}" href="#MultiScaleTreeGraph.issection-Tuple{Any, Any}"><code>MultiScaleTreeGraph.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issection(string,section)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>string::String</code>: The string to test.</li><li><code>section::String</code>: The section to test.</li></ul><pre><code class="language-julia hljs">issection(&quot;CODE :&quot;, &quot;CODE&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/utils-string.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.issection-Tuple{Any}" href="#MultiScaleTreeGraph.issection-Tuple{Any}"><code>MultiScaleTreeGraph.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issection(string)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><pre><code class="language-julia hljs">issection(&quot;CODE :&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/utils-string.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.max_id-Tuple{Any}" href="#MultiScaleTreeGraph.max_id-Tuple{Any}"><code>MultiScaleTreeGraph.max_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_id(mtg)</code></pre><p>Returns the maximum id of the mtg</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}" href="#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}"><code>MultiScaleTreeGraph.mtg_coordinates_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mtg_coordinates_df(mtg; force = false)
mtg_coordinates_df!(mtg; force = false)</code></pre><p>Extract the coordinates of the nodes of the mtg and the coordinates of their parents (:XX<em>from, :YY</em>from, :ZZ_from) and output a DataFrame.</p><p>The coordinates are computed using <a href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>coordinates!</code></a> if missing, or if <code>force = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/plot_MTG/coordinates.jl#L126-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.new_child_link-Tuple{Any}" href="#MultiScaleTreeGraph.new_child_link-Tuple{Any}"><code>MultiScaleTreeGraph.new_child_link</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_child_link(node)</code></pre><p>Compute the new link of the child node when deleting a parent node. The rule is to give the child node link of its parent node that is deleted, except when the parent was following its own parent.</p><p>The node given as input is the child node here.</p><p>The rule is summarized in the following table:</p><table><tr><th style="text-align: center">Deleted node link</th><th style="text-align: center">Child node link</th><th style="text-align: center">New child node link</th><th style="text-align: center">warning</th></tr><tr><td style="text-align: center">/</td><td style="text-align: center">/</td><td style="text-align: center">/</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">/</td><td style="text-align: center">+</td><td style="text-align: center">+</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: center">/</td><td style="text-align: center">&lt;</td><td style="text-align: center">/</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">+</td><td style="text-align: center">/</td><td style="text-align: center">/</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: center">+</td><td style="text-align: center">+</td><td style="text-align: center">+</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">+</td><td style="text-align: center">&lt;</td><td style="text-align: center">+</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">&lt;</td><td style="text-align: center">/</td><td style="text-align: center">/</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">&lt;</td><td style="text-align: center">+</td><td style="text-align: center">+</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">&lt;</td><td style="text-align: center">&lt;</td><td style="text-align: center">&lt;</td><td style="text-align: center"></td></tr></table><p>The warnings happens when there is no satisfactory way to handle the new link, <em>i.e.</em> when mixing branching and change in scale.</p><p>Note that in the case (1) of the warning the first child only takes the &quot;/&quot; link, the others keep their links.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/delete_nodes.jl#L170-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.new_id-Tuple{Int64}" href="#MultiScaleTreeGraph.new_id-Tuple{Int64}"><code>MultiScaleTreeGraph.new_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_id(mtg)
new_id(mtg, max_id)</code></pre><p>Make a new unique identifier by incrementing on the maximum node id. Hint: prefer using <code>max_id = max_id(mtg)</code> and then <code>new_id(mtg, max_is)</code> for performance if you do it repeatidely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L129-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}" href="#MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}"><code>MultiScaleTreeGraph.new_node_MTG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_node_MTG(node, template&lt;:Union{NodeMTG,MutableNodeMTG,NamedTuple,MutableNamedTuple})
new_node_MTG(node, fn)</code></pre><p>Returns a new NodeMTG matching the one used in node (either <code>NodeMTG</code> or <code>MutableNodeMTG</code>) based on a template, or on a function that takes a node as input and return said template.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# using a NodeMTG as a template:
MultiScaleTreeGraph.new_node_MTG(mtg, NodeMTG(&quot;/&quot;, &quot;Leaf&quot;, 1, 2))
# Note that it returns a MutableNodeMTG because `mtg` is using this type instead of a `NodeMTG`

# using a NamedTuple as a template:
MultiScaleTreeGraph.new_node_MTG(mtg, (link = &quot;/&quot;, symbol = &quot;Leaf&quot;, index = 1, scale = 2))

# using a function that returns a template based on the first child of the node:
MultiScaleTreeGraph.new_node_MTG(
    mtg,
    x -&gt; (
            link = x[1].MTG.link,
            symbol = x[1].MTG.symbol,
            index = x[1].MTG.index,
            scale = x[1].MTG.scale)
        )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/insert_nodes.jl#L163-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.next_line!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.next_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_line!(f,line)</code></pre><p><strong>Read line</strong></p><p>Read the next line in the IO stream, strip the comments, the missing values and increment the line index.</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/utils-string.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves" href="#MultiScaleTreeGraph.nleaves"><code>MultiScaleTreeGraph.nleaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nleaves(node)
nleaves!(node)</code></pre><p>Get the total number of leaves a node is bearing, <em>i.e.</em> the number of terminal nodes. <code>nleaves!</code> is faster than <code>nleaves</code> but cache the results in a variable so it uses more memory. Please use <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after calling <code>nleaves!</code> to clean the temporary variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

nleaves!(mtg)

clean_cache!(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/nleaves.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves!" href="#MultiScaleTreeGraph.nleaves!"><code>MultiScaleTreeGraph.nleaves!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nleaves(node)
nleaves!(node)</code></pre><p>Get the total number of leaves a node is bearing, <em>i.e.</em> the number of terminal nodes. <code>nleaves!</code> is faster than <code>nleaves</code> but cache the results in a variable so it uses more memory. Please use <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after calling <code>nleaves!</code> to clean the temporary variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

nleaves!(mtg)

clean_cache!(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/nleaves.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}" href="#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}"><code>MultiScaleTreeGraph.nleaves_siblings!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nleaves_siblings!(x)</code></pre><p>Compute how many leaves the siblings of node x bear.</p><p>Please call <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after using <code>nleaves_siblings!</code> because it creates temporary variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/nleaves.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}" href="#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MultiScaleTreeGraph.node_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Instantiate a <code>attr_type</code> struct with <code>node_attr</code> keys and values</p><p><strong>Arguments</strong></p><ul><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>node_attr::String</code>: The node attributes as a <a href="@ref"><code>Base.Dict</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/parse_mtg.jl#L325-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.ordered_children-Tuple{Any}" href="#MultiScaleTreeGraph.ordered_children-Tuple{Any}"><code>MultiScaleTreeGraph.ordered_children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ordered_children(node)</code></pre><p>Return the children as an array, ordered first by &quot;+&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}" href="#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}"><code>MultiScaleTreeGraph.parse_MTG_node</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Parse MTG node</strong></p><p>Parse MTG nodes (called from <code>parse_mtg!()</code>)</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: An MTG node (e.g. &quot;/Individual0&quot;)</li></ul><p><strong>Return</strong></p><p>A parsed node in the form of a Dict of three:</p><ul><li>the link</li><li>the symbol</li><li>and the index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/parse_mtg.jl#L215-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}" href="#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_MTG_node_attr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG node attributes names, values and type</p><p><strong>Arguments</strong></p><ul><li><code>node_data::String</code>: A splitted mtg node data (attributes)</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>features::DataFrame</code>: The features data.frame</li><li><code>attr_column_start::Integer</code>: The index of the column of the first attribute</li><li><code>line::Integer</code>: The current line of the mtg file</li><li><code>force::Bool</code>: force data reading even if errors are met during conversion ?</li></ul><p><strong>Return</strong></p><p>A list of attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/parse_mtg.jl#L252-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_macro_args-Tuple{Any}" href="#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}"><code>MultiScaleTreeGraph.parse_macro_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_macro_args(args)</code></pre><p>Parse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">args = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))
MultiScaleTreeGraph.parse_macro_args(args)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/check_filters.jl#L81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}" href="#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}"><code>MultiScaleTreeGraph.parse_mtg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code></li><li><code>classes::Array</code>: The class section data as returned by <code>parse_section!</code></li><li><code>description::Array</code>: The description section data as returned by <code>parse_section!</code></li><li><code>features::Array</code>: The features section data as returned by <code>parse_section!</code></li><li><code>line::Array{Int64,1}</code>: The current line index (mutated). Must be given as line of <code>MTG:</code></li><li><code>l::Array{String,1}</code>: the current line</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed MTG section</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/parse_mtg.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_section!-NTuple{5, Any}" href="#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_section!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>header::Array{String,1}</code>: A string defining the expected header for the class.</li><li><code>section::String</code>: The section name.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>l::Array{String,1}</code>: the current line</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed section of the MTG</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
f = open(file, &quot;r&quot;)
line = [0] ; l = [&quot;&quot;]; l[1] = MultiScaleTreeGraph.next_line!(f,line)

while MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],&quot;CLASSES&quot;)
    l[1] = MultiScaleTreeGraph.next_line!(f,line)
end

classes = MultiScaleTreeGraph.parse_section!(f,[&quot;SYMBOL&quot;,&quot;SCALE&quot;,&quot;DECOMPOSITION&quot;,&quot;INDEXATION&quot;,&quot;DEFINITION&quot;],&quot;CLASSES&quot;,line,l)

close(f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/parse_section.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}" href="#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}"><code>MultiScaleTreeGraph.paste_mtg_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paste_mtg_node(node)</code></pre><p>Parse the mtg node as it should appear in the mtg file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/write_mtg.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}" href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pipe_model!(node, var_name, threshold_value; allow_missing = false)</code></pre><p>Same than <code>pipe_model!</code> but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (<code>:var_name</code>) is well measured down to <em>e.g.</em> 2-3cm of diameter, but should be computed below.</p><p>This function allows to compute the cross-section using the pipe model <strong>only</strong> for some sub-trees with values of <code>:var_name &lt;= threshold_value</code>.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the mtg, or a specific node at which to start from.</li><li><code>var_name</code>: the name of the cross-section attribute name in the nodes</li><li><code>threshold_value</code>: the threshold defining the value below which the cross-section will be</li></ul><p>re-computed using the pipe model instead of using <code>var_name</code>.</p><ul><li><code>allow_missing=false</code>: Allow missing values for <code>var_name</code>, in which case the cross-section is</li></ul><p>recomputed using the pipe model. Please use this option only if you know why.</p><p><strong>Details</strong></p><p>The node cross-section is partitioned from parent to children according to the number of leaves (<em>i.e.</em> terminal nodes) each child subtree has, unless one or more children has a <code>:var_name &gt; threshold_value</code>. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with <code>:var_name &lt;= threshold_value</code> will be shared as usual using their number of leaves. If <code>:var_name</code> of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.</p><p><strong>Word of caution</strong></p><p>Some tips when using this function:</p><ul><li>User must ensure that <code>:var_name</code> has a value for all nodes in the mtg before calling this</li></ul><p>version of <code>pipe_model!</code>, unless <code>allow_missing=true</code>.</p><ul><li>Nodes with untrusted values should be</li></ul><p>set to a value below the threshold value to make <code>pipe_model!</code> recompute them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/pipe_model.jl#L43-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pipe_model!(node, root_value)</code></pre><p>Computes the cross-section of <code>node</code> considering its topological environment and the cross-section at the root node (<code>root_value</code>).</p><p>The pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.</p><p>The implementation uses the following algorithm:</p><p>First, check how many children a node has.</p><p>If it has one child only, the child cross-section is equal to the node cross-section.</p><p>If more children, the node cross-section is shared between the children according to the number of leaf nodes their subtree has, <em>i.e.</em> the total number of terminal nodes of their subtree.</p><p>Please call <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after using <code>pipe_model!</code> because it creates temporary variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/pipe_model.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.read_mtg" href="#MultiScaleTreeGraph.read_mtg"><code>MultiScaleTreeGraph.read_mtg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG; sheet_name = nothing)</code></pre><p>Read an MTG file</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file.</li><li><code>attr_type::DataType = Dict</code>: the type used to hold the attribute values for each node.</li><li><code>mtg_type = MutableNodeMTG</code>: the type used to hold the mtg encoding for each node (<em>i.e.</em></li></ul><p>link, symbol, index, scale). See details section below.</p><ul><li><code>sheet_name = nothing</code>: the sheet name in case you&#39;re reading an <code>xlsx</code> or <code>xlsm</code> file. It</li></ul><p>reads the first sheet if <code>nothing</code> (default behavior).</p><p><strong>Details</strong></p><p><code>attr_type</code> should be:</p><ul><li><code>NamedTuple</code> if you don&#39;t plan to modify the attributes of the mtg, <em>e.g.</em> to use them for</li></ul><p>plotting or computing statistics...</p><ul><li><code>MutableNamedTuple</code> if you plan to modify the attributes values but not adding new attributes</li></ul><p>very often, <em>e.g.</em> recompute an attribute value...</p><ul><li><code>Dict</code> or similar (<em>e.g.</em> <code>OrderedDict</code>) if you plan to heavily modify the attributes, <em>e.g.</em></li></ul><p>adding/removing attributes a lot</p><p>The <code>MultiScaleTreeGraph</code> package provides two types for <code>mtg_type</code>, one immutable (<a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a>), and one mutable (<a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a>). If you&#39;re planning on modifying the mtg encoding of some of your nodes, you should use <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a>, and if you don&#39;t want to modify anything, use <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> instead as it should be faster.</p><p><strong>Note</strong></p><p>See the documentation of the MTG format from the package documentation for further details, <em>e.g.</em> <a href="../the_mtg/mtg_concept/#The-MTG-concept">The MTG concept</a>.</p><p><strong>Returns</strong></p><p>The MTG root node.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:
mtg = read_mtg(file,Dict);

# We can also read an mtg directly from an excel file from the field:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;tree3h.xlsx&quot;)
mtg = read_mtg(file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/read_MTG.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}" href="#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}"><code>MultiScaleTreeGraph.rewrite_expr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite_expr!(arguments)</code></pre><p>Re-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add <code>attributes</code> after the node if it is an attribute.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">test = :(x = node.name)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.name)

test = :(x = node.foo)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.attributes[:foo])

test = :(x = node.MTG.symbol)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.MTG.symbol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/mutation.jl#L112-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.rotate_point-NTuple{5, Any}" href="#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}"><code>MultiScaleTreeGraph.rotate_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Rotate a point (x1,y1) around (x0, y0) with <code>angle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/plot_MTG/coordinates.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.siblings-Tuple{Node}" href="#MultiScaleTreeGraph.siblings-Tuple{Node}"><code>MultiScaleTreeGraph.siblings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siblings(node::Node)</code></pre><p>Return the siblings of <code>node</code> as a vector of nodes (or <code>nothing</code> if non-existant).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/Tree_funs.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}" href="#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}"><code>MultiScaleTreeGraph.split_MTG_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_MTG_elements(l)</code></pre><p><strong>Split MTG line</strong></p><p>Split the elements (e.g. inter-node, growth unit...) in an MTG line</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: A string for an MTG line (e.g. &quot;/P1/A1&quot;).</li></ul><p><strong>Return</strong></p><p>A vector of elements (keeping their link, e.g. + or &lt;)</p><pre><code class="language-julia hljs">split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;, r&quot;(?&lt;=.)(?=[&lt;/+])&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/utils-string.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.strip_comments" href="#MultiScaleTreeGraph.strip_comments"><code>MultiScaleTreeGraph.strip_comments</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Strip comments from a string</p><pre><code class="nohighlight hljs">striplinecomment{T&lt;:String,U&lt;:String}(a::T, cchars::U=&quot;#;&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: the string from which the comments has to be stripped</li><li><code>cchars::String</code>: the characters that defines comments</li></ul><p>From https://rosettacode.org/wiki/Strip<em>comments</em>from<em>a</em>string#Julia</p><ul><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul><pre><code class="language-julia hljs">strip_comments(&quot;test1&quot;)
strip_comments(&quot;test2 # with a comment&quot;)
strip_comments(&quot;# just a comment&quot;)
&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/strip_comments.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.traverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse!(node::Node, f::Function[, args...], &lt;keyword arguments&gt;)
traverse(node::Node, f::Function[, args...], &lt;keyword arguments&gt;)</code></pre><p>Traverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use <code>traverse!</code>) or not (use <code>traverse</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</p></li><li><p><code>f::Function</code>: a function to apply over each node</p></li><li><p><code>args::Any</code>: any argument to pass to the function</p></li><li><p>&lt;keyword arguments&gt;:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li></ul></li></ul><p><strong>Returns</strong></p><p>Nothing for <code>traverse!</code> because it mutates the (sub-)tree in-place, or an Array of whatever the function returns for <code>traverse</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
traverse!(mtg, x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf

# We can also use the `do...end` block notation when we have a complex set of instructions:
traverse!(mtg) do x
    if isleaf(x)
         println(x.name,&quot; is a leaf&quot;)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/traverse.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}" href="#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}"><code>MultiScaleTreeGraph.unsafe_getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;], but in an unsafe way, meaning it returns <code>nothing</code> when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/read_MTG/NodeMTG.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}" href="#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}"><code>MultiScaleTreeGraph.write_mtg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_mtg(file, mtg; kwargs...)
write_mtg(file, mtg, classes, description, features)</code></pre><p>Write an mtg file to disk.</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file to write.</li><li><code>mtg</code>: the mtg</li><li><code>classes</code>: the classes section</li><li><code>description</code>: the description section</li><li><code>features</code>: the features section</li></ul><p><strong>Note</strong></p><p>kwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using <a href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>get_classes</code></a>, <a href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>get_features</code></a> or <a href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>get_description</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
write_mtg(&quot;test.mtg&quot;,mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/write_mtg/write_mtg.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_mtg!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mutate_mtg!(node, args...,kwargs...)</code></pre><p>Mutate the mtg nodes in place.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the mtg to mutate</li><li><code>args...</code>: The computations to apply to the nodes (see examples)</li><li><code>kwargs...</code>: Optional keyword arguments for traversing and filtering (see details)</li></ul><p><strong>Details</strong></p><p>As for <a href="#MultiScaleTreeGraph.descendants"><code>descendants</code></a> and <a href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>ancestors</code></a>, kwargs can be any filter from:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>traversal</code>: The type of tree traversal. By default it is using <code>AbstractTrees.PreOrderDFS</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Compute a new attribute with the scales and add 2 to its values:
@mutate_mtg!(mtg, scaling = node.scales .+ 2)

# Compute several new attributes, some based on others:
@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_mtg! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/mutation.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_node!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mutate_node!(node, args...)</code></pre><p>Mutate a single node in place.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the node to mutate</li><li><code>args...</code>: The computations to apply to the node (see examples)</li></ul><p><strong>See also</strong></p><p><a href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>@mutate_mtg!</code></a> to mutate all nodes of an mtg.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Compute a new attribute with the scales and add 2 to its values:
@mutate_node!(mtg, scaling = node.scales .+ 2)

# The computation is only applied to the root node. To apply it to all nodes,
# see @mutate_mtg!

# Compute several new attributes, some based on others:
@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_node! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/fb698833bd2d7b1c3e753c620303eba5d02d4021/src/compute_MTG/mutation.jl#L70-L104">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/6.add_remove_nodes/">« Add/remove nodes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 2 December 2021 10:20">Thursday 2 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
