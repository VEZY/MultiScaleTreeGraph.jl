<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MultiScaleTreeGraph.jl</title><link rel="canonical" href="https://VEZY.github.io/MultiScaleTreeGraph.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MultiScaleTreeGraph.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../get_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiScaleTreeGraph.jl-functions"><a class="docs-heading-anchor" href="#MultiScaleTreeGraph.jl-functions">MultiScaleTreeGraph.jl functions</a><a id="MultiScaleTreeGraph.jl-functions-1"></a><a class="docs-heading-anchor-permalink" href="#MultiScaleTreeGraph.jl-functions" title="Permalink"></a></h1><p>Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you&#39;ll be directed to the function help.</p><ul><li><a href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a></li><li><a href="#MetaGraphsNext.MetaGraph-Tuple{Node}"><code>MetaGraphsNext.MetaGraph</code></a></li><li><a href="#MultiScaleTreeGraph.AbstractNodeMTG"><code>MultiScaleTreeGraph.AbstractNodeMTG</code></a></li><li><a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MultiScaleTreeGraph.MutableNodeMTG</code></a></li><li><a href="#MultiScaleTreeGraph.NodeMTG"><code>MultiScaleTreeGraph.NodeMTG</code></a></li><li><a href="#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}"><code>Base.append!</code></a></li><li><a href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a></li><li><a href="#Base.length-Tuple{Node}"><code>Base.length</code></a></li><li><a href="#Base.print-Tuple{Node}"><code>Base.print</code></a></li><li><a href="#DataFrames.transform!-Tuple{Node, Vararg{Any, N} where N}"><code>DataFrames.transform!</code></a></li><li><a href="#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M&lt;:AbstractNodeMTG"><code>MultiScaleTreeGraph.addchild!</code></a></li><li><a href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>MultiScaleTreeGraph.ancestors</code></a></li><li><a href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>MultiScaleTreeGraph.branching_order!</code></a></li><li><a href="#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MultiScaleTreeGraph.check_filters</code></a></li><li><a href="#MultiScaleTreeGraph.children-Tuple{Node}"><code>MultiScaleTreeGraph.children</code></a></li><li><a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>MultiScaleTreeGraph.clean_cache!</code></a></li><li><a href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>MultiScaleTreeGraph.coordinates!</code></a></li><li><a href="#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_node!</code></a></li><li><a href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_nodes!</code></a></li><li><a href="#MultiScaleTreeGraph.descendants"><code>MultiScaleTreeGraph.descendants</code></a></li><li><a href="#MultiScaleTreeGraph.descendants!"><code>MultiScaleTreeGraph.descendants!</code></a></li><li><a href="#MultiScaleTreeGraph.descendants_!-NTuple{11, Any}"><code>MultiScaleTreeGraph.descendants_!</code></a></li><li><a href="#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.expand_node!</code></a></li><li><a href="#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}"><code>MultiScaleTreeGraph.extend_pos</code></a></li><li><a href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>MultiScaleTreeGraph.get_classes</code></a></li><li><a href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>MultiScaleTreeGraph.get_description</code></a></li><li><a href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>MultiScaleTreeGraph.get_features</code></a></li><li><a href="#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}"><code>MultiScaleTreeGraph.get_leading_tabs</code></a></li><li><a href="#MultiScaleTreeGraph.get_node-Tuple{Node, Any}"><code>MultiScaleTreeGraph.get_node</code></a></li><li><a href="#MultiScaleTreeGraph.get_printing-Tuple{Node}"><code>MultiScaleTreeGraph.get_printing</code></a></li><li><a href="#MultiScaleTreeGraph.get_reference-Tuple{Any}"><code>MultiScaleTreeGraph.get_reference</code></a></li><li><a href="#MultiScaleTreeGraph.getroot-Tuple{Node}"><code>MultiScaleTreeGraph.getroot</code></a></li><li><a href="#MultiScaleTreeGraph.insert_node!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.insert_node!</code></a></li><li><a href="#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.insert_nodes!</code></a></li><li><a href="#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}"><code>MultiScaleTreeGraph.is_filtered</code></a></li><li><a href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>MultiScaleTreeGraph.is_segment!</code></a></li><li><a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>MultiScaleTreeGraph.isleaf</code></a></li><li><a href="#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>MultiScaleTreeGraph.isroot</code></a></li><li><a href="#MultiScaleTreeGraph.issection-Tuple{Any, Any}"><code>MultiScaleTreeGraph.issection</code></a></li><li><a href="#MultiScaleTreeGraph.issection-Tuple{Any}"><code>MultiScaleTreeGraph.issection</code></a></li><li><a href="#MultiScaleTreeGraph.max_name-Tuple{Any}"><code>MultiScaleTreeGraph.max_name</code></a></li><li><a href="#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}"><code>MultiScaleTreeGraph.mtg_coordinates_df</code></a></li><li><a href="#MultiScaleTreeGraph.new_name-Tuple{Any, Any}"><code>MultiScaleTreeGraph.new_name</code></a></li><li><a href="#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.next_line!</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves"><code>MultiScaleTreeGraph.nleaves</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves!"><code>MultiScaleTreeGraph.nleaves!</code></a></li><li><a href="#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}"><code>MultiScaleTreeGraph.nleaves_siblings!</code></a></li><li><a href="#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MultiScaleTreeGraph.node_attributes</code></a></li><li><a href="#MultiScaleTreeGraph.ordered_children-Tuple{Any}"><code>MultiScaleTreeGraph.ordered_children</code></a></li><li><a href="#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}"><code>MultiScaleTreeGraph.parse_MTG_node</code></a></li><li><a href="#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_MTG_node_attr</code></a></li><li><a href="#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}"><code>MultiScaleTreeGraph.parse_macro_args</code></a></li><li><a href="#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}"><code>MultiScaleTreeGraph.parse_mtg!</code></a></li><li><a href="#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_section!</code></a></li><li><a href="#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}"><code>MultiScaleTreeGraph.paste_mtg_node</code></a></li><li><a href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a></li><li><a href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a></li><li><a href="#MultiScaleTreeGraph.read_mtg"><code>MultiScaleTreeGraph.read_mtg</code></a></li><li><a href="#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}"><code>MultiScaleTreeGraph.rewrite_expr!</code></a></li><li><a href="#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}"><code>MultiScaleTreeGraph.rotate_point</code></a></li><li><a href="#MultiScaleTreeGraph.siblings-Tuple{Node}"><code>MultiScaleTreeGraph.siblings</code></a></li><li><a href="#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}"><code>MultiScaleTreeGraph.split_MTG_elements</code></a></li><li><a href="#MultiScaleTreeGraph.strip_comments"><code>MultiScaleTreeGraph.strip_comments</code></a></li><li><a href="#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.traverse!</code></a></li><li><a href="#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}"><code>MultiScaleTreeGraph.unsafe_getindex</code></a></li><li><a href="#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}"><code>MultiScaleTreeGraph.write_mtg</code></a></li><li><a href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_mtg!</code></a></li><li><a href="#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_node!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}" href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])</code></pre><p>Convert an MTG into a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>mtg::Node</code>: An mtg node (usually the root node).</li><li><code>key</code>: The key, or attribute name. Used to list the variables that must be added to the</li></ul><p><code>DataFrame</code>. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

DataFrame(mtg, :Length)
DataFrame(mtg, [:Length, :Width])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/conversion/DataFrame.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MetaGraphsNext.MetaGraph-Tuple{Node}" href="#MetaGraphsNext.MetaGraph-Tuple{Node}"><code>MetaGraphsNext.MetaGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MetaGraph(g::Node)</code></pre><p>Convert an MTG into a <a href="https://juliagraphs.org/MetaGraphsNext.jl/dev/">MetaGraph</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

MetaGraph(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/conversion/MetaGraph.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.AbstractNodeMTG" href="#MultiScaleTreeGraph.AbstractNodeMTG"><code>MultiScaleTreeGraph.AbstractNodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all types describing the MTG coding for a node.</p><p>See <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> and <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> for examples of implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.MutableNodeMTG" href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MultiScaleTreeGraph.MutableNodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeMTG(link, symbol, index, scale)
MutableNodeMTG(link, symbol, index, scale)</code></pre><p><strong>NodeMTG structure</strong></p><p>Builds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.</p><p><strong>Note</strong></p><ul><li>The symbol should match the possible values listed in the <code>SYMBOL</code> column of the <code>CLASSES</code> section</li></ul><p>in the mtg file if read from a file.</p><ul><li>The index is totaly free, and can be used as a way to <em>e.g.</em> keep track of the branching order.</li></ul><pre><code class="language-julia">NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.NodeMTG" href="#MultiScaleTreeGraph.NodeMTG"><code>MultiScaleTreeGraph.NodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeMTG(link, symbol, index, scale)
MutableNodeMTG(link, symbol, index, scale)</code></pre><p><strong>NodeMTG structure</strong></p><p>Builds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.</p><p><strong>Note</strong></p><ul><li>The symbol should match the possible values listed in the <code>SYMBOL</code> column of the <code>CLASSES</code> section</li></ul><p>in the mtg file if read from a file.</p><ul><li>The index is totaly free, and can be used as a way to <em>e.g.</em> keep track of the branching order.</li></ul><pre><code class="language-julia">NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}" href="#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M&lt;:AbstractNodeMTG, T&lt;:MutableNamedTuples.MutableNamedTuple}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append!(node::Node{M&lt;:AbstractNodeMTG, &lt;:MutableNamedTuple}, attr)
append!(node::Node{M&lt;:AbstractNodeMTG, &lt;:Dict}, attr)</code></pre><p>Append new attributes to a node attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/append_attributes.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Any}" href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Integer}" href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing a Node using an integer will index in its children</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Node}" href="#Base.length-Tuple{Node}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the length of the subtree below the node (including it)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L148-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print-Tuple{Node}" href="#Base.print-Tuple{Node}"><code>Base.print</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print a node to io using an UTF-8 formatted representation of the <code>tree</code>. Most of the code from <a href="https://github.com/vh-d/DataTrees.jl/blob/master/src/printing.jl">DataTrees.jl</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
mtg
# / 1: $
# └─ / 2: Individual
#    └─ / 3: Axis
#       └─ / 4: Internode
#          ├─ + 5: Leaf
#          └─ &lt; 6: Internode
#             └─ + 7: Leaf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/print_MTG/print.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFrames.transform!-Tuple{Node, Vararg{Any, N} where N}" href="#DataFrames.transform!-Tuple{Node, Vararg{Any, N} where N}"><code>DataFrames.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(node::Node, args..., &lt;keyword arguments&gt;)</code></pre><p>Transform (mutate) an MTG (<code>node</code>) in place to add attributes specified by <code>args...</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</p></li><li><p><code>args::Any</code>: the transformations (see details)</p></li><li><p>&lt;keyword arguments&gt;:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li></ul></li></ul><p><strong>Returns</strong></p><p>Nothing, mutates the (sub-)tree in-place.</p><p><strong>Details</strong></p><p>The interface of the function is inspired from the one used in <a href="https://dataframes.juliadata.org/stable/"><code>DataFrames.jl</code></a>, but adapted to an MTG.</p><p>The <code>args...</code> provided can be of the following forms:</p><ol><li>a <code>:var_name =&gt; :new_var_name</code> pair. This form is used to rename an attribute name</li><li>a <code>:var_name =&gt; function</code> or <code>[:var_name1, :var_name2] =&gt; function</code> pair. The variables</li></ol><p>are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.</p><ol><li>a <code>:var_name =&gt; function =&gt; :new_var_name</code> form that does the same as the previous form</li></ol><p>but explicitly naming the resulting variable.</p><ol><li>a <code>function =&gt; :new_var_name</code> form that applies a function to a node and puts the results</li></ol><p>in a new attribute. This form is usually applied when searching ancestors or descendants values.</p><ol><li>a <code>function</code> form that applies a mutating function to a node, without expecting any output.</li></ol><p>This form is adapted when using a function that already mutates the node, without the need to return anything, <em>e.g.</em> <a href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>branching_order!</code></a>.</p><p>Carefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))
transform!(mtg,  x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf

# We can compute a new variable based on another. For example to know if the value of the
# `:Length` attribute is provided or not, we can do:
transform!(mtg, :Length =&gt; isnothing)
# To check the values we first call [`get_features`](@ref) to know the new variable name:
get_features(mtg)
# And then we get the values using [`descendants`](@ref)
descendants(mtg, :Length_isnothing, self = true)
# Or DataFrame:
DataFrame(mtg, :Length_isnothing)

# We can also set the attribute name ourselves like so:
transform!(mtg, :Length =&gt; isnothing =&gt; :no_length)
descendants(mtg, :no_length, self = true)

# We can provide anonymous functions if we want to:
transform!(mtg, :Length =&gt; (x -&gt; isnothing(x)))
descendants(mtg, :no_length, self = true)

# When a node does not have an attribute, it returns `nothing`. Most basic functions do not
# handle well those, e.g.:
transform!(mtg, :Length =&gt; log)
# It does not work because some nodes have no value for `:Length`.
# The solution is to handle these cases in our own functions instead:
transform!(mtg, :Length =&gt; (x -&gt; x === nothing ? nothing : log(x)) =&gt; :log_length)
descendants(mtg, :log_length, self = true)

# Another way is to give a filtering function as an argument:
transform!(mtg, :Length =&gt; log =&gt; :log_length, filter_fun = x -&gt; x[:Length] !== nothing)

# We can use more than one attribute as input to our function like so:
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :volume,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
descendants(mtg, :volume, self = true)

# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.

# We can also chain operations, and they will be executed sequentially so we can use variables
# computed on the instruction just before:
density = 0.6
transform!(
    mtg,
    [:Width, :Length] =&gt; ((x, y) -&gt; (x/2)^2 * π * y) =&gt; :vol,
    :vol =&gt; (x -&gt; x * density) =&gt; :biomass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :biomass])

# We can also rename a variable like so:
transform!(
    mtg,
    :biomass =&gt; :mass,
    filter_fun = x -&gt; x[:Length] !== nothing &amp;&amp; x[:Width] !== nothing
)
DataFrame(mtg, [:vol, :mass])

# Finnaly, we can use variables from ancestors/descendants using the `function =&gt; :new_var` form:
function get_mass_descendants(x)
    masses = descendants(x, :mass, ignore_nothing = true)
    if length(masses) == 0
        nothing
    else
        sum(masses)
    end
end

transform!(
    mtg,
    get_mass_descendants =&gt; :mass_beared
)
DataFrame(mtg, [:mass, :mass_beared])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/transform.jl#L1-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M&lt;:AbstractNodeMTG" href="#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M&lt;:AbstractNodeMTG"><code>MultiScaleTreeGraph.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new child to a parent node, and add the parent node as the parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.ancestors-Tuple{Any, Any}" href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>MultiScaleTreeGraph.ancestors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ancestors(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the ancestors (basipetal).</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the parent only: <code>recursivity_level = 1</code>, for parent + grand-parent: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the root.</p><ul><li><code>ignore_nothing = false</code>: ignore nothing values</li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing an example mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Using a leaf node from the mtg:
leaf_node = mtg.children[&quot;node_2&quot;].children[&quot;node_3&quot;].children[&quot;node_4&quot;].children[&quot;node_5&quot;]

ancestors(leaf_node, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
ancestors(leaf_node, :Length, type = Union{Nothing,Float64})

# Filter by scale:
ancestors(leaf_node, :XX, scale = 1, type = Float64)
ancestors(leaf_node, :Length, scale = 3, type = Float64)

# Filter by symbol:
ancestors(leaf_node, :Length, symbol = &quot;Internode&quot;)
ancestors(leaf_node, :Length, symbol = (&quot;Axis&quot;,&quot;Internode&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/ancestors.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.branching_order!-Tuple{Any}" href="#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>MultiScaleTreeGraph.branching_order!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">branching_order!(mtg; ascend = true)</code></pre><p>Compute the topological branching order of the nodes in an mtg.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the mtg, <em>e.g.</em> output from <code>read_mtg()</code></li><li><code>ascend</code>: If <code>true</code>, the order is computed from the base (acropetal), if <code>false</code>,</li></ul><p>it is computed from the tip (basipetal).</p><p><strong>Notes</strong></p><p>The order of a node is computed from the maximum order of their children when using the basipetal computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
branching_order!(mtg)
DataFrame(mtg, :branching_order)
# 7×2 DataFrame
#  Row │ tree                        branching_order
#      │ String                      Int64
# ─────┼───────────────────────────────────────────────
#    1 │ / 1: $                                      1
#    2 │ └─ / 2: Individual                          1
#    3 │    └─ / 3: Axis                             1
#    4 │       └─ / 4: Internode                     1
#    5 │          ├─ + 5: Leaf                       2
#    6 │          └─ &lt; 6: Internode                  1
#    7 │             └─ + 7: Leaf                    2

branching_order!(mtg, ascend = false)
DataFrame(mtg, :branching_order)
# 7×2 DataFrame
#  Row │ tree                        branching_order
#      │ String                      Int64
# ─────┼───────────────────────────────────────────────
#    1 │ / 1: $                                      2
#    2 │ └─ / 2: Individual                          2
#    3 │    └─ / 3: Axis                             2
#    4 │       └─ / 4: Internode                     2
#    5 │          ├─ + 5: Leaf                       1
#    6 │          └─ &lt; 6: Internode                  2
#    7 │             └─ + 7: Leaf                    1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/mutation_helpers.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T" href="#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MultiScaleTreeGraph.check_filters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_filters(node; scale = nothing, symbol = nothing, link = nothing)</code></pre><p>Check if the filters are consistant with the mtg onto which they are applied</p><p><strong>Examples</strong></p><pre><code class="language-julia">check_filters(mtg, scale = 1)
check_filters(mtg, scale = (1,2))
check_filters(mtg, scale = (1,2), symbol = &quot;Leaf&quot;, link = &quot;&lt;&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/check_filters.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.children-Tuple{Node}" href="#MultiScaleTreeGraph.children-Tuple{Node}"><code>MultiScaleTreeGraph.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">children(node::Node)</code></pre><p>Return the immediate children of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.clean_cache!-Tuple{Any}" href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>MultiScaleTreeGraph.clean_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clean_cache!(mtg)</code></pre><p>Clean the cached variables in the mtg, usually added from <a href="#MultiScaleTreeGraph.descendants!"><code>descendants!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/descendants.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.coordinates!-Tuple{Any}" href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>MultiScaleTreeGraph.coordinates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coordinates!(mtg; angle = 45; force = false)</code></pre><p>Compute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.</p><p><strong>Returns</strong></p><p>Nothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
coordinates!(mtg)
DataFrame(mtg, [:XX, :YY, :ZZ])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/plot_MTG/coordinates.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.delete_node!-Tuple{Any}" href="#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete_node!(node)</p><p>Delete a node and re-parent the children to its own parent. If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.</p><p>The function returns the parent node (or the new root if the node is a root)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/delete_nodes.jl#L96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.delete_nodes!-Tuple{Any}" href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>MultiScaleTreeGraph.delete_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete_nodes!(mtg::Node,&lt;keyword arguments&gt;)</p><p>Delete nodes in mtg following filters rules.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale to delete. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to delete. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to delete. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first deletion (<code>true</code>), or stop?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a></li></ul><p>to decide whether to delete a node or not.</p><p><strong>Notes</strong></p><ol><li>The function is acropetal, meaning it will apply the deletion from leaves to the root to ensure</li></ol><p>that one pass is enough and we don&#39;t repeat the process of visiting already visited children.</p><ol><li>The function does not do anything fancy, it let the user take care of its own rules when</li></ol><p>deleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.</p><ol><li>The package provides some pre-made functions for filtering. See for example <a href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>is_segment!</code></a></li></ol><p>to re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

delete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2

# Delete the leaves:
delete_nodes!(mtg, symbol = &quot;Leaf&quot;)
# Delete the leaves and internodes:
delete_nodes!(mtg, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Make the mtg match field measurements made only at branching points for the scales 1 + 2:
mtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/delete_nodes.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants" href="#MultiScaleTreeGraph.descendants"><code>MultiScaleTreeGraph.descendants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendants(node::Node,key,&lt;keyword arguments&gt;)
descendants!(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the descendants (acropetal). The mutating version (<code>descendants!</code>) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a>). It also only works for trees with attributes of subtype of <code>AbstractDict</code>.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the first level children only: <code>recursivity_level = 1</code>, for children + grand-children: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.</p><ul><li><code>ignore_nothing = false</code>: ignore nothing values</li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Tips</strong></p><p>To get the values of the leaves use <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> as the filtering function, e.g.: <code>descendants(mtg, :Width; filter_fun = isleaf)</code>.</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

descendants(mtg, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
descendants(mtg, :Length, type = Union{Nothing,Float64})

# Filter by scale:
descendants(mtg, :XX, scale = 1, type = Float64)
descendants(mtg, :Length, scale = 3, type = Float64)

# Filter by symbol:
descendants(mtg, :Length, symbol = &quot;Leaf&quot;)
descendants(mtg, :Length, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Filter by function, e.g. get the values for the leaves only:
descendants(mtg, :Width; filter_fun = isleaf)

# It is possible to cache the results in the mtg. This is wqy faster when using
# `@mutate_mtg` (note the `!` at the end of the function name):
@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = &quot;Internode&quot;)), symbol = &quot;Internode&quot;)

function compute_subtree_length(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? sum(length_descendants) : nothing
end

function compute_subtree_length!(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants!(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? length_descendants : nothing
end

@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = &quot;Internode&quot;)

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
compute_subtree_length!(mtg)
DataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])

# You can then clean the cach to avoid using too much memory:
clean_cache!(mtg)
mtg[1][1][1].attributes
mtg[1][1][1][2].attributes
DataFrame(mtg, [:Length, :subtree_length])

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
node = mtg
key = :Length
scale = nothing
symbol = nothing
link = nothing
all= true
self = false
filter_fun = nothing
recursivity_level = -1
type = Any

# compute_subtree_length!(mtg)

descendants!(mtg, :Length, self = true)
DataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])
DataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/descendants.jl#L165-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants!" href="#MultiScaleTreeGraph.descendants!"><code>MultiScaleTreeGraph.descendants!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">descendants(node::Node,key,&lt;keyword arguments&gt;)
descendants!(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the descendants (acropetal). The mutating version (<code>descendants!</code>) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a>). It also only works for trees with attributes of subtype of <code>AbstractDict</code>.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>recursivity_level = -1</code>: The maximum number of recursions allowed (considering filters).</li></ul><p><em>E.g.</em> to get the first level children only: <code>recursivity_level = 1</code>, for children + grand-children: <code>recursivity_level = 2</code>. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.</p><ul><li><code>ignore_nothing = false</code>: ignore nothing values</li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Tips</strong></p><p>To get the values of the leaves use <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> as the filtering function, e.g.: <code>descendants(mtg, :Width; filter_fun = isleaf)</code>.</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

descendants(mtg, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
descendants(mtg, :Length, type = Union{Nothing,Float64})

# Filter by scale:
descendants(mtg, :XX, scale = 1, type = Float64)
descendants(mtg, :Length, scale = 3, type = Float64)

# Filter by symbol:
descendants(mtg, :Length, symbol = &quot;Leaf&quot;)
descendants(mtg, :Length, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Filter by function, e.g. get the values for the leaves only:
descendants(mtg, :Width; filter_fun = isleaf)

# It is possible to cache the results in the mtg. This is wqy faster when using
# `@mutate_mtg` (note the `!` at the end of the function name):
@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = &quot;Internode&quot;)), symbol = &quot;Internode&quot;)

function compute_subtree_length(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? sum(length_descendants) : nothing
end

function compute_subtree_length!(x)
    length_descendants = filter(x -&gt; x !== nothing, descendants!(x, :Length, symbol = &quot;Internode&quot;, self = true))
    length(length_descendants) &gt; 0 ? length_descendants : nothing
end

@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = &quot;Internode&quot;)

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
compute_subtree_length!(mtg)
DataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])

# You can then clean the cach to avoid using too much memory:
clean_cache!(mtg)
mtg[1][1][1].attributes
mtg[1][1][1][2].attributes
DataFrame(mtg, [:Length, :subtree_length])

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
node = mtg
key = :Length
scale = nothing
symbol = nothing
link = nothing
all= true
self = false
filter_fun = nothing
recursivity_level = -1
type = Any

# compute_subtree_length!(mtg)

descendants!(mtg, :Length, self = true)
DataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])
DataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/descendants.jl#L165-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.descendants_!-NTuple{11, Any}" href="#MultiScaleTreeGraph.descendants_!-NTuple{11, Any}"><code>MultiScaleTreeGraph.descendants_!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fast version of descendants_ that mutates the mtg nodes to cache the information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/descendants.jl#L110-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.expand_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Expand MTG line</strong></p><p>Expand the elements denoted by the syntactic sugar &quot;&lt;&lt;&quot;, &quot;&lt;.&lt;&quot;, &quot;++&quot; or &quot;+.+&quot;</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{String}</code>: A split MTG line (e.g. c(&quot;/P1&quot;,&quot;/A1&quot;))</li><li><code>line::Array{Int64,1}</code>: The current line index (mutated) in the file. Only</li></ul><p>used as information when erroring.</p><p><strong>Returns</strong></p><p>A Tuple of:</p><ul><li>the split MTG line with all nodes explicitly</li><li>the nodes with common attributes (when using <code>&lt;.&lt;</code> or <code>+.+</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">x = split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;,r&quot;(?&lt;=.)(?=[&lt;/+])&quot;);
nodes, shared = MultiScaleTreeGraph.expand_node!(x,1)
(AbstractString[&quot;/A1&quot;, &quot;+U85&quot;, &quot;/U86&quot;, &quot;&lt;U87&quot;, &quot;&lt;U88&quot;, &quot;&lt;U89&quot;, &quot;&lt;U90&quot;, &quot;&lt;U91&quot;, &quot;&lt;U92&quot;, &quot;&lt;U93&quot;, &quot;&lt;U94&quot;, &quot;&lt;U95&quot;, &quot;&lt;U96&quot;, &quot;&lt;U97&quot;, &quot;+U98&quot;, &quot;+U99&quot;, &quot;+U100&quot;], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/expand_node.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.extend_pos-NTuple{5, Any}" href="#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}"><code>MultiScaleTreeGraph.extend_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new point after (x1,y1) using same direction and length relative to it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/plot_MTG/coordinates.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_classes-Tuple{Any}" href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>MultiScaleTreeGraph.get_classes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_classes(mtg)</code></pre><p>Compute the mtg classes based on its content. Usefull after having mutating the mtg nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/update_sections.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_description-Tuple{Any}" href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>MultiScaleTreeGraph.get_description</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_description(mtg)</code></pre><p>Returns <code>nothing</code>, because we can&#39;t really predict the description section from an mtg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/update_sections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_features-Tuple{Any}" href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>MultiScaleTreeGraph.get_features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_features(mtg)</code></pre><p>Compute the mtg features based on its attributes. Usefull after having computed new attributes in the mtg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/update_sections.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}" href="#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}"><code>MultiScaleTreeGraph.get_leading_tabs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_leading_tabs(node)</code></pre><p>Get the number of tabulation the node should have when writting it to a file based on the topology of its parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/write_mtg.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_node-Tuple{Node, Any}" href="#MultiScaleTreeGraph.get_node-Tuple{Node, Any}"><code>MultiScaleTreeGraph.get_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_node(node::Node, name)</code></pre><p>Get a node in an mtg by name.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
traverse!(mtg, x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/get_node.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_printing-Tuple{Node}" href="#MultiScaleTreeGraph.get_printing-Tuple{Node}"><code>MultiScaleTreeGraph.get_printing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_printing(node::Node; leading::AbstractString = &quot;&quot;)</code></pre><p>Format the printing of the tree according to link: follow or branching</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/print_MTG/print.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.get_reference-Tuple{Any}" href="#MultiScaleTreeGraph.get_reference-Tuple{Any}"><code>MultiScaleTreeGraph.get_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_reference(node)</code></pre><p>Get the preceding &quot;^&quot; keyword if needed, <em>i.e.</em> in case we refer to the parent node in the same mtg file column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/write_mtg.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.getroot-Tuple{Node}" href="#MultiScaleTreeGraph.getroot-Tuple{Node}"><code>MultiScaleTreeGraph.getroot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the root node of a tree, given any node in the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_node!-Tuple{Any, Any, Any}" href="#MultiScaleTreeGraph.insert_node!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.insert_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insert_node!(node, template, max_id)</code></pre><p>Insert a node as the new parent of node.</p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: The node at which to insert a node as a parent.</li><li><code>template::Node</code>: A template node used as the inserted nodes.</li><li><code>max_id::Vector{Int64}</code>: The maximum id of the mtg as a vector of 1 value, used to compute</li></ul><p>the name of the inserted node. It is incremented in the function.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

template = MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1)
max_id = parse(Int, MultiScaleTreeGraph.max_name(mtg)[6:end])
mtg = insert_node!(mtg[1][1], template, max_id)
mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/insert_nodes.jl#L88-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.insert_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>insert_nodes!(mtg::Node,template,&lt;keyword arguments&gt;)</p><p>Insert new nodes in the mtg following filters rules. It is important to note that it always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>template::Node</code>: A template node used for all inserted nodes.</li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale at which to insert. Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol at which to insert. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node at which to insert. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Continue after the first insertion (<code>true</code>), or stop.</li><li><code>filter_fun = nothing</code>: Any function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to decide</li></ul><p>where to insert.</p><p><strong>Notes</strong></p><ol><li>The nodes are always inserted before a filtered node because we can&#39;t decide if a new node would</li></ol><p>be considered a new child or a new parent of the children otherwise.</p><ol><li>The function does not do anything fancy, it let the user take care of its own rules when</li></ol><p>inserting nodes. So if you insert a branching node, the whole subtree will be branched.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;A1B1.mtg&quot;)
mtg = read_mtg(file)

mtg = insert_nodes!(mtg, MultiScaleTreeGraph.MutableNodeMTG(&quot;/&quot;, &quot;Shoot&quot;, 0, 1), scale = 2) # Will insert new nodes before all scale 2
mtg</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/insert_nodes.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.is_filtered-NTuple{5, Any}" href="#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}"><code>MultiScaleTreeGraph.is_filtered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_filtered(node, scale, symbol, link, filter_fun)</code></pre><p>Is a node filtered in ? Returns <code>true</code> if the node is kept, <code>false</code> if it is filtered-out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/check_filters.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.is_segment!-Tuple{Any}" href="#MultiScaleTreeGraph.is_segment!-Tuple{Any}"><code>MultiScaleTreeGraph.is_segment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_segment(node)</code></pre><p>Checks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.</p><p>The function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.</p><p>See <a href="#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> for an example of application.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/filter/filter-funs.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.isleaf-Tuple{Node}" href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>MultiScaleTreeGraph.isleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isleaf(node::Node)</code></pre><p>Test whether a node is a leaf or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.isroot-Tuple{Node}" href="#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>MultiScaleTreeGraph.isroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isroot(node::Node)</code></pre><p>Return <code>true</code> if <code>node</code> is the root node (meaning, it has no parent).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.issection-Tuple{Any, Any}" href="#MultiScaleTreeGraph.issection-Tuple{Any, Any}"><code>MultiScaleTreeGraph.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issection(string,section)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>string::String</code>: The string to test.</li><li><code>section::String</code>: The section to test.</li></ul><pre><code class="language-julia">issection(&quot;CODE :&quot;, &quot;CODE&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/utils-string.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.issection-Tuple{Any}" href="#MultiScaleTreeGraph.issection-Tuple{Any}"><code>MultiScaleTreeGraph.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issection(string)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><pre><code class="language-julia">issection(&quot;CODE :&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/utils-string.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.max_name-Tuple{Any}" href="#MultiScaleTreeGraph.max_name-Tuple{Any}"><code>MultiScaleTreeGraph.max_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_name(mtg)</code></pre><p>Returns the maximum name of the mtg based on its index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}" href="#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}"><code>MultiScaleTreeGraph.mtg_coordinates_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mtg_coordinates_df(mtg; force = false)
mtg_coordinates_df!(mtg; force = false)</code></pre><p>Extract the coordinates of the nodes of the mtg and the coordinates of their parents (:XX<em>from, :YY</em>from, :ZZ_from) and output a DataFrame.</p><p>The coordinates are computed using <a href="#MultiScaleTreeGraph.coordinates!-Tuple{Any}"><code>coordinates!</code></a> if missing, or if <code>force = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/plot_MTG/coordinates.jl#L126-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.new_name-Tuple{Any, Any}" href="#MultiScaleTreeGraph.new_name-Tuple{Any, Any}"><code>MultiScaleTreeGraph.new_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">new_name(mtg)
new_name(mtg,max_name)</code></pre><p>Make a new unique identifier by incrementing on the maximum name (names are names+index). Hint: prefer using <code>max_name = max_name(mtg)</code> and then <code>new_name(mtg,max_name)</code> for performance if you do it repeatidely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.next_line!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.next_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">next_line!(f,line)</code></pre><p><strong>Read line</strong></p><p>Read the next line in the IO stream, strip the comments, the missing values and increment the line index.</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/utils-string.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves" href="#MultiScaleTreeGraph.nleaves"><code>MultiScaleTreeGraph.nleaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nleaves(node)
nleaves!(node)</code></pre><p>Get the total number of leaves a node is bearing, <em>i.e.</em> the number of terminal nodes. <code>nleaves!</code> is faster than <code>nleaves</code> but cache the results in a variable so it uses more memory. Please use <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after calling <code>nleaves!</code> to clean the temporary variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

nleaves!(mtg)

clean_cache!(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/nleaves.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves!" href="#MultiScaleTreeGraph.nleaves!"><code>MultiScaleTreeGraph.nleaves!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nleaves(node)
nleaves!(node)</code></pre><p>Get the total number of leaves a node is bearing, <em>i.e.</em> the number of terminal nodes. <code>nleaves!</code> is faster than <code>nleaves</code> but cache the results in a variable so it uses more memory. Please use <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after calling <code>nleaves!</code> to clean the temporary variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

nleaves!(mtg)

clean_cache!(mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/nleaves.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}" href="#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}"><code>MultiScaleTreeGraph.nleaves_siblings!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nleaves_siblings!(x)</code></pre><p>Compute how many leaves the siblings of node x bear.</p><p>Please call <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after using <code>nleaves_siblings!</code> because it creates temporary variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/nleaves.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}" href="#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MultiScaleTreeGraph.node_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Instantiate a <code>attr_type</code> struct with <code>node_attr</code> keys and values</p><p><strong>Arguments</strong></p><ul><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>node_attr::String</code>: The node attributes as a <a href="@ref"><code>Base.Dict</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/parse_mtg.jl#L327-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.ordered_children-Tuple{Any}" href="#MultiScaleTreeGraph.ordered_children-Tuple{Any}"><code>MultiScaleTreeGraph.ordered_children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordered_children(node)</code></pre><p>Return the children as an array, ordered first by &quot;+&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}" href="#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}"><code>MultiScaleTreeGraph.parse_MTG_node</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Parse MTG node</strong></p><p>Parse MTG nodes (called from <code>parse_mtg!()</code>)</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: An MTG node (e.g. &quot;/Individual0&quot;)</li></ul><p><strong>Return</strong></p><p>A parsed node in the form of a Dict of three:</p><ul><li>the link</li><li>the symbol</li><li>and the index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/parse_mtg.jl#L217-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}" href="#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_MTG_node_attr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG node attributes names, values and type</p><p><strong>Arguments</strong></p><ul><li><code>node_data::String</code>: A splitted mtg node data (attributes)</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>features::DataFrame</code>: The features data.frame</li><li><code>attr_column_start::Integer</code>: The index of the column of the first attribute</li><li><code>line::Integer</code>: The current line of the mtg file</li><li><code>force::Bool</code>: force data reading even if errors are met during conversion ?</li></ul><p><strong>Return</strong></p><p>A list of attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/parse_mtg.jl#L254-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_macro_args-Tuple{Any}" href="#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}"><code>MultiScaleTreeGraph.parse_macro_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_macro_args(args)</code></pre><p>Parse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.</p><p><strong>Examples</strong></p><pre><code class="language-julia">args = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))
MultiScaleTreeGraph.parse_macro_args(args)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/check_filters.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}" href="#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}"><code>MultiScaleTreeGraph.parse_mtg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code></li><li><code>classes::Array</code>: The class section data as returned by <code>parse_section!</code></li><li><code>description::Array</code>: The description section data as returned by <code>parse_section!</code></li><li><code>features::Array</code>: The features section data as returned by <code>parse_section!</code></li><li><code>line::Array{Int64,1}</code>: The current line index (mutated). Must be given as line of <code>MTG:</code></li><li><code>l::Array{String,1}</code>: the current line</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed MTG section</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/parse_mtg.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.parse_section!-NTuple{5, Any}" href="#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}"><code>MultiScaleTreeGraph.parse_section!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>header::Array{String,1}</code>: A string defining the expected header for the class.</li><li><code>section::String</code>: The section name.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>l::Array{String,1}</code>: the current line</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed section of the MTG</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
f = open(file, &quot;r&quot;)
line = [0] ; l = [&quot;&quot;]; l[1] = MultiScaleTreeGraph.next_line!(f,line)

while MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],&quot;CLASSES&quot;)
    l[1] = MultiScaleTreeGraph.next_line!(f,line)
end

classes = MultiScaleTreeGraph.parse_section!(f,[&quot;SYMBOL&quot;,&quot;SCALE&quot;,&quot;DECOMPOSITION&quot;,&quot;INDEXATION&quot;,&quot;DEFINITION&quot;],&quot;CLASSES&quot;,line,l)

close(f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/parse_section.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}" href="#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}"><code>MultiScaleTreeGraph.paste_mtg_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">paste_mtg_node(node)</code></pre><p>Parse the mtg node as it should appear in the mtg file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/write_mtg.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}" href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pipe_model!(node, var_name, threshold_value; allow_missing = false)</code></pre><p>Same than <code>pipe_model!</code> but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (<code>:var_name</code>) is well measured down to <em>e.g.</em> 2-3cm of diameter, but should be computed below.</p><p>This function allows to compute the cross-section using the pipe model <strong>only</strong> for some sub-trees with values of <code>:var_name &lt;= threshold_value</code>.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the mtg, or a specific node at which to start from.</li><li><code>var_name</code>: the name of the cross-section attribute name in the nodes</li><li><code>threshold_value</code>: the threshold defining the value below which the cross-section will be</li></ul><p>re-computed using the pipe model instead of using <code>var_name</code>.</p><ul><li><code>allow_missing=false</code>: Allow missing values for <code>var_name</code>, in which case the cross-section is</li></ul><p>recomputed using the pipe model. Please use this option only if you know why.</p><p><strong>Details</strong></p><p>The node cross-section is partitioned from parent to children according to the number of leaves (<em>i.e.</em> terminal nodes) each child bear, unless one or more children has a <code>:var_name &gt; threshold_value</code>. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with <code>:var_name &lt;= threshold_value</code> will be shared as usual using their number of leaves. If <code>:var_name</code> of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.</p><p><strong>Word of caution</strong></p><p>Some tips when using this function:</p><ul><li>User must ensure that <code>:var_name</code> has a value for all nodes in the mtg before calling this</li></ul><p>version of <code>pipe_model!</code>, unless <code>allow_missing=true</code>.</p><ul><li>Nodes with untrusted values should be</li></ul><p>set to a value below the threshold value to make <code>pipe_model!</code> recompute them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/pipe_model.jl#L39-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}" href="#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}"><code>MultiScaleTreeGraph.pipe_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pipe_model!(node, root_value)</code></pre><p>Computes the cross-section of <code>node</code> considering its topological environment and the cross-section at the root node (<code>root_value</code>).</p><p>The pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.</p><p>The implementation is as follows: the algorithm first checks how many children a node has. If it has one child only, the child cross-section is equal to the node cross-section. If more children, the node cross-section is shared between the children according to the number of leaves they bear, <em>i.e.</em> the total number of terminal nodes of their sub-tree.</p><p>Please call <a href="#MultiScaleTreeGraph.clean_cache!-Tuple{Any}"><code>clean_cache!</code></a> after using <code>pipe_model!</code> because it creates temporary variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/pipe_model.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.read_mtg" href="#MultiScaleTreeGraph.read_mtg"><code>MultiScaleTreeGraph.read_mtg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG)</code></pre><p>Read an MTG file</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file.</li><li><code>attr_type::DataType = Dict</code>: the type used to hold the attribute values for each node.</li><li><code>mtg_type = MutableNodeMTG</code>: the type used to hold the mtg encoding for each node (<em>i.e.</em></li></ul><p>link, symbol, index, scale). See details section below.</p><p><strong>Details</strong></p><p><code>attr_type</code> should be:</p><ul><li><code>NamedTuple</code> if you don&#39;t plan to modify the attributes of the mtg, <em>e.g.</em> to use them for</li></ul><p>plotting or computing statistics...</p><ul><li><code>MutableNamedTuple</code> if you plan to modify the attributes values but not adding new attributes</li></ul><p>very often, <em>e.g.</em> recompute an attribute value...</p><ul><li><code>Dict</code> or similar (e.g. <code>OrderedDict</code>) if you plan to heavily modify the attributes, <em>e.g.</em></li></ul><p>adding/removing attibutes a lot</p><p>The <code>MTG</code> package provides two types for <code>mtg_type</code>, one immutable (<a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a>), and one mutable (<a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a>). If you&#39;re planning on modifying the mtg encoding of some of your nodes, you should use <a href="#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a>, and if you don&#39;t want to modify anything, use <a href="#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a> instead as it should be faster.</p><p><strong>Note</strong></p><p>See the documentation for the MTG format from the <a href="http://openalea.gforge.inria.fr/doc/vplants/newmtg/doc/_build/html/user/intro.html#mtg-a-plant-architecture-databases">OpenAlea webpage</a> for further details.</p><p><strong>Returns</strong></p><p>The MTG data.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:
mtg = read_mtg(file,Dict);

# We can also read an mtg directly from an excel file from the field:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;tree3h.xlsx&quot;)
mtg = read_mtg(file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/read_MTG.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}" href="#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}"><code>MultiScaleTreeGraph.rewrite_expr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewrite_expr!(arguments)</code></pre><p>Re-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add <code>attributes</code> after the node if it is an attribute.</p><p><strong>Examples</strong></p><pre><code class="language-none">test = :(x = node.name)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.name)

test = :(x = node.foo)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.attributes[:foo])

test = :(x = node.MTG.symbol)
MultiScaleTreeGraph.rewrite_expr!(:mtg,test)
test
# :(mtg.attributes[:x] = mtg.MTG.symbol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/mutation.jl#L112-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.rotate_point-NTuple{5, Any}" href="#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}"><code>MultiScaleTreeGraph.rotate_point</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Rotate a point (x1,y1) around (x0, y0) with <code>angle</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/plot_MTG/coordinates.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.siblings-Tuple{Node}" href="#MultiScaleTreeGraph.siblings-Tuple{Node}"><code>MultiScaleTreeGraph.siblings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siblings(node::Node)</code></pre><p>Return the siblings of <code>node</code> as a vector of nodes (or <code>nothing</code> if non-existant).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/Tree_funs.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}" href="#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}"><code>MultiScaleTreeGraph.split_MTG_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split_MTG_elements(l)</code></pre><p><strong>Split MTG line</strong></p><p>Split the elements (e.g. inter-node, growth unit...) in an MTG line</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: A string for an MTG line (e.g. &quot;/P1/A1&quot;).</li></ul><p><strong>Return</strong></p><p>A vector of elements (keeping their link, e.g. + or &lt;)</p><pre><code class="language-julia">split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;, r&quot;(?&lt;=.)(?=[&lt;/+])&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/utils-string.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.strip_comments" href="#MultiScaleTreeGraph.strip_comments"><code>MultiScaleTreeGraph.strip_comments</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Strip comments from a string</p><pre><code class="language-none">striplinecomment{T&lt;:String,U&lt;:String}(a::T, cchars::U=&quot;#;&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: the string from which the comments has to be stripped</li><li><code>cchars::String</code>: the characters that defines comments</li></ul><p>From https://rosettacode.org/wiki/Strip<em>comments</em>from<em>a</em>string#Julia</p><ul><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul><pre><code class="language-julia">strip_comments(&quot;test1&quot;)
strip_comments(&quot;test2 # with a comment&quot;)
strip_comments(&quot;# just a comment&quot;)
&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/strip_comments.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.traverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverse!(node::Node, f::Function[, args...], &lt;keyword arguments&gt;)
traverse(node::Node, f::Function[, args...], &lt;keyword arguments&gt;)</code></pre><p>Traverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use <code>traverse!</code>) or not (use <code>traverse</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</p></li><li><p><code>f::Function</code>: a function to apply over each node</p></li><li><p><code>args::Any</code>: any argument to pass to the function</p></li><li><p>&lt;keyword arguments&gt;:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li></ul></li></ul><p><strong>Returns</strong></p><p>Nothing for <code>traverse!</code> because it mutates the (sub-)tree in-place, or an Array of whatever the function returns for <code>traverse</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
traverse!(mtg, x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf

# We can also use the `do...end` block notation when we have a complex set of instructions:
traverse!(mtg) do x
    if isleaf(x)
         println(x.name,&quot; is a leaf&quot;)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/traverse.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}" href="#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}"><code>MultiScaleTreeGraph.unsafe_getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;], but in an unsafe way, meaning it returns <code>nothing</code> when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/read_MTG/NodeMTG.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}" href="#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}"><code>MultiScaleTreeGraph.write_mtg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_mtg(file, mtg; kwargs...)
write_mtg(file, mtg, classes, description, features)</code></pre><p>Write an mtg file to disk.</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file to write.</li><li><code>mtg</code>: the mtg</li><li><code>classes</code>: the classes section</li><li><code>description</code>: the description section</li><li><code>features</code>: the features section</li></ul><p><strong>Note</strong></p><p>kwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using <a href="#MultiScaleTreeGraph.get_classes-Tuple{Any}"><code>get_classes</code></a>, <a href="#MultiScaleTreeGraph.get_features-Tuple{Any}"><code>get_features</code></a> or <a href="#MultiScaleTreeGraph.get_description-Tuple{Any}"><code>get_description</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)
write_mtg(&quot;test.mtg&quot;,mtg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/write_mtg/write_mtg.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_mtg!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@mutate_mtg!(node, args...,kwargs...)</code></pre><p>Mutate the mtg nodes in place.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the mtg to mutate</li><li><code>args...</code>: The computations to apply to the nodes (see examples)</li><li><code>kwargs...</code>: Optional keyword arguments for traversing and filtering (see details)</li></ul><p><strong>Details</strong></p><p>As for <a href="#MultiScaleTreeGraph.descendants"><code>descendants</code></a> and <a href="#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>ancestors</code></a>, kwargs can be any filter from:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>traversal</code>: The type of tree traversal. By default it is using <code>AbstractTrees.PreOrderDFS</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Compute a new attribute with the scales and add 2 to its values:
@mutate_mtg!(mtg, scaling = node.scales .+ 2)

# Compute several new attributes, some based on others:
@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_mtg! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/mutation.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}" href="#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MultiScaleTreeGraph.@mutate_node!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@mutate_node!(node, args...)</code></pre><p>Mutate a single node in place.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the node to mutate</li><li><code>args...</code>: The computations to apply to the node (see examples)</li></ul><p><strong>See also</strong></p><p><a href="#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>@mutate_mtg!</code></a> to mutate all nodes of an mtg.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing an mtg from the package:
file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)

# Compute a new attribute with the scales and add 2 to its values:
@mutate_node!(mtg, scaling = node.scales .+ 2)

# The computation is only applied to the root node. To apply it to all nodes,
# see @mutate_mtg!

# Compute several new attributes, some based on others:
@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_node! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/c491e71ce9ff1a127c611d7e862590588f45bee1/src/compute_MTG/mutation.jl#L70-L104">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../get_started/">« Getting started</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 November 2021 14:26">Tuesday 9 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
