var documenterSearchIndex = {"docs":
[{"location":"tutorials/6.add_remove_nodes/#Add/remove-nodes","page":"Add/remove nodes","title":"Add/remove nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"using MultiScaleTreeGraph","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Make-an-MTG-manually","page":"Add/remove nodes","title":"Make an MTG manually","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It is very easy to add or remove nodes in an MTG. Actually, we can even construct an MTG completely manually.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Root-node","page":"Add/remove nodes","title":"Root node","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Create the root node:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg = Node(\"node_1\", MutableNodeMTG(\"/\", \"Plant\", 0, 1), Dict{Symbol,Any}(:species => \"Grassy-plant\"))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The first argument to Node is the name. For the root node we usually use \"node_1\". The second argument is a MutableNodeMTG (or a NodeMTG) that defines the topology of the node: its link to its parent (the root node always decomposes), its symbol, its index and its scale. The third and last argument is used to add attributes to the MTG.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Node-id","page":"Add/remove nodes","title":"Node id","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The ids of the nodes should be unique. This package provides a function that guaranties a new id is unique in the MTG:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"new_id = new_id(mtg)","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Adding-children-nodes","page":"Add/remove nodes","title":"Adding children nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"To create a child node, we use a different method of Node. This method is close to the one we used for the root, except there is a new argument at the second position: the parent node. Here we use the root node as the parent (mtg), and the unique id (new_id) as the child name.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"IN1 = Node(\"node_1\", new_id, mtg, MutableNodeMTG(\"/\", \"Internode\", 0, 2), Dict{Symbol,Any}(:diameter => 0.1, :length => 0.5))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Now the MTG has two nodes:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can continue like this indefinitely. For example we can add a leaf to the first internode:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Node(\"Leaf_node\",new_id(mtg), IN1, MutableNodeMTG(\"+\", \"Leaf\", 0, 2), Dict{Symbol,Any}(:area => 0.2))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"note: Note\nIf a node has no children, there is no need to keep track of it in an object.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And an internode following the first internode:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"IN2 = Node(\"IN_node\",new_id(mtg), IN1, MutableNodeMTG(\"<\", \"Internode\", 1, 2), Dict{Symbol,Any}(:diameter => 0.15, :length => 0.3))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And a leaf to it:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Node(\"Leaf_node2\",new_id(mtg), IN2, MutableNodeMTG(\"+\", \"Leaf\", 1, 2), Dict{Symbol,Any}(:area => 0.2))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And here is our resulting MTG:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And the attributes:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"DataFrame(mtg, get_attributes(mtg))","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Delete-a-node","page":"Add/remove nodes","title":"Delete a node","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It is possible to remove a single node in an MTG using delete_node!. For example if we want to delete the second internode (\"node_4\"):","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, \"node_4\"))\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"As we can see the new MTG has only one internode now, and the children of the second internode are now the children of its parents, the first internode.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"But what if we deleted the first internode?","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, \"node_2\"))\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We see there is a warning now. This is because we don't really know what should be the new link for a branching child replacing a decomposing node. So by default we don't make any assumption and keep the scale of the child as it is, in the hope the user will look into it.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"In our example the first leaf is now branching from the plant, while it should decompose it because it is not of the same scale. But a leaf decomposing a Plant has no meaning botanically. The best approach would be to keep an intermediary node, as it was before.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The user can define its own rules for the new links using the child_link_fun keyword argument of delete_node!. It expect a function that takes the child node as input and return its new link.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"For example one could decide to never replace the children link and manage them afterward. In this case we can use the identity function like this:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, \"node_2\"), child_link_fun = node -> node.MTG.link)\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It didn't change anything here because the child already kept its own link. But it will differ for other types of parent / children links.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Insert/remove-nodes-programmatically","page":"Add/remove nodes","title":"Insert/remove nodes programmatically","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Sometimes we want to remove or add a lot of nodes in an MTG. This is possible to do it programmatically using delete_nodes! and insert_nodes respectively.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Delete-nodes","page":"Add/remove nodes","title":"Delete nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can remove all nodes that meet specific conditions given by the usual node filters (see Filters for more details). For example one could remove all nodes of scale 2 in an MTG, i.e. all nodes except the Plant in our example:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ndelete_nodes!(mtg_2, scale = 2)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can also remove nodes with more complex filters, for example all nodes with an index greater or equal to 1:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_3 = deepcopy(mtg)\n\ndelete_nodes!(mtg_3, filter_fun = node -> node.MTG.index >= 1)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"note: Note\ndelete_nodes! always return the root node of the MTG. If the root node of the original MTG is deleted, its child becomes the new root node. If the root had several children, it returns an error. The function always return the root node of the new MTG, so if the root has not been modified, it remains the same, but if it has been deleted, the new root is returned. That is why it is preferable to use delete_nodes! has a non-mutating function and re-assign the results to an object if it is planned to remove the root node.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"As for delete_node! (singular), by default delete_nodes! (plural) uses new_child_link to re-link the children of the deleted nodes, but the user can provide a custom function. See the function details to learn more about it.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Add-nodes","page":"Add/remove nodes","title":"Add nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can add new nodes in an MTG programmatically using insert_nodes!. The function insert new nodes based on a template NodeMTG provided by the user. The new nodes are inserted before the the filtered nodes, because it is impossible to decide beforehand if a new node would be considered as a new child or parent of the children otherwise. The id of the inserted node is automatically computed using new_id.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"For example if we need to insert new nodes before each leaf, we would do:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_4 = deepcopy(mtg)\ntemplate = MutableNodeMTG(\"+\", \"Flower\", 0, 2)\ninsert_nodes!(mtg_4, template, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The function does not do anything fancy, its sole job is to insert a new node at a given position with a template NodeMTG.","category":"page"},{"location":"tutorials/4.convert_mtg/#Converting-MTGs","page":"Converting MTGs","title":"Converting MTGs","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"We can do a lot using the MTG format, but sometimes we want our data in another format.","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"That's why MultiScaleTreeGraph.jl provide functions to convert an MTG into a DataFrame or into a Graph.","category":"page"},{"location":"tutorials/4.convert_mtg/#MTG-to-DataFrame","page":"Converting MTGs","title":"MTG to DataFrame","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"To convert an MTG into a DataFrame, you can simply use this command:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"df = DataFrame(mtg, :Width)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"This will convert your MTG into a DataFrame along with the selected variable (here the Width). The node MTG is always reported in new columns:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"tree: a pretty-printing of the MTG\nid: the unique ID of the node, taken from the node name (e.g. mtg.name)\nsymbol: the node symbol\nscale: the node scale\nindex: the node index\nparent_id: the node's parent id\nlink: the link between the node and its parent","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"It is also possible to get several attributes as columns by passing their names as a vector:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"DataFrame(mtg, [:Width, :Length])","category":"page"},{"location":"tutorials/4.convert_mtg/#MTG-to-MetaGraph","page":"Converting MTGs","title":"MTG to MetaGraph","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"We can convert an MTG into a MetaGraph using MetaGraph():","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"mg = MetaGraph(mtg)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"This is particularly useful if you want to benefit from the algorithm provided by Graphs.jl and MetaGraphsNext.jl, such as writing into more standard formats such as DOTFormat or MGFormat (or any other available from GraphIO.jl), plotting with GraphPlot.jl or NetworkLayout.jl, or computing e.g. flow with GraphsFlows.jl.","category":"page"},{"location":"the_mtg/mtg_format/#The-.mtg-file-format","page":"File format","title":"The .mtg file format","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The .mtg file format was developed in the AMAP lab to be able to describe a plant in the MTG format directly in a file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The file format is generally used when measuring a plant on the field or to write on disk the results of an architectural model such as AMAPSim or VPalm for example. This format helps exchange and archive data about plants in a standard and efficient way.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The format is described in details in the original paper from Godin et al. (1997), but our implementation in Julia is detailed in this section.","category":"page"},{"location":"the_mtg/mtg_format/#Example-MTG","page":"File format","title":"Example MTG","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's define a very simple virtual plant composed of only two internodes and two leaves:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"<div class=\"sketchfab-embed-wrapper\">\n<iframe title=\"A 3D model\" width=\"640\" height=\"480\" src=\"https://sketchfab.com/models/2a699871f6f6459faa11c206bf81ae9a/embed?autospin=0.2&amp;autostart=1&amp;preload=1&amp;ui_controls=1&amp;ui_infos=1&amp;ui_inspector=1&amp;ui_stop=1&amp;ui_watermark=1&amp;ui_watermark_link=1\" frameborder=\"0\" allow=\"autoplay; fullscreen; vr\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n<p style=\"font-size: 13px; font-weight: normal; margin: 5px; color: #4A4A4A;\">\n<a href=\"https://sketchfab.com/3d-models/a-simple-3d-plant-2a699871f6f6459faa11c206bf81ae9a?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">A simple 3D plant</a>\nby <a href=\"https://sketchfab.com/rvezy?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">rvezy</a>\non <a href=\"https://sketchfab.com?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">Sketchfab</a>\n</p>\n</div>","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The corresponding MTG file is provided with this package. Let's print it using Julia's built-in read method:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This is a consequent file for such a tiny plant! This is because MTG files have a header with several sections before the MTG of the plant itself, which only appears after the MTG: line.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's dig into the information we have here.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-sections","page":"File format","title":"The MTG sections","text":"","category":"section"},{"location":"the_mtg/mtg_format/#Introduction","page":"File format","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"An MTG file is divided into five sections. These sections are defined by a keyword and a colon. The content of each section appears on a new line right after the keyword. A section can appear right after the content of the previous section, or they can be separated by blank lines. In fact, all blank lines are ignored in an MTG file.","category":"page"},{"location":"the_mtg/mtg_format/#The-CODE-section","page":"File format","title":"The CODE section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first section of an MTG file is the CODE section. It must appear first in the file as it is used to determine which version of the format specification the MTG file is following. The standard format in 2021 is the FORM-A specification.","category":"page"},{"location":"the_mtg/mtg_format/#The-CLASSES-section","page":"File format","title":"The CLASSES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The CLASSES section lists all symbols used in the MTG, and associates the scale of each symbol.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The data is presented as a table with five columns:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"SYMBOL: the string used for the node symbol.\nSCALE: the scale of the symbol, meaning all nodes with the given symbol will have this scale.\nDECOMPOSITION: This is not used anymore\nINDEXATION: This is not used anymore\nDEFINITION: This is not used anymore","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first row of the table is reserved and shouldn't be updated. It is a standard to use the dollar sign as the symbol for the scene, i.e. the node with the higher scale that encompass all MTGs. This node is usually not used in an MTG because MTG files mostly describe just a single plant (or a part of), not a whole scene.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThe symbol must be a character string without any numbers at the end, because the index of a node is read as the numbers at the end of a node name, so if a node symbol ends with a number, it will be parsed as an index. For example a symbol written Axis1 with index 1 will give Axis11 in the MTG, which will be parsed as Axis for the symbol and 11 for the index. Numbers are allowed inside the symbol though, e.g. Ax1s is allowed.","category":"page"},{"location":"the_mtg/mtg_format/#The-DESCRIPTION-section","page":"File format","title":"The DESCRIPTION section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The DESCRIPTION section is a table with four columns, and it defines a set of topological rules the MTG nodes of a same scale must follow. The rules are completely optional, but the header of the section is mandatory. In other words, the table can be empty.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The LEFT column designates the symbol of a parent node, the RIGHT column the symbol of a child node, the RELTYPE column the type of links allowed between the two, and MAX the maximum number of times these types of connexions are allowed in the MTG. The user can use a question mark to denote no maximum.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nThe rules only apply between symbols sharing the same scale (e.g. a node with itself, or in our example, the Internode with a Leaf).","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"These rules are mainly used to check the integrity of an MTG that has been written by hand on the field.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the rules yet. You can let this section empty (with the header) for your mtg if you don't plan to read it with other tools than MultiScaleTreeGraph.jl.","category":"page"},{"location":"the_mtg/mtg_format/#The-FEATURES-section","page":"File format","title":"The FEATURES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is a table with two columns that define the name of the attributes (or features) that can be attached to nodes, and the type of these attributes. This section makes sure that attributes are interpreted correctly when parsing the file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The NAME column is used to give the name of an attribute, and the TYPE column its type. The type can be:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"REAL for real numbers, e.g. 0.1\nINT for integer numbers, e.g. 1\nSTRING for strings, e.g. broken\nALPHA for reserved keywords:\nNbEl: NumBer of ELements, the number of children at the next scale\nLength: the node length\nBottomDiameter, the bottom tapering applied to the node for computing its geometry\nTopDiameter, the tapering applied at the top\nState, defines the state of a node. It can take the value D (Dead), A (Alive), B (Broken) , P (Pruned), G (Growing), V (Vegetative), R (Resting), C (Completed), M (Modified), or any combination of these given letters.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the State of a node, and does not make use of the reserved keywords.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-section","page":"File format","title":"The MTG section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is the actual MTG. It describes the topology of the plant, and give the possibility to add attributes to them.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The MTG is encoded as a table with tabulation separated values. The header of this section defines the columns used for describing the topology and the ones used for the attributes. The first column name is reserved and must be named ENTITY-CODE. Then, a set of empty column names (i.e. just tabulations) that defines how many columns are used for the topology. Finally, the following columns are used to define the attributes of the nodes. Their names must match the ones given in The FEATURES section.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Each row of the table usually refers to a single node. The topology is and node description is given in the ENTITY-CODE columns.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"In our example MTG, the first node is the scene: /Scene0. In this package, this notation is called a NodeMTG. It is made out of three different information:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent node: /\nThe node Symbol: Scene\nThe node index: 0","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent can be either / (decomposition), < (following) or + (branching). you can read the Node MTG and attributes section for more details on the signification of each. In few words, a node decomposes its parent if it changes the scale of description, follows if it is continuing after its parent, or branching if it branches from its parent.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node symbol is used to determine the scale of the node and eventually its properties.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node index is completely free. It is mainly used to keep track of the number of following segments on an axis, or the branching order.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The second node in our example is ^/Individual0. It introduces a new character used as prefix: ^. This character is used to tell us the parent of the current node is the last node in the same column. If this character is absent, then the parent of the node is the last node found on the column before.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"We can find such example in the 5th row of the table where a leaf is declared like so: +Leaf0. The missing ^ tells us that the parent of this node is the one found on the column before, which is ^/Internode0.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nBecause there is no explicit need to change column when nodes are decomposing or following, we usually create a new column only when a node branches to reduce the number of columns in the ENTITY-CODE.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Attributes are then declared in their respective columns defined in the header. If there is no value for an attribute, it is usually declared as an empty column","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nMTGs entered manually on the field are usually done in a spreadsheet software such as MS Excel or Only Office / Open Office / Libre Office Calc. Here is an example spreadsheet used on the field. We have one with a Macro too. Just sent us an email to get one.","category":"page"},{"location":"tutorials/0.read_write/#Read-and-Write-MTGs","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/#Read","page":"Read and Write MTGs","title":"Read","text":"","category":"section"},{"location":"tutorials/0.read_write/#Reading-a-file","page":"Read and Write MTGs","title":"Reading a file","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Reading an MTG is done using the read_mtg function:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\n\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The file given in input can be either a .mtg, .csv, .xlsx or .xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Options","page":"Read and Write MTGs","title":"Options","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The function has two optional arguments to set the type used for the attributes, and the type used for the MTG field (see next section for more details). It also has a keyword argument to choose the sheet name in case you're reading an xlsx or xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Attributes-type","page":"Read and Write MTGs","title":"Attributes type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The type used for the attributes should be a NamedTuple-alike or a Dict-alike type. Here is a more in-depth recommendation, use:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"NamedTuple if you don't plan to modify the attributes of the MTG, e.g. to use them for plotting or computing statistics...\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes very often, e.g. recompute an attribute value...\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g. adding/removing attributes a lot","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nIf you don't know what to use, just use the default.","category":"page"},{"location":"tutorials/0.read_write/#MTG-encoding-type","page":"Read and Write MTGs","title":"MTG encoding type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The MTG encoding type can be either immutable or mutable. By default we use a mutable one (MutableNodeMTG), but you can use the immutable one by setting the mtg_type argument of the function to NodeMTG. If you're planning on modifying the MTG encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nAgain, if you don't know what to use, use the default.","category":"page"},{"location":"tutorials/0.read_write/#Sheet-name","page":"Read and Write MTGs","title":"Sheet name","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you're reading your MTG from a .xlsx or .xlsm file, you can choose the sheet you want to read by using the keyword argument sheet_name.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you don't provide anything for the sheet name, it will read the first one by default.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nKeyword arguments must be explicitly named in the function call. In this case it would be:file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file, sheet_name = \"A3H\")","category":"page"},{"location":"tutorials/0.read_write/#Write","page":"Read and Write MTGs","title":"Write","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Writing an MTG back to disk is as simple as this:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"temporary_file = tempname() # using a temporary file here, but you should put the path to the file you want to write\n\nwrite_mtg(temporary_file, mtg)","category":"page"},{"location":"api/#MultiScaleTreeGraph.jl-functions","page":"API","title":"MultiScaleTreeGraph.jl functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you'll be directed to the function help.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MultiScaleTreeGraph]","category":"page"},{"location":"api/#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T<:Union{Tuple, AbstractArray}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])\n\nConvert an MTG into a DataFrame.\n\nArguments\n\nmtg::Node: An mtg node (usually the root node).\nkey: The key, or attribute name. Used to list the variables that must be added to the\n\nDataFrame. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nDataFrame(mtg, :Length)\nDataFrame(mtg, [:Length, :Width])\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.MetaGraph-Tuple{Node}","page":"API","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g::Node)\n\nConvert an MTG into a MetaGraph.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nMetaGraph(mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.MutableNodeMTG","page":"API","title":"MultiScaleTreeGraph.MutableNodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.Node","page":"API","title":"MultiScaleTreeGraph.Node","text":"Node(id::Int, MTG<:AbstractNodeMTG, attributes)\nNode(name::String, id::Int, MTG<:AbstractNodeMTG, attributes)\nNode(id::Int, parent::Node, MTG<:AbstractNodeMTG, attributes)\nNode(name::String, id::Int, parent::Node, MTG<:AbstractNodeMTG, attributes)\nNode(\n    name::String,\n    id::Int,\n    parent::Node,\n    children::Union{Nothing,Dict{Int,Node}},\n    siblings::Union{Nothing,Dict{Int,Node}},\n    MTG<:AbstractNodeMTG,\n    attributes\n)\n\nType that defines an MTG node (i.e. an element) with the name of the node, its unique id, its parent (only if its not the root node), children, MTG encoding (see NodeMTG or MutableNodeMTG) and attributes.\n\nThe node is an entry point to a Mutli-Scale Tree Graph, meaning we can move through the MTG from any of its node. The root node is the node without parent. A leaf node is a node without any children. Root and leaf nodes are used with their computer science meaning throughout the package, not in the biological sense.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.NodeMTG","page":"API","title":"MultiScaleTreeGraph.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:Node","page":"API","title":"Base.:==","text":"==(a::Node, b::Node)\n\nTest Node quality. The children and siblings are not tested, only their id is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"API","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Any}","page":"API","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Integer}","page":"API","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Node}","page":"API","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.print-Tuple{Node}","page":"API","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.transform","page":"API","title":"DataFrames.transform","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function or [:var_name1, :var_name2...] => function pair. The variables\n\nare declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.\n\na :var_name => function => :new_var_name form that does the same as the previous form\n\nbut explicitly naming the resulting variable (can take several variables on left-hand side).\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finnaly, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#DataFrames.transform!","page":"API","title":"DataFrames.transform!","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function or [:var_name1, :var_name2...] => function pair. The variables\n\nare declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.\n\na :var_name => function => :new_var_name form that does the same as the previous form\n\nbut explicitly naming the resulting variable (can take several variables on left-hand side).\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finnaly, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M<:AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.addchild!","text":"Add a new child to a parent node, and add the parent node as the parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = mtg.children[2].children[3].children[4].children[5]\n\nancestors(leaf_node, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\nancestors(leaf_node, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1, type = Float64)\nancestors(leaf_node, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = \"Internode\")\nancestors(leaf_node, :Length, symbol = (\"Axis\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.branching_order!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.branching_order!","text":"branching_order!(mtg; ascend = true)\n\nCompute the topological branching order of the nodes in an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nNotes\n\nThe order of a node is computed from the maximum order of their children when using the basipetal computation.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nbranching_order!(mtg)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\nbranching_order!(mtg, ascend = false)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T","page":"API","title":"MultiScaleTreeGraph.check_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = \"Leaf\", link = \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.children-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.children","text":"children(node::Node)\n\nReturn the immediate children of node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.clean_cache!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.coordinates!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.coordinates!","text":"coordinates!(mtg; angle = 45; force = false)\n\nCompute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.\n\nReturns\n\nNothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncoordinates!(mtg)\nDataFrame(mtg, [:XX, :YY, :ZZ])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_node!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_node!","text":"deletenode!(node; childlinkfun = newchild_link)\n\nDelete a node and re-parent the children to its own parent.\n\nIf the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nchild_link_fun is a function that takes the child node of a deleted node as input and returns its new link. The default function is new_child_link, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the following function instead:\n\nnode -> node.MTG.link\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nchild_link_fun = new_child_link: a function that takes the child node of a deleted node\n\nas input and returns its new link (see details).\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nThe default function used for child_link_fun is new_child_link, which tries to be\n\nclever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the following function instead:\n\nnode -> node.MTG.link\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, symbol = \"Leaf\")\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (\"Leaf\",\"Internode\"))\n\n# Make the mtg match field measurements made only at branching points for the scales 1 + 2:\nmtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.descendants","page":"API","title":"MultiScaleTreeGraph.descendants","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants!","page":"API","title":"MultiScaleTreeGraph.descendants!","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants_!-NTuple{10, Any}","page":"API","title":"MultiScaleTreeGraph.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MultiScaleTreeGraph.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.extend_pos","text":"Add a new point after (x1,y1) using same direction and length relative to it\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.filter_fun_nothing","text":"filter_fun_nothing(filter_fun, ignore_nothing)\n\nReturns a new filtering function that adds a filter on the key value for nothing if ignore_nothing is true\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_attributes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_attributes","text":"get_attributes(node)\n\nGet all attributes names available on the node and its children.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_classes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_description-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_features-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_features","text":"get_features(mtg)\n\nCompute the mtg features section based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_leading_tabs","text":"get_leading_tabs(node)\n\nGet the number of tabulation the node should have when writting it to a file based on the topology of its parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node-Tuple{Node, String}","page":"API","title":"MultiScaleTreeGraph.get_node","text":"get_node(node::Node, name::String)\nget_node(node::Node, id::Int)\n\nGet a node in an mtg by name or id. If names are not unique in the MTG, the function will return the first it finds.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6 = get_node(mtg, \"node_6\")\nnode_6_2 = get_node(mtg, 6)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_printing-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_reference-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_reference","text":"get_reference(node)\n\nGet the preceding \"^\" keyword if needed, i.e. in case we refer to the parent node in the same mtg file column.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_root-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_root","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_child!","page":"API","title":"MultiScaleTreeGraph.insert_child!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Should return\n\nattribute values of the same type as of the nodes attributes in the MTG (e.g. Dict or NamedTuple). If you need to just pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmtg = insert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\nmtg = insert_parent!(\n    mtg[1][1],\n    x -> (\n        link = x[1].MTG.link,\n        symbol = x[1].MTG.symbol,\n        index = x[1].MTG.index,\n        scale = x[1].MTG.scale)\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_children!","page":"API","title":"MultiScaleTreeGraph.insert_children!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generation!","page":"API","title":"MultiScaleTreeGraph.insert_generation!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Should return\n\nattribute values of the same type as of the nodes attributes in the MTG (e.g. Dict or NamedTuple). If you need to just pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmtg = insert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\nmtg = insert_parent!(\n    mtg[1][1],\n    x -> (\n        link = x[1].MTG.link,\n        symbol = x[1].MTG.symbol,\n        index = x[1].MTG.index,\n        scale = x[1].MTG.scale)\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generations!","page":"API","title":"MultiScaleTreeGraph.insert_generations!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_nodes!","page":"API","title":"MultiScaleTreeGraph.insert_nodes!","text":"Actual workhorse of insertparents!, insertgenerations!, insertchildren!, insertsiblings!\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_parent!","page":"API","title":"MultiScaleTreeGraph.insert_parent!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Should return\n\nattribute values of the same type as of the nodes attributes in the MTG (e.g. Dict or NamedTuple). If you need to just pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmtg = insert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\nmtg = insert_parent!(\n    mtg[1][1],\n    x -> (\n        link = x[1].MTG.link,\n        symbol = x[1].MTG.symbol,\n        index = x[1].MTG.index,\n        scale = x[1].MTG.scale)\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_parents!","page":"API","title":"MultiScaleTreeGraph.insert_parents!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_sibling!","page":"API","title":"MultiScaleTreeGraph.insert_sibling!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node.attributes)(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Should return\n\nattribute values of the same type as of the nodes attributes in the MTG (e.g. Dict or NamedTuple). If you need to just pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmtg = insert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\nmtg = insert_parent!(\n    mtg[1][1],\n    x -> (\n        link = x[1].MTG.link,\n        symbol = x[1].MTG.symbol,\n        index = x[1].MTG.index,\n        scale = x[1].MTG.scale)\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_siblings!","page":"API","title":"MultiScaleTreeGraph.insert_siblings!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.is_segment!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isleaf-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isroot-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.max_id-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.max_id","text":"max_id(mtg)\n\nReturns the maximum id of the mtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.mtg_coordinates_df","text":"mtg_coordinates_df(mtg; force = false)\nmtg_coordinates_df!(mtg; force = false)\n\nExtract the coordinates of the nodes of the mtg and the coordinates of their parents (:XXfrom, :YYfrom, :ZZ_from) and output a DataFrame.\n\nThe coordinates are computed using coordinates! if missing, or if force = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_child_link-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.new_child_link","text":"new_child_link(node)\n\nCompute the new link of the child node when deleting a parent node. The rule is to give the child node link of its parent node that is deleted, except when the parent was following its own parent.\n\nThe node given as input is the child node here.\n\nThe rule is summarized in the following table:\n\nDeleted node link Child node link New child node link warning\n/ / / \n/ + + yes (1)\n/ < / \n+ / / yes (2)\n+ + + \n+ < + \n< / / \n< + + \n< < < \n\nThe warnings happens when there is no satisfactory way to handle the new link, i.e. when mixing branching and change in scale.\n\nNote that in the case (1) of the warning the first child only takes the \"/\" link, the others keep their links.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_id-Tuple{Int64}","page":"API","title":"MultiScaleTreeGraph.new_id","text":"new_id(mtg)\nnew_id(mtg, max_id)\n\nMake a new unique identifier by incrementing on the maximum node id. Hint: prefer using max_id = max_id(mtg) and then new_id(mtg, max_is) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.new_node_MTG","text":"new_node_MTG(node, template<:Union{NodeMTG,MutableNodeMTG,NamedTuple,MutableNamedTuple})\nnew_node_MTG(node, fn)\n\nReturns a new NodeMTG matching the one used in node (either NodeMTG or MutableNodeMTG) based on a template, or on a function that takes a node as input and return said template.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# using a NodeMTG as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, NodeMTG(\"/\", \"Leaf\", 1, 2))\n# Note that it returns a MutableNodeMTG because `mtg` is using this type instead of a `NodeMTG`\n\n# using a NamedTuple as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, (link = \"/\", symbol = \"Leaf\", index = 1, scale = 2))\n\n# using a function that returns a template based on the first child of the node:\nMultiScaleTreeGraph.new_node_MTG(\n    mtg,\n    x -> (\n            link = x[1].MTG.link,\n            symbol = x[1].MTG.symbol,\n            index = x[1].MTG.index,\n            scale = x[1].MTG.scale)\n        )\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.nleaves","page":"API","title":"MultiScaleTreeGraph.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves!","page":"API","title":"MultiScaleTreeGraph.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}","page":"API","title":"MultiScaleTreeGraph.node_attributes","text":"Instantiate a attr_type struct with node_attr keys and values\n\nArguments\n\nattr_type::DataType: the type of the structure used to hold the attributes\nnode_attr::String: The node attributes as a Base.Dict\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ordered_children-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.ordered_children","text":"ordered_children(node)\n\nReturn the children as an array, ordered first by \"+\"\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nattr_type::DataType: the type of the structure used to hold the attributes\nfeatures::DataFrame: The features data.frame\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))\nMultiScaleTreeGraph.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}","page":"API","title":"MultiScaleTreeGraph.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MultiScaleTreeGraph.next_line!(f,line)\n\nwhile MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],\"CLASSES\")\n    l[1] = MultiScaleTreeGraph.next_line!(f,line)\nend\n\nclasses = MultiScaleTreeGraph.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.paste_mtg_node","text":"paste_mtg_node(node)\n\nParse the mtg node as it should appear in the mtg file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, var_name, threshold_value; allow_missing = false)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (:var_name) is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nallow_missing=false: Allow missing values for var_name, in which case the cross-section is\n\nrecomputed using the pipe model. Please use this option only if you know why.\n\nDetails\n\nThe node cross-section is partitioned from parent to children according to the number of leaves (i.e. terminal nodes) each child subtree has, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves. If :var_name of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.\n\nWord of caution\n\nSome tips when using this function:\n\nUser must ensure that :var_name has a value for all nodes in the mtg before calling this\n\nversion of pipe_model!, unless allow_missing=true.\n\nNodes with untrusted values should be\n\nset to a value below the threshold value to make pipe_model! recompute them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, root_value)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation uses the following algorithm:\n\nFirst, check how many children a node has.\n\nIf it has one child only, the child cross-section is equal to the node cross-section.\n\nIf more children, the node cross-section is shared between the children according to the number of leaf nodes their subtree has, i.e. the total number of terminal nodes of their subtree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.read_mtg","page":"API","title":"MultiScaleTreeGraph.read_mtg","text":"read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG; sheet_name = nothing)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nsheet_name = nothing: the sheet name in case you're reading an xlsx or xlsm file. It\n\nreads the first sheet if nothing (default behavior).\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:\nmtg = read_mtg(file,Dict);\n\n# We can also read an mtg directly from an excel file from the field:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}","page":"API","title":"MultiScaleTreeGraph.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.name)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.name)\n\ntest = :(x = node.foo)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.attributes[:foo])\n\ntest = :(x = node.MTG.symbol)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.MTG.symbol)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.rotate_point","text":"Rotate a point (x1,y1) around (x0, y0) with angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.siblings-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\", r\"(?<=.)(?=[</+])\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.strip_comments","page":"API","title":"MultiScaleTreeGraph.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.traverse!","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\n\nReturns\n\nNothing for traverse! because it mutates the (sub-)tree in-place, or an Array of whatever the function returns for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}","page":"API","title":"MultiScaleTreeGraph.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"api/#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/5.plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"using MultiScaleTreeGraph\nusing Plots\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"The package provides plots recipes to plot MTGs.","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"To do so, you just have to use the Plots package, and choose a backend. Let's choose the plotly backend for our example:","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"using Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\n\nplot(mtg)\nsavefig(\"mtgplot.html\"); nothing # hide","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"<object type=\"text/html\" data=\"mtgplot.html\" style=\"width:100%;height:500px;\"></object>","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"The default plot is a 2D projection of the MTG. You an also get a 3D projection using the mode keyword argument:","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"plot(mtg, mode = \"3d\")","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"<object type=\"text/html\" data=\"../mtgplot3d.html\" style=\"width:100%;height:500px;\"></object>\n<!-- NB: this plot is made in get_started.md -->","category":"page"},{"location":"the_mtg/mtg_concept/#The-MTG-concept","page":"Concept","title":"The MTG concept","text":"","category":"section"},{"location":"the_mtg/mtg_concept/#Introduction","page":"Concept","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The Multi-scale Tree Graph -or MTG for short- is a data structure for describing a tree-alike object at one or several scales.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Let's take a grass plant as an example:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 1. A Typical grass plant.[1]","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"This plant can be described at the individual scale, as a whole (Fig. 2a). At this scale, we see some attributes such as its species, its spatial coordinates, its height, and if we measure it, its total biomass, or leaf area.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Now if we get closer to the plant we see more details, for example we can now see the dominant axes of the plant (Fig. 2b). This is a new scale of description, let's say the axis scale. We can measure new attributes at this scale such as the biomass or total leaf area of each axis for example.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"If we get closer again, each axis can be described with more details, and we can now differentiate each phytomer (Fig. 2c), i.e. the compound of the leaf and the internode. This is a new scale again, and attributes can be associated to each metamer, for example its length, diameter, biomass, leaf area or volume.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 2. A grass plant described at three different scales: (a) the plant, (b) the axis and (c) the phytomer. The corresponding MTG graph (mono-scale) is shown on the right of each description.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Figure 2 shows a different graph for each scale used for the description, but we can join all scales into a single MTG instead. In the MTG, all scales live together in the same data structure. The elementary object is called a node. The nodes are denoted by the little circles in Figure 2. There is one node for the plant scale (Fig. 2a), two nodes for the axis because there are two tillers (Fig. 2b), and six nodes for the phytomers, one for each (Fig. 2c).","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The resulting MTG describing all scales at once in the same graph can be represented as follows:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: MTG of a grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 3. Multi-scale Tree Graph of a grass plant described at three different scales: the plant (P), the axis (A) and the phytomer (I).","category":"page"},{"location":"the_mtg/mtg_concept/#Node-MTG-and-attributes","page":"Concept","title":"Node MTG and attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Each node, represented as circles in Figure 2 & 3, is described by a set of informations. These informations include the node scale, its symbol and index, its parent and the type of connection -or link- they share, a list of children and some attributes.","category":"page"},{"location":"the_mtg/mtg_concept/#The-scale","page":"Concept","title":"The scale","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"We already talked about the node scale above, it is defined by an integer used to describe the level of description of the object. Usually the value of the scale is 0 for the first node, and increase going towards the finer descriptions. In our example MTG, the plant would be of scale 0, the axes of scale 1 and the phytomers of scale 2.","category":"page"},{"location":"the_mtg/mtg_concept/#The-symbol","page":"Concept","title":"The symbol","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The symbol is used as a name for the type of nodes used in the MTG. In our example MTG in Figure 2 & 3 we had the Plant, the Axis and the Phytomer. A symbol can be present at one scale only, but several symbols can be used in the same scale.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"For example we could add a finer scale of description to our example MTG: the organ scale. At this scale we would have at least three different types of organs: the leaf, the internode and the inflorescence. Each one would share the same scale (i.e. Organ -> scale 3), but would have a different name for their symbol.","category":"page"},{"location":"the_mtg/mtg_concept/#The-index","page":"Concept","title":"The index","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The index of a node is an integer with a completely free value. It is generally used by the user to e.g. keep track of the count of nodes or the branching order. In our example MTG, we incremented our phytomers one by one, but we could start our numbering for each axis for example, allowing us to keep track rapidly of how many phytomers there are in each axis.","category":"page"},{"location":"the_mtg/mtg_concept/#Links","page":"Concept","title":"Links","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Like any other tree graph, each node in an MTG keeps track of which node is its parent, and which are its children. One originality of the MTG is having the choice of using three different types of links between a node and its parent:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"decomposition (/): this link is used when the node decomposes its parent, meaning it has a different scale. For example in Figure 3 the first axis node (A1) decomposes the Plant node (P1).\nfollow (<): it is used when a node follows its parent node with the same scale. In Figure 3, the second phytomer (I3) of the first axis (A1) follows the first one (I1).\nbranch (+): the node branches from its parent. In Figure 3, the second axis (A2) branches from the first phytomer (A1) of the first axis (A1) of the plant.","category":"page"},{"location":"the_mtg/mtg_concept/#Attributes","page":"Concept","title":"Attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Attributes are used to attach data about a node. The MTG standard for the .mtg file format specifies that attributes can be of type a integer, real or character only. But in Julia it is also possible to use any type (e.g. a DataFrame, a user type...). As soon as you don't plan to write it to the disk it is completely fine.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"[1]: The SVG was made by Kelvin13 and found on Wikimedia.","category":"page"},{"location":"tutorials/3.transform_mtg/#Transform-an-MTG","page":"Transform an MTG","title":"Transform an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/3.transform_mtg/#A-note-on-anonymous-functions","page":"Transform an MTG","title":"A note on anonymous functions","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"A lot of examples in this tutorial use anonymous functions. These functions are just a way to quickly define a function. For example a function that adds 1 to its input argument would usually be declared as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"function test(x)\n    x + 1\nend","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we have a name for our function: \"test\". But sometimes we don't need to name our function because its only usage is to be passed to another function. In this case we can declare an anonymous function like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"x -> x + 1","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This is exactly the same function, but without a name.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nWe use x here because it is more or less of a standard, but we could use any other argument name. You'll see that we use node instead when referring to an MTG node (node -> node.name), and x when we refer to a node attribute (x -> x + 1).","category":"page"},{"location":"tutorials/3.transform_mtg/#Introduction-to-MTG-transforming","page":"Transform an MTG","title":"Introduction to MTG transforming","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"MTGs can be very large, and it quickly becomes impossible to manually change the attribute values of the nodes.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Instead, you can compute new attributes for all nodes in an MTG using transform!.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The syntax of transform! is very close to the one from DataFrames.jl. It has several forms that allow to perform computations either on the node or the node attributes directly.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here is a summary of the different forms you can use:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"a :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function or [:var_name1, :var_name2...] => function pair. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.\na :var_name => function => :new_var_name form that does the same as the previous form but explicitly name the resulting variable (can take several variables on left-hand side).\na function => :new_var_name form that applies a function to a node and puts the results in a new attribute. This form is usually applied when searching ancestors or descendants values.\na function form that applies a mutating function to a node, without expecting any output. This form is used when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This tutorial is a deep dive into these different forms.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nAll examples use the mutating version transform!, but there is a non-mutating version too (transform). It is used likewise but returns a modified copy of the mtg, which is a little bit slower.","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-1:-Rename-an-attribute","page":"Transform an MTG","title":"Form 1: Rename an attribute","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Renaming an attribute in an MTG is very simple. It uses the exact same syntax as DataFrames.jl. First, let's check which attributes are available in the MTG:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"get_attributes(mtg)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's rename :Width to remove the capital letter and make it all lowercase:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Width => :width)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's check if the attribute name changed:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"print(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Yes it did!","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The equivalent call with the non-mutating version of transform is:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"new_mtg = transform(mtg, :Width => :width)\n\nprint(get_attributes(new_mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-2:-Compute-new-attributes-based-on-other-attributes","page":"Transform an MTG","title":"Form 2: Compute new attributes based on other attributes","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also compute a new attribute based on another one. For example we could need the length in meters instead of centimetres. To do so, we can compute it as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => (x -> x / 10), ignore_nothing = true)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here transform! take the :Length variable as input, and use it as the argument for the anonymous function x -> x / 10. So what the call do is divide the :Length attribute by 10 for every node in the MTG.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We use ignore_nothing = true to tell transform! not to process the nodes with a value of nothing for the input variable (:Length). Otherwise our computation would error because the function we use do not handle nothing values well: nothing / 10 returns an error.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"warning: Warning\nThe anonymous function must be surrounded by parenthesis (like in DataFrames.jl)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The name of the new attribute is automatically computed based on the input variable name and the name of the function. If the function is anonymous, which is the case in our example, it uses the default \"function\" name instead. Our new variable name is then called :Length_function. Let's check if we can find :Length_function in the list of our MTG attributes:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"print(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also get its values by using descendants on the root node:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"descendants(mtg, :Length_function)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also get the values in the form of a DataFrame instead:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"DataFrame(mtg, :Length_function)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"If we used the log function instead of an anonymous function, the new attribute name would be :Length_log. Here's an example with the log function:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => log, ignore_nothing = true)\n\nprint(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-3:-Form-2-naming-the-new-attribute","page":"Transform an MTG","title":"Form 3: Form 2 + naming the new attribute","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can use the third form to make a computation on the attributes but also explicitly provide the name of the new attribute:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => (x -> x / 10) => :length_m, ignore_nothing = true)\n\nprint(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here our new attribute is named :length_m.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also provide several input variables if we need:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, [:Length, :width] => ((x,y) -> π * x * y^2) => :volume_cm3, ignore_nothing = true)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we provide the input attributes as a Vector of Symbols (could be String also), and given them to an anonymous function that takes two arguments as inputs. Our attributes are given to the anonymous function in order, i.e positional arguments. Then we name our new attribute :volume_cm3. Again, we use ignore_nothing = true to remove the nodes with nothing values for the input attributes :Length and :width.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's see the results:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"DataFrame(mtg, [:Length, :width, :volume_cm3])","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"And of course it also works with Form 2, i.e. computing the new name automatically.","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-4:-Compute-a-new-attribute-based-on-node-values","page":"Transform an MTG","title":"Form 4: Compute a new attribute based on node values","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can compute a new attribute by providing a function directly as the right-hand side instead of an attribute name like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, (node -> node.MTG.symbol) => :Symbol)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we just copied the MTG symbol onto the attributes of the nodes. In this form, it is mandatory to provide a name for the newly created variable, else the function is considered to not return anything (see next form: Form 5: Apply a function to nodes).","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Because this form expect a function that works on nodes directly, it is now possible to use the descendants and ancestors functions. For example we can compute the total length of the subtree of each node in an MTG (i.e. the length of all children of a node) as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"function get_length_descendants(x)\n    nodes_lengths = descendants(x, :Length, ignore_nothing = true)\n    if length(nodes_lengths) == 0\n        return nothing\n    else\n        return sum(nodes_lengths)\n    end\nend\n\ntransform!(mtg, get_length_descendants => :length_subtree)\n\ndescendants(mtg, :length_subtree)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nThis form cannot use ignore_nothing = true because it does not know which attributes to look for before-hand. You'll have to use the filter_fun argument or handle nothing values inside your function instead.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we first declared a new function to get the length of all descendants of a node (get_length_descendants), and then compute the sum only if one or more values for length were found. Then we pass this function to transform! and define our new attribute name as :length_subtree. We define the function first for clarity because it needs to handle nothing values properly before the call to sum.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"An alternative way to write this would be to first get the vector of length for each node, and then to compute the sum like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(\n    mtg,\n    (node -> descendants(node, :Length, ignore_nothing = true)) => :length_subtree2,\n    :length_subtree2 => (x -> length(x) == 0 ? nothing : sum(x)) => :length_subtree2\n)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Because transform! computes the expressions sequentially, we can re-use a computation from the last expression. This is exactly what we are doing here. First we get the values of the length of all descendants of each node, and put the result in a new attribute :length_subtree2. Then we re-use the data from this attribute to compute its sum, but only if the length of the data is not 0, and put the result back to the same attribute :length_subtree2.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can test if both calls returns the same output:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"all(descendants(mtg, :length_subtree2) .== descendants(mtg, :length_subtree))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Yes they are!","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-5:-Apply-a-function-to-nodes","page":"Transform an MTG","title":"Form 5: Apply a function to nodes","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also apply a function that performs a computation on the node like Form 4, but does not return a new attribute value. For example it can be useful to use a printing function to help us debug another function call. Here's an example where we want to print the name of the nodes that are leaf nodes:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, node -> isleaf(node) ? println(node.name,\" is a leaf\") : nothing)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also use this form to mutate the MTG of a node (which is not possible with forms 2 and 3). Here's an example where we change the \"Internode\" symbol into \"I\":","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, node -> node.MTG.symbol = \"I\", symbol = \"Internode\")\n\nmtg","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nIf you change the values of the MTG field of the nodes, you can update the header of the MTG stored in the root node. For example here we updated the symbols, so we should do:mtg[:symbols] = get_classes(mtg).SYMBOL\nmtg[:description] = get_description(mtg)Note that it is not important for writing back to disc as they are automatically updated anyway.","category":"page"},{"location":"tutorials/3.transform_mtg/#Traverse-an-MTG","page":"Transform an MTG","title":"Traverse an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform! uses traverse! under the hood to apply a function call to each node of an MTG. traverse! is just a little bit less easy to use as only Form 5 exists. We can obtain the exact same results as the last example using the same call with traverse!. Let's change the Leaf symbol into L:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"traverse!(mtg, node -> node.MTG.symbol = \"L\", symbol = \"Leaf\")\n\nmtg","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"A benefit of traverse! is it can be used with a do...end block notation for complex sets of instructions:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"traverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend","category":"page"},{"location":"tutorials/3.transform_mtg/#Mutate-an-MTG","page":"Transform an MTG","title":"Mutate an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"For users coming from R, we also provide the @mutate_mtg! macro that is similar to transform! but uses a more tidyverse-alike syntax. All values coming from the MTG node must be preceded by a node., as with the .data$ in the tidyverse. The names of the attributes are shortened to just node.attr_name instead of node.attributes.attr_name though. Here's an example usage:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"@mutate_mtg!(mtg, volume = π * 2 * node.Length, symbol = \"I\")","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We see that we first name the new attribute and assign the result of the computation. Constants are provided as is, and values coming from the nodes are prefixes by node..","category":"page"},{"location":"tutorials/3.transform_mtg/#Helpers","page":"Transform an MTG","title":"Helpers","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"You can use helper functions provided by MultiScaleTreeGraph.jl for:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Filtering nodes: isroot, isleaf\nCompute the number of leaf nodes in the subtree of a node: nleaves\nApply the pipe_model! to the MTG to compute the cross-section of all nodes based on an initial cross-section.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The pipe model is applied as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"first_cross_section = 0.34 # the initial cross-section of the plant\n\ntransform!(mtg, (node -> pipe_model!(node, first_cross_section)) => :cross_section_pipe)\nDataFrame(mtg, :cross_section_pipe)","category":"page"},{"location":"get_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"get_started/#Introduction","page":"Getting started","title":"Introduction","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"This page let's you take a peek at what the package is capable of. If you want a better, more in-depth introduction to the package, take a look at the tutorials, starting from Read and Write MTGs. If you don't know what an MTG is, you can read more about starting from The MTG concept.","category":"page"},{"location":"get_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can install the latest stable version of MultiScaleTreeGraph.jl using this command:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"]add MultiScaleTreeGraph","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"note: Note\nThe ] is used to enter the package mode in the REPL.","category":"page"},{"location":"get_started/#Example","page":"Getting started","title":"Example","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntransform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 100.) => :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Read a simple MTG file:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can compute new variables in the MTG using transform!:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"transform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 100.) => :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The design of transform! is heavily inspired from the eponym function from DataFrame.jl, with little tweaks for MTGs.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"If you prefer a more R-like design, you can use @mutate_mtg! instead:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"@mutate_mtg!(mtg, length_mm = node.Length * 100., filter_fun = x -> !isnothing(x[:Length]))","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can write the MTG back to disk like so:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"write_mtg(\"test.mtg\",mtg)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can also transform it into a DataFrame while selecting the variables you want:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"DataFrame(mtg, [:length_mm, :XX])","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Or convert it to a MetaGraph:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"MetaGraph(mtg)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Finally, we can plot the MTG using any backends from Plots, e.g. Plotly for the 3d:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\n\nplot(mtg, mode = \"3d\") # use mode = \"2d\" for a 2d plot\nsavefig(\"mtgplot3d.html\"); nothing # hide","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"<object type=\"text/html\" data=\"mtgplot3d.html\" style=\"width:100%;height:2100px;\"></object>","category":"page"},{"location":"tutorials/1.manipulate_node/#Manipulate-nodes","page":"Manipulate nodes","title":"Manipulate nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/#Read-an-MTG-file","page":"Manipulate nodes","title":"Read an MTG file","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Let's first read a simple MTG file:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node: Node\nIf you print a node, it will always print its subtree. So if we print the root node it will print the entire MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"read_mtg returns a Node object.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"typeof(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"This node is the root node of the MTG, meaning the first node of the MTG, the one without any parent.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"note: Note\nRoot node and leaf node mean a node without any parent or children respectively. These terms are used in the sense of a tree data structure.","category":"page"},{"location":"tutorials/1.manipulate_node/#The-Node-type","page":"Manipulate nodes","title":"The Node type","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/#What's-a-node?","page":"Manipulate nodes","title":"What's a node?","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"As we learned in the previous section, the node is used as the elementary object to build the MTG. In this package, a node is a data structure used to hold these informations (i.e. fields):","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"name: the name of the node. It is usually generated when read from a file and unique in the MTG;\nparent: the parent node;\nchildren: a dictionary of the children nodes, or nothing if no children;\nsiblings: a dictionary of sibling(s) node(s) if any, or else nothing. Can be nothing if not computed too;\nMTG: the MTG encoding of the node (see below, or NodeMTG);\nattributes: the node attributes. Can be a NamedTuple, a MutableNamedTuple or a Dict or similar (e.g. OrderedDict). The choice of the data structure used depends on how much you plan to change the attributes and their values. Attributes include for example the length or diameter of a node, its colour, 3d position...","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-node's-fields","page":"Manipulate nodes","title":"Get the node's fields","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get a field of a node, you can use the dot notation, e.g.:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.attributes","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"The MTG field from the node helps us describe the node within the MTG. Let's see what's in it:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"fieldnames(typeof(mtg.MTG))","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"We see that it holds the MTG fields: the scale, symbol, index and link to its parent.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-other-nodes","page":"Manipulate nodes","title":"Get other nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"We can move in the MTG from node to node because we know its parents and children.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To do so, we use either the dot notation, or the corresponding functions.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-children-nodes","page":"Manipulate nodes","title":"Get children nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the children of a node, you can use either:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.children","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"or:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"children(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"You can also index the node using an integer, and it will return the corresponding child:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg[1]","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-parent-node","page":"Manipulate nodes","title":"Get the parent node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the parent you can use:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.parent","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Or:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"parent(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Note that it returns nothing here because the root node has no parent.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-node-siblings","page":"Manipulate nodes","title":"Get the node siblings","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the node siblings:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"siblings(mtg[1][1][1][1])","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"note: Note\nWe repeatedly index into the MTG (mtg[1][1][1][1]) to get the fourth generation descendant of the root node, because it is the only one with a sibling in our example MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-any-node","page":"Manipulate nodes","title":"Get any node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get any node in the MTG, you can get it by its name:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"get_node(mtg, \"node_5\")","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-root-node","page":"Manipulate nodes","title":"Get the root node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the root node from any other node, simply use get_root:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node_5 = get_node(mtg, \"node_5\")\n\nget_root(node_5)","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-attributes","page":"Manipulate nodes","title":"Get the attributes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"You can get all node attributes using either the dot notation:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node_5.attributes","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Then you can get the attributes using Symbol or String indexing if the attributes are stored as a Dictionary, or again the dot notation if it's a NamedTuple-alike (see Attributes type for more details). In our case it is a Dictionary (Dict), so we can do:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node_5.attributes[:Length]","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Or you can simply use the more standard way of indexing the node with a String or a Symbol directly:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node_5[:Length]","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"note: Note\nThis is the preferred way to retrieve node attributes as the call does not depend on the type of your attributes, making your code more generic.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get all attributes available in the node subtree, you can use get_features:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"get_features(node_5)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Note that it returns only two attributes here because \"node5\" is a leaf, so it has no sub-tree, and hence [`getfeatures](@ref) only returns the node's attributes. To be sure to get all the attributes available in the MTG, it is better to call [get_features`](@ref) on the root node:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"get_features(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"If you start from another node you can retrieve the root node using get_root:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"get_features(get_root(node_5))","category":"page"},{"location":"the_mtg/our_implementation/#MTG-implementation","page":"Our implementation","title":"MTG implementation","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Introduction","page":"Our implementation","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6 = get_node(mtg, \"node_6\")","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"In this package, the MTG is represented as a tree data structure.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The tree is built from a series of nodes with different fields that describe the topology (i.e. how nodes are connected together) and the attributes of the node.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe package use terms from computer science rather than plant biology. So we use words such as \"root\" in an MTG, which is not the plant root, but the first node in the tree, i.e. the one without any parent. Similarly a leaf node is not a leaf from a plant but a node without any children.","category":"page"},{"location":"the_mtg/our_implementation/#Data-types","page":"Our implementation","title":"Data types","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The nodes have their own data type called Node. A Node has several fields:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(Node)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Here is a little description of each field:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"name: The name of the node. It is completely free, but is usually computing automatically when reading the MTG. The automatic name is based on the index of the node in the MTG, e.g. \"node_1\" for the first node.\nparent: The parent node of the curent node. If the curent node is the root node, it will return nothing. You can test whether a node is a root node sing the isroot function.\nchildren: A dictionary with the children of the current node as values, and their name as keys.\nsiblings: A dictionary with the siblings of the current node as values, and their name as keys.\nMTG: The MTG description of the node (see below)\nattributes: the node attributes, usually of the form of a dictionary, but the type is optional (can be a vector, a tuple...).","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The MTG field of a node describes the topology of the node (see Node MTG and attributes and The MTG section for more details). It is a data structure called NodeMTG, which has four fields:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(NodeMTG)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"These fields correspond to the topology encoding of the node: the type of link with the parent node (decompose: /, follow: <, and branch: +), the symbol of the node, its index, and its description scale.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nNodeMTG is the immutable data type, meaning that information cannot be changed once read. By default the package the mutable equivalent called MutableNodeMTG. Accessing the information of a mutable data structure is slower, but it is more convenient if we need to change its values.","category":"page"},{"location":"the_mtg/our_implementation/#Learning-by-example","page":"Our implementation","title":"Learning by example","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Read-an-MTG","page":"Our implementation","title":"Read an MTG","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Let's print again the example MTG from the previous section:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can use read_mtg from MultiScaleTreeGraph.jl to read this MTG:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"read_mtg returns the first node of the MTG, of type Node","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"typeof(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe Node is a parametric type, that's why typeof(mtg) also returns the type used for the MTG data in the node (MutableNodeMTG) and the type used for the attributes (Dict{Symbol, Any}). But this is not important here.","category":"page"},{"location":"the_mtg/our_implementation/#Accessing-a-node","page":"Our implementation","title":"Accessing a node","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The first node of the whole MTG is all we need to access every other nodes in the MTG, because they are all linked together. For example we can access the data of its child either using its name:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.children[\"node_2\"]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or directly by indexing the node with an integer:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg[1]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can iteratively index into the nodes to access the descendants of a node. For example if we need to access the 6th node (the 2nd Internode), we would do:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6 = mtg[1][1][1][2]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or more simply, we can use the get_node function with the name of the node:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6 = get_node(mtg, \"node_6\")","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"To access the parent of a node, we would do:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6.parent","category":"page"},{"location":"the_mtg/our_implementation/#Accessing-node-data","page":"Our implementation","title":"Accessing node data","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can access the data of a node using the dot notation. For example to get its MTG data:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.MTG","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or its attributes:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.attributes","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe attributes of the root node always include the data from the header sections of an MTG file: the scales of the MTG, the description and the symbols. You can learn more in The MTG sections if you want.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can also access the attributes of a node by indexing the node with a Symbol:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6[:Length]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"... or a String:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6[\"Length\"]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Which are both equivalent to:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6.attributes[:Length]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"You'll find more information on how to make computations over the MTG, how to transform it into a DataFrame, how to write it back to disk, or how to delete and insert new nodes in the tutorials.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Computing","page":"Computing","title":"Computing","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"An MTG can hold a lot of information, usually measured locally at one given scale. It is often interesting to compute new attributes based on the topological environment of the nodes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"For example one could be interested in computing how many leaves a plant has in total.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Let's first read our example MTG:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Descendants","page":"Computing","title":"Descendants","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"It is very easy to get the values of an attribute for all descendants of a node. For example to get the length attributes we would do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"descendants(mtg, :Length)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"The descendants function visits every children nodes recursively until finding a leaf node. The function visits the branching nodes first.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Ancestors","page":"Computing","title":"Ancestors","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"To get the values of an attribute from the ancestors of a node, we would similarly do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"node_5 = get_node(mtg, \"node_5\")\nancestors(node_5, :Length)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filters","page":"Computing","title":"Filters","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Sometimes we only want the values of descendants or ancestors based on a given information. It is possible to filter out nodes based on their scale, symbol, link, or really anything by using the keyword arguments.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-scale","page":"Computing","title":"Filter by scale","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"For example if we want the length of all descendants of the root node of our MTG that are of scale 3 (leaves & internodes), we would simply do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"descendants(mtg, :Length, scale = 3)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-symbol","page":"Computing","title":"Filter by symbol","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"If we need only the leaves, we would filter by their symbol (i.e. \"Leaf\"):","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"descendants(mtg, :Length, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-anything","page":"Computing","title":"Filter by anything","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"And if we want to filter depending on an arbitrary value, we can use the filter_fun argument. For example if we want the length of the nodes, but only the ones with a width greater than 1, will would do like so:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"descendants(mtg, :Length, filter_fun = x -> x[:Width] === nothing ? false : x[:Width] > 1)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"note: Note\nThe function passed to filter_fun must take a node as input, not attributes directly. This is because we want to be able to access any information the user could need. By using nodes as inputs we can even filter on a node parent or children, on a combination of its topological information, or by any of its attributes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"warning: Warning\nBy default if a node does not have an attribute, trying to get its value returns nothing. So if one uses attributes in the function passed to filter_fun, the function must handle missing values. This is what we do here by first testing if x[:Width] is nothing (in which case we return false to filter out the node), and then apply our test on the value of the node width.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-helpers","page":"Computing","title":"Filter helpers","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"There are three other arguments to help filtering nodes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"The first one is all. It is used to stop the search for new nodes as soon as one node does not correspond to the filters the user asked for.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"It is generally used to get all nodes that are following a node for example. You can find an example usage here if you need one.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"The second one is the self argument. It is used to return the value of the node on which we call the function if its true, and only the ancestors / descendants if false (the default).","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"The third one is the recursivity_level, that is used to control the depth of the search for the  ancestors / descendants. It is set to -1 by default, which does not apply any filter on the depth. It is generally used to get e.g. only the children values of a node (recursivity_level = 1).","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"The fourth one is ignore_nothing. It is used to not return the values of a node if it is nothing. Note that it is applied after the filter, so filter_fun still has to handle nothing values.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Transform-values","page":"Computing","title":"Transform values","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Assign-attributes-to-a-node","page":"Computing","title":"Assign attributes to a node","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"It is possible to change the values of attributes in a node. For example one could be interested to compute the total length of all nodes for the scene in our example MTG. In this case we can do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"mtg[:Length] = sum(descendants(mtg, :Length, ignore_nothing = true))","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Compute-attributes-in-an-MTG","page":"Computing","title":"Compute attributes in an MTG","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Now MTGs can be very large, and it quickly becomes cumbersome to manually visit each node to change its value.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Instead, you can compute new attributes for all nodes in an MTG using transform. Head to the next tutorial for more information: Transform an MTG.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Helpers","page":"Computing","title":"Helpers","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Some helper functions can be useful when filtering nodes. For example you can use isroot to test if a node is the root node of the MTG. This is particularly useful when searching for ancestor values, but need a special treatment for the root node.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"Similarly, you can use isleaf to filter the leaf nodes of an MTG.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Computing","title":"Computing","text":"You also have nleaves to compute the number of leaf nodes on the sub-tree of a given node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiScaleTreeGraph","category":"page"},{"location":"#MultiScaleTreeGraph.jl","page":"Home","title":"MultiScaleTreeGraph.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultiScaleTreeGraph.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of MultiScaleTreeGraph.jl is to read, write, analyse and plot MTG (Multi-scale Tree Graph) files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Multi-Scale Tree Graph, or MTG, is a data structure used to encode a plant to describe its topology (i.e. structure) and any attributes (e.g. geometry, colours, state...). It was developed in the AMAP lab in the 90's to cope with the need of a generic yet scalable structure for plant topology and traits measurement, analysis and modelling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The format is described in details in the original paper from Godin et al. (1997).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MTG format helps describe the plant at different scales at the same time. For example we can describe a plant at the scale of the organ (e.g. leaf, internode), the scale of a growth unit, the scale of the axis, the crown or even at the whole plant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can find out how to use the package on the Getting started section, or more about the MTG format in the The MTG concept.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Godin, C., et Y. Caraglio. 1998. « A Multiscale Model of Plant Topological Structures ». Journal of Theoretical Biology 191 (1): 1‑46. https://doi.org/10.1006/jtbi.1997.0561.","category":"page"}]
}
