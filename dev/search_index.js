var documenterSearchIndex = {"docs":
[{"location":"tutorials/6.add_remove_nodes/#Add/remove-nodes","page":"Add/remove nodes","title":"Add/remove nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Make-an-MTG-manually","page":"Add/remove nodes","title":"Make an MTG manually","text":"It is very easy to add or remove nodes in an MTG. Actually, we can even construct an MTG completely manually.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Root-node","page":"Add/remove nodes","title":"Root node","text":"Create the root node:\n\nmtg = Node(MutableNodeMTG(\"/\", \"Plant\", 0, 1), Dict{Symbol,Any}(:species => \"Grassy-plant\"))\n\nThe first argument to Node is its MTG description: link with parent, scale, index, and symbol. It is given as a MutableNodeMTG (or a NodeMTG). The second argument contains node attributes.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Node-id","page":"Add/remove nodes","title":"Node id","text":"The ids of the nodes should be unique. They are automatically computed using new_id starting by 1 at the root node:\n\nnew_id(mtg)","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Adding-new-nodes","page":"Add/remove nodes","title":"Adding new nodes","text":"To create a child node, we use a different method of Node. This method is close to the one we used for the root, except there is a new argument at the first position: the parent node. Here we use the root node as the parent (mtg):\n\nIN1 = Node(mtg, MutableNodeMTG(\"/\", \"Internode\", 0, 2), Dict{Symbol,Any}(:diameter => 0.1, :length => 0.5))\n\nNow the MTG has two nodes:\n\nmtg\n\nWe can continue like this indefinitely. For example we can add a leaf to the first internode:\n\nNode(IN1, MutableNodeMTG(\"+\", \"Leaf\", 0, 2), Dict{Symbol,Any}(:area => 0.2))\n\nnote: Note\nIf a node has no children, there is no need to keep track of it in an object.\n\nAnd an internode following the first internode:\n\nIN2 = Node(IN1, MutableNodeMTG(\"<\", \"Internode\", 1, 2), Dict{Symbol,Any}(:diameter => 0.15, :length => 0.3))\n\nAnd a leaf to it:\n\nNode(IN2, MutableNodeMTG(\"+\", \"Leaf\", 1, 2), Dict{Symbol,Any}(:area => 0.2))\n\nAnd here is our resulting MTG:\n\nmtg\n\nAnd the attributes:\n\nto_table(mtg)","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Inserting-nodes","page":"Add/remove nodes","title":"Inserting nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insertion-functions","page":"Add/remove nodes","title":"Insertion functions","text":"Adding nodes step by step is easy, but sometimes we want to insert nodes in-between other nodes. We can still use Node to do so, but it becomes a bit cumbersome because you'll have to handle manually the changes in parents, children and siblings.\n\nWe provide some helper functions that does it for you instead:\n\ninsert_parent!: add a new parent node\ninsert_child!: add a new child node\ninsert_sibling!: add a new sibling node\ninsert_generation!: add a new child node, but this new child is considered a whole new generation, meaning the previous children of the node become the children of the new node.\n\nwarning: Warning\nNote the singular form for the name of the functions. The plural form does the job on the whole MTG for selected nodes (see Insert nodes at position).","category":"section"},{"location":"tutorials/6.add_remove_nodes/#The-NodeMTG","page":"Add/remove nodes","title":"The NodeMTG","text":"Those functions use a NodeMTG (or MutableNodeMTG), and automatically:\n\nfind a unique id for the node\nadd its children, parents and siblings\nupdate the links of the parents / siblings / children\n\nmtg_2 = deepcopy(mtg)\n\ninsert_parent!(mtg_2, NodeMTG(:/, :Scene, 0, 0))\n\nmtg_2 = get_root(mtg_2)\n\nThe NodeMTG can also be computed based on the node on which we insert the new node. In this case we can pass a function that take the node as input and returns the template for us:\n\nmtg_2 = deepcopy(mtg)\n\ninsert_parent!(\n    mtg_2,\n    node -> (\n        link = link(node),\n        symbol = :Scene,\n        index = index(node),\n        scale = scale(node) - 1\n    )\n)\nmtg_2 = get_root(mtg_2)\n\nnode_mtg(mtg_2)\n\nThe MTG encoding field of the newly-created root node (node_mtg(mtg_2)) used some of the information from the MTG to compute its values.\n\nnote: Note\nWe use get_root to recompute mtg_2 because insert_parent! always return the input node, which is not the root node of the MTG anymore.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Node-attributes","page":"Add/remove nodes","title":"Node attributes","text":"We can also provide attributes for the new node using the attr_fun argument. attr_fun expects a function that computes new attributes based on the input node. This function must return attribute values of the same type as the one used for other nodes attributes in the MTG (e.g. Dict or NamedTuple).\n\nTo know what is the type used for the attributes of your MTG, you can use typeof as follows:\n\ntypeof(node_attributes(mtg))\n\nIf you just need to pass attributes values to a node, you can do as follows:\n\nmtg_2 = deepcopy(mtg)\n\ninsert_child!(\n    mtg_2,\n    NodeMTG(:/, :Axis, 0, 2),\n    node -> Dict{Symbol, Any}(:length => 2, :area =>  0.1)\n)\n\nnode_attributes(mtg_2[1])\n\nBut we can also compute our attributes based on other nodes data:\n\nmtg_2 = deepcopy(mtg)\n\ninsert_child!(\n    mtg_2,\n    NodeMTG(:/, :Axis, 0, 2),\n    node -> Dict{Symbol, Any}(:total_length => sum(descendants(node, :length, ignore_nothing = true)))\n)\n\nnode_attributes(mtg_2[1])\n\nWe use mtg_2[1] here to get the first child of the root node.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Delete-a-node","page":"Add/remove nodes","title":"Delete a node","text":"It is possible to remove a single node in an MTG using delete_node!. For example if we want to delete the second internode (node 4):\n\nmtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 4))\n\nmtg_del\n\nAs we can see the new MTG has only one internode now, and the children of the second internode are now the children of its parents, the first internode.\n\nBut what if we deleted the first internode?\n\nmtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 2))\n\nmtg_del\n\nWe don't see it here in the documentation but this expressions returns a warning now. It says:\n\nWarning: Scale of the child node branched but its deleted parent was decomposing. Keep branching, please check if the decomposition is still correct.\n\nThis is because we don't really know what should be the new link for a branching child replacing a decomposing node. So by default we don't make any assumption and keep the scale of the child as it is, in the hope the user will look into it.\n\nIn our example the first leaf is now branching from the plant, while it should decompose it because it is not of the same scale. But a leaf decomposing a Plant has no meaning botanically. The best approach would be to keep an intermediary node, as it was before.\n\nThe user can define its own rules for the new links using the child_link_fun keyword argument of delete_node! (click to see an example usage). It expect a function that takes the child node as input and return its new link.\n\nFor example one could decide to never replace the children link and manage them afterward. In this case we can use the identity function like this:\n\nmtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 2), child_link_fun = link)\n\nmtg_del\n\nIt didn't change anything here because the child already kept its own link. But it will differ for other types of parent / children links.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insert/remove-nodes-programmatically","page":"Add/remove nodes","title":"Insert/remove nodes programmatically","text":"Sometimes we want to remove or add a lot of nodes in an MTG. This is possible to do it programmatically using dedicated functions.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Delete-nodes","page":"Add/remove nodes","title":"Delete nodes","text":"We can remove all nodes that meet specific conditions given by the usual node filters (see Filters for more details). For example one could remove all nodes of scale 2 in an MTG, i.e. all nodes except the Plant in our example:\n\nmtg_2 = deepcopy(mtg)\n\ndelete_nodes!(mtg_2, scale = 2)\n\nWe can also remove nodes with more complex filters, for example all nodes with an index greater or equal to 1:\n\nmtg_3 = deepcopy(mtg)\n\ndelete_nodes!(mtg_3, filter_fun = node -> node_mtg(node).index >= 1)\n\nnote: Note\ndelete_nodes! always returns the root node of the resulting MTG. If the old root was deleted and had one child, that child becomes the new root. If the old root had several children, the function returns an error. In practice, re-assign the result to keep the correct root reference after deletions.\n\nAs for delete_node! (singular), by default delete_nodes! (plural) uses new_child_link to re-link the children of the deleted nodes, but the user can provide a custom function. See the function details to learn more about it.","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insert-nodes","page":"Add/remove nodes","title":"Insert nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insert-nodes-at-position","page":"Add/remove nodes","title":"Insert nodes at position","text":"We can add new nodes in an MTG programmatically using:\n\ninsert_parents!: add a new parent node to the filtered nodes\ninsert_children!: add a new child node to the filtered nodes\ninsert_siblings!: add a new sibling node to the filtered nodes\ninsert_generations!: add a new child node to the filtered nodes, but this new child is considered a whole new generation, meaning the previous children of the targeted nodes become the children of the new child node (i.e. a new generation).\n\nwarning: Warning\nNote the plural form for the name of the functions. The singular form does the same thing but only on the node we provide as input. The plural forms do the job for every filtered node in the MTG.\n\nThe functions insert new nodes based either on a template NodeMTG or a function that computes it. The attributes of the nodes are empty by default, be can also be provided by the user either as is, or as a function that computes them.\n\nThe id of the inserted node is automatically computed using new_id.\n\nFor example if we need to insert new Flower nodes as parents of each Leaf, we would do:\n\nmtg_4 = deepcopy(mtg)\ntemplate = MutableNodeMTG(:+, :Flower, 0, 2)\ninsert_parents!(mtg_4, template, symbol = :Leaf)\n\nSimilarly, we can add a new child to leaves using insert_children!:\n\ntemplate = MutableNodeMTG(:/, :Leaflet, 0, 3)\ninsert_children!(mtg_4, template, symbol = :Leaf)\n\nUsually, the flower is positioned as a sibling of the leaf though. To do so, we can use insert_siblings!:\n\nmtg_5 = deepcopy(mtg)\ntemplate = MutableNodeMTG(:+, :Flower, 0, 2)\ninsert_siblings!(mtg_5, template, symbol = :Leaf)","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Compute-the-template-on-the-fly","page":"Add/remove nodes","title":"Compute the template on the fly","text":"The template for the NodeMTG can also be computed on the fly for more complex designs:\n\ninsert_children!(\n    mtg_5,\n    node -> if node_id(node) == 3 MutableNodeMTG(:/, :Spear, 0, 3) else MutableNodeMTG(:/, :Leaflet, 0, 3) end,\n    symbol = :Leaf\n)","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Compute-attributes-on-the-fly","page":"Add/remove nodes","title":"Compute attributes on the fly","text":"The same is true for the attributes. We can provide them as is:\n\ninsert_siblings!(\n    mtg_5,\n    MutableNodeMTG(:+, :Leaf, 0, 2),\n    Dict{Symbol, Any}(:area => 0.1),\n    symbol = :Leaf\n)\n\nOr compute them based on the node on which we insert the new nodes. For example if we want the new node to take twice the values of the area of the node it is inserted on, we would do:\n\ninsert_siblings!(\n    mtg_5,\n    MutableNodeMTG(:+, :Leaf, 0, 2),\n    node -> node[:area] === nothing  ? nothing : Dict{Symbol, Any}(:area => node[:area] * 2),\n    symbol = :Leaf\n)\n\ndanger: Danger\nThe function used to compute the attributes must return data using the same structure as the one used for the other nodes attributes. In our example it returns a Dict{Symbol, Any}, but it can be different depending on your MTG. To know which structure you should use, use this command:typeof(node_attributes(mtg))\n\nLet's see the results for the area of our leaves:\n\ndescendants(mtg_5, :area, self = true)","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Write-the-MTG","page":"Add/remove nodes","title":"Write the MTG","text":"Finally, we can write our newly created MTG to disk using write_mtg. The header of the MTG file will be computed automatically based on the information in the MTG. If you want to pass your own header information you can use the corresponding arguments in the function, e.g. classes.\n\nwrite_mtg(\"myMTG.mtg\",mtg)","category":"section"},{"location":"tutorials/7.performance_considerations/#Performance-Considerations","page":"Performance Considerations","title":"Performance Considerations","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/#Introduction","page":"Performance Considerations","title":"Introduction","text":"This tutorial covers some of the performance considerations when using MultiScaleTreeGraph.jl. It is not meant to be a comprehensive guide, but rather a starting point for users to understand the performance implications of their code.\n\nIt is important to note that MultiScaleTreeGraph.jl is high-performance by design. The package is designed to be as fast as possible considering the most common use cases. However, there are some things that the user can do to improve performance.","category":"section"},{"location":"tutorials/7.performance_considerations/#Performance-Tips","page":"Performance Considerations","title":"Performance Tips","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/#Vocabulary","page":"Performance Considerations","title":"Vocabulary","text":"This page uses a few technical words. Here is what they mean in MTG terms:\n\nTraversal: visiting nodes one after another in the graph.\nRequest: asking the MTG for data, for example descendants(mtg, :Length) or ancestors(node, :Width).\nDirect traversal: reading the graph by following parent/children links directly.\nIndexed traversal: using a precomputed lookup table to answer some descendant requests faster.\nDFS (Depth-First Search): one way to visit nodes; it goes deep into one branch before moving to the next branch.","category":"section"},{"location":"tutorials/7.performance_considerations/#Attribute-backend","page":"Performance Considerations","title":"Attribute backend","text":"By default, read_mtg uses ColumnarStore, a typed per-symbol columnar backend. This is optimized for traversal + attribute extraction workloads and reduces repeated dictionary lookups in hot loops.\n\nThe explicit attribute API is:\n\nattribute(node, :key; default=nothing)\nattribute!(node, :key, value)\nattributes(node, format=:namedtuple | :dict)\nadd_column!, drop_column!, rename_column! for schema updates\n\nread_mtg always uses the typed columnar backend. If you build nodes manually, you can still pass Dict/NamedTuple values, and they are converted automatically to columnar attributes.","category":"section"},{"location":"tutorials/7.performance_considerations/#MTG-encoding","page":"Performance Considerations","title":"MTG encoding","text":"The MTG encoding is the type used to store the MTG information about the node, i.e. the scale, index, symbol and link.\n\nBy default, MultiScaleTreeGraph.jl uses a mutable encoding (MutableNodeMTG), which allows for modifying this information. However, if the user does not need to modify these, it is recommended to use an immutable encoding instead (NodeMTG). This will improve performance significantly.\n\nThe internal representation of MTG symbol and link values is based on Symbol for faster comparisons and lower repeated allocations. For backward compatibility, string inputs are still accepted everywhere (constructors and filters), but using symbols in performance-critical code is recommended:\n\nNodeMTG(:/, :Internode, 1, 2)\ntraverse(mtg, x -> x, symbol=:Internode, link=:<)","category":"section"},{"location":"tutorials/7.performance_considerations/#Traversal:-node-caching","page":"Performance Considerations","title":"Traversal: node caching","text":"MultiScaleTreeGraph.jl visits all nodes by default when traversing a tree. This is usually fast, but not always optimal. For example, in a very large tree with only two leaves of interest, we still visit every node even though we only need those two leaves.\n\nTo improve performance, it is possible to cache any type of traversal, including any kind of filter on the nodes, and then use the cached traversal instead of the default one. This will improve performance significantly.\n\nnote: Note\nA cache is simply a saved result that can be reused later. Here, it saves references to the nodes selected by a traversal so the package does not need to re-scan the full tree each time. This usually improves speed at the cost of a small amount of extra memory.\n\nTo cache a traversal, you can use cache_nodes!. For example, if you want to cache all the leaf nodes in the MTG, you can do:\n\ncache_nodes!(mtg, symbol = :Leaf)\n\nThis will cache all the nodes with the symbol :Leaf in the MTG. Then, the tree traversal functions will use the cached traversal to iterate over the nodes.\n\ntip: Tip\nTree traversal is very fast, so caching nodes is not always necessary. Caching should be used when the traversal is needed multiple times, and the traversal is sparse, i.e. a lot of nodes are filtered-out.","category":"section"},{"location":"tutorials/7.performance_considerations/#Traversal:-descendants-values-caching","page":"Performance Considerations","title":"Traversal: descendants values caching","text":"Similarly to caching nodes during tree traversal, descendants! (the ! means \"update in place\") provides a way to cache values from descendants of a node. This is useful when these values are needed many times, because it avoids traversing the tree repeatedly. For example, this is useful when computing total biomass supported by each segment.","category":"section"},{"location":"tutorials/7.performance_considerations/#In-place-traversal-outputs","page":"Performance Considerations","title":"In-place traversal outputs","text":"For repeated requests on large trees, prefer reusing buffers with in-place methods to reduce allocations:\n\nvals = Float64[]\nnodes = typeof(mtg)[]\n\ndescendants!(vals, mtg, :Length)\nancestors!(vals, get_node(mtg, 5), :Length)\ndescendants!(nodes, mtg, self=true)\n\nThis pattern is especially useful when the same request is executed many times (e.g. across millions of leaves).\n\ntype= for descendants/ancestors is deprecated because return eltypes are inferred automatically from typed columns.","category":"section"},{"location":"tutorials/7.performance_considerations/#Hybrid-descendants-backend-(growth-safe)","page":"Performance Considerations","title":"Hybrid descendants backend (growth-safe)","text":"For descendants(node, key, ...) on columnar MTGs, the package supports:\n\n:auto (default): use direct graph traversal when the MTG is changing a lot, and switch to indexed traversal when read requests dominate\n:pointer: always use direct graph traversal\n:indexed: always use the index (rebuilding it when structure changed)\n\nIn other words:\n\nIf your simulation is currently growing a lot (many inserted/deleted organs), :pointer behavior is usually best.\nIf your simulation is mostly reading values repeatedly from a mostly stable structure, :indexed behavior can be faster.\n:auto tries to choose between both automatically.\n\ndescendants_strategy(mtg)          # :auto\ndescendants_strategy!(mtg, :pointer)\ndescendants_strategy!(mtg, :indexed)\ndescendants_strategy!(mtg, :auto)\n\nTypical mixed workflow:\n\n# Growth phase (many structural mutations):\ndescendants_strategy!(mtg, :pointer)\n\n# Analysis phase (many repeated descendant requests):\ndescendants_strategy!(mtg, :auto)   # or :indexed if structure is stable","category":"section"},{"location":"tutorials/4.convert_mtg/#Converting-MTGs","page":"Converting MTGs","title":"Converting MTGs","text":"We can do a lot using the MTG format, but sometimes we want our data in another format.\n\nThat's why MultiScaleTreeGraph.jl provides functions to expose an MTG as a Tables.jl source, or convert it into a graph.","category":"section"},{"location":"tutorials/4.convert_mtg/#MTG-to-table","page":"Converting MTGs","title":"MTG to table","text":"To get a unified table view of the MTG, you can use:\n\ntbl = to_table(mtg)\n\nThe unified table reports MTG topology columns plus all attributes:\n\nnode_id: the unique ID of the node in the whole MTG\nsymbol: the node symbol\nscale: the node scale\nindex: the node index\nparent_id: the node's parent id\nlink: the link between the node and its parent\n\nsymbols and scales are shown as table metadata in the display header (not as columns).\n\nIf you only need a few attributes, you can select them directly:\n\nto_table(mtg, vars=[:Width, :Length])\n\nIt is also possible to get a per-symbol table:\n\nleaf_tbl = to_table(mtg, symbol=:Leaf)\n\nPer-symbol tables can also select attributes:\n\nto_table(mtg, symbol=:Leaf, vars=[:Width, :Length])\n\nYou can also materialize directly into a sink when available in your environment:\n\nusing DataFrames\ndf = to_table(mtg, vars=[:Width, :Length], sink=DataFrame)\n\nIf you use DataFrames.jl in your own project, DataFrame(mtg) still works because MTGs implement the Tables.jl interface.\n\nusing DataFrames\ndf = DataFrame(mtg)","category":"section"},{"location":"tutorials/4.convert_mtg/#MTG-to-MetaGraph","page":"Converting MTGs","title":"MTG to MetaGraph","text":"We can convert an MTG into a MetaGraph using MetaGraph():\n\nmg = MetaGraph(mtg)\n\nThis is particularly useful if you want to benefit from the algorithm provided by Graphs.jl and MetaGraphsNext.jl, such as writing into more standard formats such as DOTFormat or MGFormat (or any other available from GraphIO.jl), plotting with GraphPlot.jl or NetworkLayout.jl, or computing e.g. flow with GraphsFlows.jl.","category":"section"},{"location":"the_mtg/mtg_format/#The-.mtg-file-format","page":"File format","title":"The .mtg file format","text":"The .mtg file format was developed in the AMAP lab to be able to describe a plant in the MTG format directly in a file.\n\nThe file format is generally used when measuring a plant on the field or to write on disk the results of an architectural model such as AMAPSim or VPalm for example. This format helps exchange and archive data about plants in a standard and efficient way.\n\nThe format is described in details in the original paper from Godin et al. (1998), but our implementation in Julia is detailed in this section.","category":"section"},{"location":"the_mtg/mtg_format/#Example-MTG","page":"File format","title":"Example MTG","text":"Let's define a very simple virtual plant composed of only two internodes and two leaves:\n\n<div class=\"sketchfab-embed-wrapper\">\n<iframe title=\"A 3D model\" width=\"640\" height=\"480\" src=\"https://sketchfab.com/models/2a699871f6f6459faa11c206bf81ae9a/embed?autospin=0.2&amp;autostart=1&amp;preload=1&amp;ui_controls=1&amp;ui_infos=1&amp;ui_inspector=1&amp;ui_stop=1&amp;ui_watermark=1&amp;ui_watermark_link=1\" frameborder=\"0\" allow=\"autoplay; fullscreen; vr\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n<p style=\"font-size: 13px; font-weight: normal; margin: 5px; color: #4A4A4A;\">\n<a href=\"https://sketchfab.com/3d-models/a-simple-3d-plant-2a699871f6f6459faa11c206bf81ae9a?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">A simple 3D plant</a>\nby <a href=\"https://sketchfab.com/rvezy?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">rvezy</a>\non <a href=\"https://sketchfab.com?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">Sketchfab</a>\n</p>\n</div>\n\nThe corresponding MTG file is provided with this package. Let's print it using Julia's built-in read method:\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))\n\nThis is a consequent file for such a tiny plant! This is because MTG files have a header with several sections before the MTG of the plant itself, which only appears after the MTG: line.\n\nLet's dig into the information we have here.","category":"section"},{"location":"the_mtg/mtg_format/#The-MTG-sections","page":"File format","title":"The MTG sections","text":"","category":"section"},{"location":"the_mtg/mtg_format/#Introduction","page":"File format","title":"Introduction","text":"An MTG file is divided into five sections. These sections are defined by a keyword and a colon. The content of each section appears on a new line right after the keyword. A section can appear right after the content of the previous section, or they can be separated by blank lines. In fact, all blank lines are ignored in an MTG file.","category":"section"},{"location":"the_mtg/mtg_format/#The-CODE-section","page":"File format","title":"The CODE section","text":"The first section of an MTG file is the CODE section. It must appear first in the file as it is used to determine which version of the format specification the MTG file is following. The standard format in 2021 is the FORM-A specification. A new format is under reflexion but is not yet available.","category":"section"},{"location":"the_mtg/mtg_format/#The-CLASSES-section","page":"File format","title":"The CLASSES section","text":"The CLASSES section lists all symbols used in the MTG, and associates the scale of each symbol.\n\nThe data is presented as a table with five columns:\n\nSYMBOL: the string used for the node symbol.\nSCALE: the scale of the symbol, meaning all nodes with the given symbol will have this scale.\nDECOMPOSITION: This is not used anymore\nINDEXATION: This is not used anymore\nDEFINITION: This is not used anymore\n\nThe first row of the table is reserved and shouldn't be updated. It is a standard to use the dollar sign as the symbol for the scene, i.e. the node with the higher scale that encompass all MTGs. This node is usually not used in an MTG because MTG files mostly describe just a single plant (or a part of), not a whole scene.\n\nwarning: Warning\nThe symbol must be a character string without any numbers at the end, because the index of a node is read as the numbers at the end of a node name, so if a node symbol ends with a number, it will be parsed as an index. For example a symbol written Axis1 with index 1 will give Axis11 in the MTG, which will be parsed as Axis for the symbol and 11 for the index. Numbers are allowed inside the symbol though, e.g. Ax1s is allowed.","category":"section"},{"location":"the_mtg/mtg_format/#The-DESCRIPTION-section","page":"File format","title":"The DESCRIPTION section","text":"The DESCRIPTION section is a table with four columns, and it defines a set of topological rules the MTG nodes of a same scale must follow. The rules are completely optional, but the header of the section is mandatory. In other words, the table can be empty.\n\nThe LEFT column designates the symbol of a parent node, the RIGHT column the symbol of a child node, the RELTYPE column the type of links allowed between the two, and MAX the maximum number of times these types of connexions are allowed in the MTG. The user can use a question mark to denote no maximum.\n\nnote: Note\nThe rules only apply between symbols sharing the same scale (e.g. a node with itself, or in our example, the Internode with a Leaf).\n\nThese rules are mainly used to check the integrity of an MTG that has been written by hand on the field.\n\nwarning: Warning\nThis package does not implement any check on the rules yet. You can let this section empty (with the header) for your MTG if you don't plan to read it with other tools than MultiScaleTreeGraph.jl.","category":"section"},{"location":"the_mtg/mtg_format/#The-FEATURES-section","page":"File format","title":"The FEATURES section","text":"This section is a table with two columns that define the name of the attributes (or features) that can be attached to nodes, and the type of these attributes. This section makes sure that attributes are interpreted correctly when parsing the file.\n\nThe NAME column is used to give the name of an attribute, and the TYPE column its type. The type can be:\n\nREAL for real numbers, e.g. 0.1\nINT for integer numbers, e.g. 1\nSTRING for strings, e.g. broken\nALPHA for reserved keywords:\nNbEl: NumBer of ELements, the number of children at the next scale\nLength: the node length\nBottomDiameter, the bottom tapering applied to the node for computing its geometry\nTopDiameter, the tapering applied at the top\nState, defines the state of a node. It can take the value D (Dead), A (Alive), B (Broken) , P (Pruned), G (Growing), V (Vegetative), R (Resting), C (Completed), M (Modified), or any combination of these given letters.\n\nwarning: Warning\nThis package does not implement any check on the State of a node, and does not make use of the reserved keywords.","category":"section"},{"location":"the_mtg/mtg_format/#The-MTG-section","page":"File format","title":"The MTG section","text":"This section is the actual MTG. It describes the topology of the plant, and give the possibility to add attributes to them.\n\nThe MTG is encoded as a table with tabulation separated values. The header of this section defines the columns used for describing the topology and the ones used for the attributes. The first column name is reserved and must be named ENTITY-CODE. Then, a set of empty column names (i.e. just tabulations) that defines how many columns are used for the topology. Finally, the following columns are used to define the attributes of the nodes. Their names must match the ones given in The FEATURES section.\n\nEach row of the table usually refers to a single node. The topology is and node description is given in the ENTITY-CODE columns.\n\nIn our example MTG, the first node is the scene: /Scene0. In this package, this notation is called a NodeMTG. It is made out of three different information:\n\nThe link to the parent node: /\nThe node Symbol: Scene\nThe node index: 0\n\nThe link to the parent can be either / (decomposition), < (following) or + (branching). you can read the Node MTG and attributes section for more details on the signification of each. In few words, a node decomposes its parent if it changes the scale of description, follows if it is continuing after its parent, or branching if it branches from its parent.\n\nThe node symbol is used to determine the scale of the node and eventually its properties.\n\nThe node index is completely free. It is mainly used to keep track of the number of following segments on an axis, or the branching order.\n\nThe second node in our example is ^/Individual0. It introduces a new character used as a prefix: ^. By default the parent of a node is defined as the last node present in the column preceding it, e.g.:\n\nnode1 \n node2\n node3\n\nHere node1 is the parent of node2 and node3. But if we want node2 as the parent of node3, we would have to create a new column:\n\nnode1  \n node2 \n  node3\n\nThis means large MTGs would require a lot of columns for the topology encoding. This is where ^ becomes useful. It allows us to write a child in the same column as its parent, as long as the parent has only on child:\n\nnode1 \n node2\n ^node3\n\nIn the example above, node1 is the parent of node2, and node2 is the parent of node3.\n\nnote: Note\nBecause there is no explicit need to change column when nodes are decomposing or following, we usually create a new column only when a node branches to reduce the number of columns in the ENTITY-CODE.\n\nAttributes are then declared in their respective columns defined in the header. If there is no value for an attribute, it is usually declared as an empty column\n\nnote: Note\nMTGs entered manually on the field are usually done in a spreadsheet software such as MS Excel or Only Office / Open Office / Libre Office Calc. Here is an example spreadsheet used on the field.","category":"section"},{"location":"tutorials/0.read_write/#Read-and-Write-MTGs","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"","category":"section"},{"location":"tutorials/0.read_write/#Read","page":"Read and Write MTGs","title":"Read","text":"","category":"section"},{"location":"tutorials/0.read_write/#Reading-a-file","page":"Read and Write MTGs","title":"Reading a file","text":"Reading an MTG is done using the read_mtg function:\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\n\nmtg = read_mtg(file)\n\nThe file given in input can be either a .mtg, .csv, .xlsx or .xlsm file.","category":"section"},{"location":"tutorials/0.read_write/#Options","page":"Read and Write MTGs","title":"Options","text":"The function has one optional argument to set the type used for the MTG field (see next section for more details). It also has a keyword argument to choose the sheet name in case you're reading an xlsx or xlsm file.","category":"section"},{"location":"tutorials/0.read_write/#Attributes-type","page":"Read and Write MTGs","title":"Attributes type","text":"Attributes are stored using the columnar backend (ColumnarAttrs) by default.\n\nThis backend keeps one typed table per symbol and is optimized for repeated traversal and attribute retrieval. In practice:\n\nusers can still create nodes with Dict/NamedTuple-like attribute inputs;\nthose inputs are converted to the columnar representation when nodes are attached to an MTG.\n\nSo for most workflows, there is no extra option to choose here: use the default.","category":"section"},{"location":"tutorials/0.read_write/#MTG-encoding-type","page":"Read and Write MTGs","title":"MTG encoding type","text":"The MTG encoding type can be either immutable or mutable. By default we use a mutable one (MutableNodeMTG), but you can use the immutable one by setting the mtg_type argument of the function to NodeMTG. If you're planning on modifying the MTG encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nnote: Note\nAgain, if you don't know what to use, use the default.","category":"section"},{"location":"tutorials/0.read_write/#Sheet-name","page":"Read and Write MTGs","title":"Sheet name","text":"If you're reading your MTG from a .xlsx or .xlsm file, you can choose the sheet you want to read by using the keyword argument sheet_name.\n\nIf you don't provide anything for the sheet name, it will read the first one by default.\n\nnote: Note\nKeyword arguments must be explicitly named in the function call. In this case it would be:file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file, sheet_name = \"A3H\")","category":"section"},{"location":"tutorials/0.read_write/#Write","page":"Read and Write MTGs","title":"Write","text":"Writing an MTG back to disk is as simple as this:\n\ntemporary_file = tempname() # using a temporary file here, but you should put the path to the file you want to write\n\nwrite_mtg(temporary_file, mtg)","category":"section"},{"location":"tutorials/0.read_write/#Build-manually","page":"Read and Write MTGs","title":"Build manually","text":"It is also possible to build an MTG from scratch using MultiScaleTreeGraph.jl. It is explained in a further tutorial Make an MTG manually.","category":"section"},{"location":"api/#MultiScaleTreeGraph.jl-functions","page":"API","title":"MultiScaleTreeGraph.jl functions","text":"Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you'll be directed to the function help.\n\nNotable attribute APIs:\n\nattribute, attribute!, attributes, attribute_names\nadd_column!, drop_column!, rename_column!\ndescendants_strategy, descendants_strategy! (choose automatic/direct/indexed descendants retrieval)\nto_table (Tables.jl source/sink entry-point)\n\n","category":"section"},{"location":"api/#MetaGraphsNext.MetaGraph-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g::Node)\n\nConvert an MTG into a MetaGraph.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nMetaGraph(mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.ColumnarStore","page":"API","title":"MultiScaleTreeGraph.ColumnarStore","text":"Marker type used by read_mtg to request the columnar attribute backend.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.MutableNodeMTG","page":"API","title":"MultiScaleTreeGraph.MutableNodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.Node","page":"API","title":"MultiScaleTreeGraph.Node","text":"Node(MTG<:AbstractNodeMTG)\nNode(parent::Node, MTG<:AbstractNodeMTG)\nNode(id::Int, MTG<:AbstractNodeMTG, attributes)\nNode(id::Int, parent::Node, MTG<:AbstractNodeMTG, attributes)\nNode(id::Int, parent::Node, children::Vector{Node}, MTG<:AbstractNodeMTG, attributes)\nNode(\n    id::Int,\n    parent::Node,\n    children::Vector{Node},\n    MTG<:AbstractNodeMTG,\n    attributes;\n    traversal_cache\n)\n\nType that defines an MTG node (i.e. an element) with:\n\nid: The unique id of node (unique in the whole MTG)\nparent: the parent node (if not the root node)\nchildren: an optional array of children nodes\nMTG: the MTG description, or encoding (see NodeMTG or\n\nMutableNodeMTG)\n\nattributes: the node attributes, that can be anything but \n\nusually a Dict{String,Any}\n\ntraversal_cache: a cache for the traversal, used by e.g. traverse to traverse more efficiently particular nodes in the MTG\n\nThe node is an entry point to a Mutli-Scale Tree Graph, meaning we can move through the MTG from any of its node. The root node is the node without parent. A leaf node is a node without any children. Root and leaf nodes are used with their computer science meaning throughout the package, not in the biological sense.\n\nNote that it is possible to create a whole MTG using only the Node type, because it has methods to create a node as a child of another node (see example below). \n\nExamples\n\nmtg = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(mtg, NodeMTG(\"/\", \"Internode\", 1, 2))\n# Note that the node is created with a parent, so it is not necessary to add it as a child of the `mtg ` Node\n\nmtg\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.NodeMTG","page":"API","title":"MultiScaleTreeGraph.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.children-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"AbstractTrees.children","text":"AbstractTrees.children(node::Node{T,A}) where {T,A}\n\nGet the children of a MultiScaleTreeGraph node.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractTrees.parent-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"AbstractTrees.parent","text":"AbstractTrees.parent(node::Node{T,A})\n\nGet the parent of a MultiScaleTreeGraph node. If the node is the root, it returns nothing.\n\nSee also reparent! to update the parent of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractNodeMTG","page":"API","title":"Base.:==","text":"==(a::Node, b::Node)\n\nTest AbstractNodeMTG equality.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:Node","page":"API","title":"Base.:==","text":"==(a::Node, b::Node)\n\nTest Node equality. The parent, children and siblings are not tested, only their id is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"API","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple, GenericNode}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict, GenericNode}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Any}","page":"API","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Integer}","page":"API","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Node}","page":"API","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.names-Tuple{T} where T<:Node","page":"API","title":"Base.names","text":"names(mtg)\n\nGet all attributes names available on the mtg and its children. This is an alias for get_attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parent-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"Base.parent","text":"Base.parent(node::Node{T,A})\n\nGet the parent of a MultiScaleTreeGraph node. If the node is the root, it returns nothing.\n\nSee also reparent! to update the parent of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.print-Tuple{Node}","page":"API","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M<:AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.addchild!","text":"addchild!(p::Node, id::Int, MTG<:AbstractNodeMTG, attributes)\naddchild!(p::Node, MTG<:AbstractNodeMTG, attributes)\naddchild!(p::Node, MTG<:AbstractNodeMTG)\naddchild!(p::Node, child::Node; force=false)\n\nAdd a new child to a parent node (p), and add the parent node as the parent. Returns the child node.\n\nSee also insert_child!, or directly Node where we  can pass the parent, and it uses addchild! under the hood.\n\nExamples\n\n# Create a root node:\nmtg = MultiScaleTreeGraph.Node(\n    NodeMTG(\"/\", \"Plant\", 1, 1),\n    Dict{Symbol,Any}()\n)\n\nroots = addchild!(\n    mtg, \n    NodeMTG(\"+\", \"RootSystem\", 1, 2)\n)\n\nstem = addchild!(\n    mtg, \n    NodeMTG(\"+\", \"Stem\", 1, 2)\n)\n\nphyto = addchild!(\n    stem, \n    NodeMTG(\"/\", \"Phytomer\", 1, 3)\n)\n\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\nancestors(node::Node,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal), or the ancestor nodes that are not filtered-out.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. It is only mandatory for the first method that search for attributes values. The second method returns the node directly. \n\nMake it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: Deprecated. Return types are inferred automatically.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = get_node(mtg, 5)\n\nancestors(leaf_node, :Length)\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1)\nancestors(leaf_node, :Length, scale = 3, ignore_nothing=true)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = :Internode)\nancestors(leaf_node, :Length, symbol = (:Axis,:Internode))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.attribute!-Tuple{Node, Symbol, Any}","page":"API","title":"MultiScaleTreeGraph.attribute!","text":"attribute!(node::Node, key::Symbol, value)\n\nSet one attribute on a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.attribute-Tuple{Node, Symbol, Any}","page":"API","title":"MultiScaleTreeGraph.attribute","text":"attribute(node::Node, key::Symbol; default=nothing)\n\nGet one attribute from a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.attribute_names-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.attribute_names","text":"attribute_names(node::Node)\n\nReturn the attribute names available for this node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.attributes-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.attributes","text":"attributes(node::Node; format=:namedtuple)\n\nGet all attributes from a node as a snapshot.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.branching_order!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.branching_order!","text":"branching_order!(mtg; ascend = true)\n\nCompute the topological branching order of the nodes in an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nNotes\n\nThe order of a node is computed from the maximum order of their children when using the basipetal computation.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nbranching_order!(mtg)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\nbranching_order!(mtg, ascend = false)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.cache_name-Tuple","page":"API","title":"MultiScaleTreeGraph.cache_name","text":"cache_name(vars...)\n\nMake a unique name based on the vars names.\n\nExamples\n\ncache_name(\"test\",\"var\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.cache_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.cache_nodes!","text":"cache_nodes!(node; scale=nothing, symbol=nothing, link=nothing, filter_fun=nothing, overwrite=false)\n\nCache the nodes of the mtg based on the filters that would be applied to a traversal. This is used automatically when traversing using traverse! or transform!.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))), \"test\", \"files\", \"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Cache all leaf nodes:\ncache_nodes!(mtg, symbol=:Leaf)\n\n# Cached nodes are stored in the traversal_cache field of the mtg (here, the two leaves):\n@test MultiScaleTreeGraph.node_traversal_cache(mtg)[\"_cache_c0bffb8cc8a9b075e40d26be9c2cac6349f2a790\"] == [get_node(mtg, 5), get_node(mtg, 7)]\n\n# Then you can use the cached nodes in a traversal:\ntraverse(mtg, x -> symbol(x), symbol=:Leaf) == [:Leaf, :Leaf]\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.clean_cache!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.columnarize!-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.columnarize!","text":"columnarize!(mtg::Node)\n\nBind all node attributes to a single MTGAttributeStore.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.components","page":"API","title":"MultiScaleTreeGraph.components","text":"symbols(mtg)\ncomponents(mtg)\n\nGet all the symbols names, a.k.a. components of an MTG.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.delete_node!-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.delete_node!","text":"deletenode!(node; childlinkfun = newchild_link)\n\nDelete a node and re-parent the children to its own parent.\n\nIf the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nchild_link_fun is a function that takes the child node of a deleted node as input and returns its new link. The default function is new_child_link, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Symbol.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nchild_link_fun = new_child_link: a function that takes the child node of a deleted node\n\nas input and returns its new link (see details).\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes, except for the link (see below).\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nThe default function used for child_link_fun is new_child_link, which tries to be\n\nclever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, :Leaf)\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (:Leaf,:Internode))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.descendants","page":"API","title":"MultiScaleTreeGraph.descendants","text":"descendants(node::Node,key;<keyword arguments>)\ndescendants(node::Node;<keyword arguments>)\ndescendants!(node::Node,key;<keyword arguments>)\ndescendants!(out::AbstractVector,node::Node,key;<keyword arguments>)\n\nGet attribute values from the descendants of the node (acropetal). The first method returns an array of values, the second an array of nodes that respect the filters, and the third the mutating version of the  first one that caches the results in the mtg.\n\nThe mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster when descendants is called repeateadly for the same computation on large trees, but require to clean the chache sometimes  (see clean_cache!).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name (only mandatory for the first and third methods). Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = Inf: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If Inf (the default) or a negative value is provided, there is no  recursion limitation.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: Deprecated. Return types are inferred automatically.\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length)\n\n# Filter by scale:\ndescendants(mtg, :XEuler, scale = 3)\ndescendants(mtg, :Length, scale = 3, ignore_nothing=true) # No `nothing` in output\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = :Leaf)\ndescendants(mtg, :Length, symbol = (:Leaf,:Internode))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# You can also ask for different attributes by passing them as a vector:\ndescendants(mtg, [:Width, :Length]; filter_fun = isleaf)\n# The output is an array of arrays of length of the attributes you asked for.\n\n# It is possible to cache the results in the mtg using the mutating version `descendants!` (note the `!` \n# at the end of the function name):\ntransform!(mtg, node -> sum(descendants!(node, :Length)) => :subtree_length, symbol = :Internode)\n\n# Or using `@mutate_mtg!` instead of `transform!`:\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length)), symbol = :Internode)\n\n# The cache is stored in a temporary variable with a name that starts with `_cache_` followed by the SHA\n# of the function call, *e.g.*: `:_cache_5c1e97a3af343ce623cbe83befc851092ca61c8d`:\nnode_attributes(mtg[1][1][1])\n\n# You can then clean the cache to avoid using too much memory:\nclean_cache!(mtg)\nnode_attributes(mtg[1][1][1])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants!","page":"API","title":"MultiScaleTreeGraph.descendants!","text":"descendants(node::Node,key;<keyword arguments>)\ndescendants(node::Node;<keyword arguments>)\ndescendants!(node::Node,key;<keyword arguments>)\ndescendants!(out::AbstractVector,node::Node,key;<keyword arguments>)\n\nGet attribute values from the descendants of the node (acropetal). The first method returns an array of values, the second an array of nodes that respect the filters, and the third the mutating version of the  first one that caches the results in the mtg.\n\nThe mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster when descendants is called repeateadly for the same computation on large trees, but require to clean the chache sometimes  (see clean_cache!).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name (only mandatory for the first and third methods). Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = Inf: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If Inf (the default) or a negative value is provided, there is no  recursion limitation.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: Deprecated. Return types are inferred automatically.\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length)\n\n# Filter by scale:\ndescendants(mtg, :XEuler, scale = 3)\ndescendants(mtg, :Length, scale = 3, ignore_nothing=true) # No `nothing` in output\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = :Leaf)\ndescendants(mtg, :Length, symbol = (:Leaf,:Internode))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# You can also ask for different attributes by passing them as a vector:\ndescendants(mtg, [:Width, :Length]; filter_fun = isleaf)\n# The output is an array of arrays of length of the attributes you asked for.\n\n# It is possible to cache the results in the mtg using the mutating version `descendants!` (note the `!` \n# at the end of the function name):\ntransform!(mtg, node -> sum(descendants!(node, :Length)) => :subtree_length, symbol = :Internode)\n\n# Or using `@mutate_mtg!` instead of `transform!`:\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length)), symbol = :Internode)\n\n# The cache is stored in a temporary variable with a name that starts with `_cache_` followed by the SHA\n# of the function call, *e.g.*: `:_cache_5c1e97a3af343ce623cbe83befc851092ca61c8d`:\nnode_attributes(mtg[1][1][1])\n\n# You can then clean the cache to avoid using too much memory:\nclean_cache!(mtg)\nnode_attributes(mtg[1][1][1])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants_!-NTuple{10, Any}","page":"API","title":"MultiScaleTreeGraph.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.descendants_strategy-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.descendants_strategy","text":"descendants_strategy(node::Node)\ndescendants_strategy!(node::Node, strategy::Symbol)\n\nGet or set how descendants(node, key, ...) is computed for columnar MTGs.\n\n:auto (default): choose automatically based on workload.\n:pointer: always follow parent/children links directly in the graph.\n:indexed: use a precomputed index for descendant lookups.\n\nThe index is based on a Depth-First Search (DFS) visit order (visit a branch deeply, then the next branch). It can speed up repeated descendant requests on mostly stable trees, while :pointer is often better when the tree structure changes very frequently.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MultiScaleTreeGraph.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.filter_fun_nothing","text":"filter_fun_nothing(filter_fun, ignore_nothing, attr_keys)\n\nReturns a new filtering function that adds a filter on the keys value for nothing if ignore_nothing is true\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_attributes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_attributes","text":"get_attributes(mtg)\n\nGet all attributes names available on the mtg and its children.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_classes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_description-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_features-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_features","text":"get_features(mtg)\n\nCompute the mtg features section based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node-Tuple{Node, Int64}","page":"API","title":"MultiScaleTreeGraph.get_node","text":"get_node(node::Node, id::Int)\n\nGet a node in an mtg by id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6_2 = get_node(mtg, 6)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node_printing!","page":"API","title":"MultiScaleTreeGraph.get_node_printing!","text":"get_node_printing!(node, lead, ref, print_node, node_lead=0, node_ref=\"\")\n\nGet the number of tabulation (in lead) and the \"^\" (in ref) used as a prefix for the node when writting it to a file, based on the topology of its parent. Also get the node printing (e.g. \"/Axis0\") in print_node.\n\nThe function modifies the lead, ref and print_node vectors in place.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nlead = Int[]\nref = String[]\nget_node_printing!(mtg, lead, ref)\n\nlead\nref\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.get_printing-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_root-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_root","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.index!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.index!","text":"index!(node::Node, new_index)\n\nSet the index of the MTG encoding of the node. The index should be some kind of integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.index-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.index","text":"index(node::Node)\n\nGet the index from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_child!","page":"API","title":"MultiScaleTreeGraph.insert_child!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one. It is incremented in the function, \n\nand use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1])\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_children!","page":"API","title":"MultiScaleTreeGraph.insert_children!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Symbols.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(:/, :Shoot, 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generation!","page":"API","title":"MultiScaleTreeGraph.insert_generation!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one. It is incremented in the function, \n\nand use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1])\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generations!","page":"API","title":"MultiScaleTreeGraph.insert_generations!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Symbols.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(:/, :Shoot, 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_nodes!-Union{Tuple{A}, Tuple{N}, Tuple{Node{N, A}, Any, Any}, Tuple{Node{N, A}, Any, Any, Any}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.insert_nodes!","text":"Actual workhorse of insertparents!, insertgenerations!, insertchildren!, insertsiblings!\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_parent!","page":"API","title":"MultiScaleTreeGraph.insert_parent!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one. It is incremented in the function, \n\nand use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1])\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_parents!","page":"API","title":"MultiScaleTreeGraph.insert_parents!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Symbols.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(:/, :Shoot, 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_sibling!","page":"API","title":"MultiScaleTreeGraph.insert_sibling!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one. It is incremented in the function, \n\nand use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1])\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_siblings!","page":"API","title":"MultiScaleTreeGraph.insert_siblings!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Symbols.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(:/, :Shoot, 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.is_segment!-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isleaf-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isroot-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.lastchild-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.lastchild","text":"lastchild(node::Node)\n\nGet the last child of node, or nothing if the node is a leaf.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.lastsibling-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.lastsibling","text":"lastsibling(node::Node)\n\nReturn the last sibling of node (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.link!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.link!","text":"link!(node::Node, new_link)\n\nSet the link of the MTG encoding of the node. It can be one of \"/\", \"<\", or \"+\".\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.link-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.link","text":"link(node::Node)\n\nGet the link from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.list_nodes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.list_nodes","text":"list_nodes(mtg)\n\nList all nodes IDs in the subtree of mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.max_id-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.max_id","text":"max_id(mtg)\n\nReturns the maximum id of the mtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.mtg_table","page":"API","title":"MultiScaleTreeGraph.mtg_table","text":"mtg_table(mtg::Node, vars=nothing)\n\nReturn a unified traversal-ordered table view of an MTG (Tables.jl-compatible). Absent attributes are represented as missing. If vars is provided (Symbol/String/vector/tuple), only these attributes are included.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.new_child_link","page":"API","title":"MultiScaleTreeGraph.new_child_link","text":"new_child_link(node)\n\nCompute the new link of the child node when deleting a parent node. The rule is to give the child node link of its parent node that is deleted, except when the parent was following its own parent.\n\nThe node given as input is the child node here.\n\nThe rule is summarized in the following table:\n\nDeleted node link Child node link New child node link warning\n/ / / \n/ + + yes (1)\n/ < / \n+ / / yes (2)\n+ + + \n+ < + \n< / / \n< + + \n< < < \n\nThe warnings happens when there is no satisfactory way to handle the new link, i.e. when mixing branching and change in scale.\n\nNote that in the case (1) of the warning the first child only takes the \"/\" link, the others keep their links.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.new_id-Tuple{Int64}","page":"API","title":"MultiScaleTreeGraph.new_id","text":"new_id(mtg)\nnew_id(mtg, max_id)\n\nMake a new unique identifier by incrementing on the maximum node id. Hint: prefer using max_id = max_id(mtg) and then new_id(mtg, max_is) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.new_node_MTG","text":"new_node_MTG(node, template<:Union{NodeMTG,MutableNodeMTG,NamedTuple,MutableNamedTuple})\nnew_node_MTG(node, fn)\n\nReturns a new NodeMTG matching the one used in node (either NodeMTG or MutableNodeMTG) based on a template, or on a function that takes a node as input and return said template.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# using a NodeMTG as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, NodeMTG(:/, :Leaf, 1, 2))\n# Note that it returns a MutableNodeMTG because `mtg` is using this type instead of a `NodeMTG`\n\n# using a NamedTuple as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, (link = :/, symbol = :Leaf, index = 1, scale = 2))\n# using a function that returns a template based on the first child of the node:\nMultiScaleTreeGraph.new_node_MTG(\n    mtg,\n    x -> (\n            link = link(x[1]),\n            symbol = symbol(x[1]),\n            index = index(x[1]),\n            scale = scale(x[1]))\n        )\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.nleaves","page":"API","title":"MultiScaleTreeGraph.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves!","page":"API","title":"MultiScaleTreeGraph.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.no_node_filters","page":"API","title":"MultiScaleTreeGraph.no_node_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = :Leaf, link = :<)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.node_attributes!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, A}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.node_attributes!","text":"node_attributes!(node::Node)\n\nSet the attributes of a node, i.e. replace the whole structure by another. This function is internal,  and should not be used directly. Use e.g. node.key = value to set a single attribute of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.node_attributes","text":"node_attributes(node::Node)\n\nGet the attributes of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_id-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_id","text":"node_id(node::Node)\n\nGet the unique id of the node in the MTG.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_mtg-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_mtg","text":"node_mtg(node::Node)\n\nGet the MTG encoding of the node, i.e. the MTG description (see NodeMTG or MutableNodeMTG):\n\nscale: the scale of the node (e.g. 1)\nsymbol: the symbol of the node (e.g. \"Axis\")\nindex: the index of the node (e.g. 1, this is free)\nlink: the link of the node (\"/\", \"+\" or \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_traversal_cache-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_traversal_cache","text":"node_traversal_cache(node::Node)\n\nGet the traversal cache of the node if any.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{4, Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nfeatures::ColumnTable: The parsed features table\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_line_to_node!-NTuple{9, Any}","page":"API","title":"MultiScaleTreeGraph.parse_line_to_node!","text":"parse_line_to_node!(tree_dict, l, line, attr_column_start, node_id, mtg_type, features,classes)\n\nParse a line of the MTG file to a node and add it to the tree dictionary. It may also add several nodes if the line contains several MTG elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = node_id(node)), :(y = node.x + 2), :(scale = 2))\nMultiScaleTreeGraph.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_mtg!-NTuple{6, Any}","page":"API","title":"MultiScaleTreeGraph.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_node_attributes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_node_attributes","text":"Instantiate a ColumnarAttrs struct with node_attr keys and values.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MultiScaleTreeGraph.next_line!(f,line)\n\nwhile MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],\"CLASSES\")\n    l[1] = MultiScaleTreeGraph.next_line!(f,line)\nend\n\nclasses = MultiScaleTreeGraph.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, var_name, threshold_value; allow_missing = false)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (:var_name) is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nallow_missing=false: Allow missing values for var_name, in which case the cross-section is\n\nrecomputed using the pipe model. Please use this option only if you know why.\n\nDetails\n\nThe node cross-section is partitioned from parent to children according to the number of leaves (i.e. terminal nodes) each child subtree has, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves. If :var_name of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.\n\nWord of caution\n\nSome tips when using this function:\n\nUser must ensure that :var_name has a value for all nodes in the mtg before calling this\n\nversion of pipe_model!, unless allow_missing=true.\n\nNodes with untrusted values should be\n\nset to a value below the threshold value to make pipe_model! recompute them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, root_value; name=:_cache_a7118a60b2a624134bf9eac2d64f2bb32798626a)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation uses the following algorithm:\n\nFirst, check how many children a node has.\n\nIf it has one child only, the child cross-section is equal to the node cross-section.\n\nIf more children, the node cross-section is shared between the children according to the number of leaf nodes their subtree has, i.e. the total number of terminal nodes of their subtree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.prune!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.prune!","text":"prune!(node)\n\nPrune a tree at node, i.e. delete the entire sub-tree starting at node (including it).\n\nReturns an error if the node is a root, or the parent node of the (deleted) node.\n\nExamples\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nprune!(get_node(mtg, 6))\n\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.read_mtg","page":"API","title":"MultiScaleTreeGraph.read_mtg","text":"read_mtg(file, mtg_type = MutableNodeMTG; sheet_name = nothing)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nsheet_name = nothing: the sheet name in case you're reading an xlsx or xlsm file. It\n\nreads the first sheet if nothing (default behavior).\n\nDetails\n\nAttributes are always stored as ColumnarAttrs (typed columnar backend). Input values from the file are converted automatically.\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can also read an mtg directly from an excel file from the field:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.rechildren!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Array{Node{T, A}, 1}}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.rechildren!","text":"rechildren!(node::Node{T,A}, chnodes::Vector{Node{T,A}}) where {T,A}\n\nSet the children of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.reparent!-Union{Tuple{N2}, Tuple{N}, Tuple{A}, Tuple{T}, Tuple{N, N2}} where {T, A, N<:Node{T, A}, N2<:Union{Nothing, Node{T, A}}}","page":"API","title":"MultiScaleTreeGraph.reparent!","text":"reparent!(node::N, p::N) where N<:Node{T,A}\n\nSet the parent of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}","page":"API","title":"MultiScaleTreeGraph.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.var)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = mtg[:var])\n\ntest = :(x = node.foo)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = mtg[:foo])\n\ntest = :(x = symbol(node))\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = symbol(mtg))\n\ntest = :(x = node_mtg(node) |> symbol)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = node_mtg(mtg) |> symbol)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scale!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.scale!","text":"scale!(node::Node, new_scale)\n\nSet the scale of the MTG encoding of the node. The scale should be some kind of integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scale-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.scale","text":"scale(node::Node)\n\nGet the scale from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scales-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.scales","text":"scales(mtg)\n\nGet all the scales of an MTG.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.select!-Tuple{Node, Vararg{Any}}","page":"API","title":"MultiScaleTreeGraph.select!","text":"select!(node::Node, args..., <keyword arguments>)\nselect(node::Node, args..., <keyword arguments>)\n\nDelete all attributes not selected in args..., and optionally apply transformations on the fly on the selected variables. This function works similarly to transform! except it keeps only the selected variables, while transform! add new variables.\n\nSee the documentation of transform! for more details on the format of args and on how to use the arguments.\n\nThis function adds one more form to args...: a variable name to just select a variable.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nselect!(mtg, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.siblings-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit_MTG_elements(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.strip_comments","page":"API","title":"MultiScaleTreeGraph.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.symbol!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.symbol!","text":"symbol!(node::Node, symbol)\n\nSet the symbol of the MTG encoding node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.symbol-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.symbol","text":"symbol(node::Node)\n\nGet the symbol from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.symbol_table","page":"API","title":"MultiScaleTreeGraph.symbol_table","text":"symbol_table(mtg::Node, symbol, vars=nothing)\n\nReturn a per-symbol column table view (Tables.jl-compatible). If vars is provided (Symbol/String/vector/tuple), only these attributes are included.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.symbols","page":"API","title":"MultiScaleTreeGraph.symbols","text":"symbols(mtg)\ncomponents(mtg)\n\nGet all the symbols names, a.k.a. components of an MTG.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.to_table-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.to_table","text":"to_table(mtg::Node; symbol=nothing, vars=nothing, sink=nothing)\n\nGeneric table conversion entry-point.\n\nsymbol=nothing: unified traversal-ordered table\nsymbol=<symbol>: per-symbol table\nvars: optional attribute selection (Symbol/String/vector/tuple)\nsink: optional sink materialization (e.g. sink=DataFrame if DataFrames.jl is loaded)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.transform","page":"API","title":"MultiScaleTreeGraph.transform","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or\n\n[:var_name1, :var_name2...] => function => :new_var_name pair. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. The new attribute name is optional and is automatically generated if not provided by concatenating the source column name(s) and the function name if any.\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 expect a function that takes one or more node attributes (== variables) as inputs, while form 3 and 4 expect a function that takes a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  node -> isleaf(node) ? println(node_id(x),\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finally, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.transform!","page":"API","title":"MultiScaleTreeGraph.transform!","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or\n\n[:var_name1, :var_name2...] => function => :new_var_name pair. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. The new attribute name is optional and is automatically generated if not provided by concatenating the source column name(s) and the function name if any.\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 expect a function that takes one or more node attributes (== variables) as inputs, while form 3 and 4 expect a function that takes a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  node -> isleaf(node) ? println(node_id(x),\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finally, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse","page":"API","title":"MultiScaleTreeGraph.traverse","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that is filtered out (false).\ntype::Type = Any: The elements type of the returned array. This can speed-up things. Only available for the non-mutating version.\nrecursivity_level::Int = Inf: The maximum depth of the traversal. Default is Inf (i.e. no limit).\n\nReturns\n\nnothing for traverse! because it mutates the (sub-)tree in-place, or an Array{type} (or Array{Any} if type is not given) for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, node -> isleaf(node) ? println(node_id(node),\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do node\n    if isleaf(node)\n         println(node_id(x),\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse!","page":"API","title":"MultiScaleTreeGraph.traverse!","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Symbols.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Symbols.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that is filtered out (false).\ntype::Type = Any: The elements type of the returned array. This can speed-up things. Only available for the non-mutating version.\nrecursivity_level::Int = Inf: The maximum depth of the traversal. Default is Inf (i.e. no limit).\n\nReturns\n\nnothing for traverse! because it mutates the (sub-)tree in-place, or an Array{type} (or Array{Any} if type is not given) for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, node -> isleaf(node) ? println(node_id(node),\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do node\n    if isleaf(node)\n         println(node_id(x),\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}","page":"API","title":"MultiScaleTreeGraph.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any}}","page":"API","title":"MultiScaleTreeGraph.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2, filter_fun = node -> node.scales !== nothing)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node_id(node)), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node_id(node))\n\n\n\n\n\n","category":"macro"},{"location":"api/#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any}}","page":"API","title":"MultiScaleTreeGraph.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node_id(node)), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node_id(node))\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/5.plotting/#Plotting","page":"Plotting","title":"Plotting","text":"The companion package PlantGeom.jl provides plots recipes to plot MTGs using either Plots.jl or Makie.jl.\n\nTo do so, you just have to use either of the packages, and choose a backend. Let's plot the MTG using CairoMakie:\n\n# import Pkg; Pkg.add(\"CairoMakie\"); Pkg.add(\"PlantGeom\")\nusing CairoMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndiagram(mtg)\n\n(Image: A diagram of the MTG)","category":"section"},{"location":"the_mtg/mtg_concept/#The-MTG-concept","page":"Concept","title":"The MTG concept","text":"","category":"section"},{"location":"the_mtg/mtg_concept/#Introduction","page":"Concept","title":"Introduction","text":"The Multi-scale Tree Graph (MTG) is a format for describing a plant-like branching object at one or several scales.\n\nLet's take a grass plant as an example:\n\n(Image: A grass plant)\n\nFig. 1. A Typical grass plant.[1]\n\nThis plant can be described at the individual scale, as a whole (Fig. 2a). At this scale, we see some attributes such as its species, its spatial coordinates, its height, and if we measure it, its total biomass, or leaf area.\n\nNow if we get closer to the plant we see more details, for example we can now see the dominant axes of the plant (Fig. 2b). This is a new scale of description, let's say the axis scale. We can measure new attributes at this scale such as the biomass or total leaf area of each axis for example.\n\nIf we get closer again, each axis can be described with more details, and we can now differentiate each phytomer (Fig. 2c), i.e. the compound of the leaf and the internode. This is a new scale again, and attributes can be associated to each metamer, for example its length, diameter, biomass, leaf area or volume.\n\n(Image: A grass plant described at different scales)\n\nFig. 2. A grass plant described at three different scales: (a) the plant, (b) the axis and (c) the phytomer. The corresponding MTG graph (mono-scale) is shown on the right of each description.\n\nFigure 2 shows a different graph for each scale, but we can also merge all scales into one MTG. In an MTG, all scales live together in one structure. The basic element is a node (the circles in Figure 2). There is one node for the plant scale (Fig. 2a), two nodes for axes because there are two tillers (Fig. 2b), and six nodes for phytomers, one for each (Fig. 2c).\n\nThe resulting MTG describing all scales at once in the same graph can be represented as follows:\n\n(Image: MTG of a grass plant described at different scales)\n\nFig. 3. Multi-scale Tree Graph of a grass plant described at three different scales: the plant (P), the axis (A) and the phytomer (I).","category":"section"},{"location":"the_mtg/mtg_concept/#Node-MTG-and-attributes","page":"Concept","title":"Node MTG and attributes","text":"Each node, represented as circles in Figure 2 & 3, is described by a set of informations. These informations include the node scale, its symbol and index, its parent and the type of connection -or link- they share, a list of children and some attributes.","category":"section"},{"location":"the_mtg/mtg_concept/#The-scale","page":"Concept","title":"The scale","text":"We already talked about the node scale above, it is defined by an integer used to describe the level of description of the object. Usually the value of the scale is 0 for the first node, and increase going towards the finer descriptions. In our example MTG, the plant would be of scale 0, the axes of scale 1 and the phytomers of scale 2.","category":"section"},{"location":"the_mtg/mtg_concept/#The-symbol","page":"Concept","title":"The symbol","text":"The symbol is used as a name for the type of nodes used in the MTG. In our example MTG in Figure 2 & 3 we had the Plant, the Axis and the Phytomer. A symbol can be present at one scale only, but several symbols can be used in the same scale.\n\nFor example we could add a finer scale of description to our example MTG: the organ scale. At this scale we would have at least three different types of organs: the leaf, the internode and the inflorescence. Each one would share the same scale (i.e. Organ -> scale 3), but would have a different name for their symbol.","category":"section"},{"location":"the_mtg/mtg_concept/#The-index","page":"Concept","title":"The index","text":"The index of a node is an integer with a completely free value. It is generally used by the user to e.g. keep track of the count of nodes or the branching order. In our example MTG, we incremented our phytomers one by one, but we could start our numbering for each axis for example, allowing us to keep track rapidly of how many phytomers there are in each axis.","category":"section"},{"location":"the_mtg/mtg_concept/#Links","page":"Concept","title":"Links","text":"Like any other tree graph, each node in an MTG keeps track of which node is its parent, and which are its children. One originality of the MTG is having the choice of using three different types of links between a node and its parent:\n\ndecomposition (/): this link is used when the node decomposes its parent, meaning it has a different scale. For example in Figure 3 the first axis node (A1) decomposes the Plant node (P1).\nfollow (<): it is used when a node follows its parent node with the same scale. In Figure 3, the second phytomer (I3) of the first axis (A1) follows the first one (I1).\nbranch (+): the node branches from its parent. In Figure 3, the second axis (A2) branches from the first phytomer (A1) of the first axis (A1) of the plant.","category":"section"},{"location":"the_mtg/mtg_concept/#Attributes","page":"Concept","title":"Attributes","text":"Attributes are used to attach data about a node. The MTG standard for the .mtg file format specifies that attributes can be of type integer, real or character only. But in Julia it is also possible to use any type (e.g. a DataFrame, a user type...). As soon as you don't plan to write it to the disk it is completely fine.\n\nnote: Note\nMultiScaleTreeGraph.jl does not check if the attributes are in the correct format when writing to disk. The user should check before writing. This is because the package allows all types for attribues, so we cannot filter on type.\n\n[1]: The SVG was made by Kelvin13 and found on Wikimedia.","category":"section"},{"location":"tutorials/3.transform_mtg/#Transform-an-MTG","page":"Transform an MTG","title":"Transform an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/#A-note-on-anonymous-functions","page":"Transform an MTG","title":"A note on anonymous functions","text":"A lot of examples in this tutorial use anonymous functions. These functions are just a way to quickly define a function. For example a function that adds 1 to its input argument would usually be declared as follows:\n\nfunction plus_one(x)\n    x + 1\nend\n\nHere we have a name for our function: \"plus_one\". But sometimes we don't need to name our function because its only usage is to be passed to another function. In this case we can declare an anonymous function like so:\n\nx -> x + 1\n\nThis is exactly the same function, but without a name.\n\nnote: Note\nWe use x here because it is more or less of a standard, but we could use any other argument name. You'll see that we use node instead when referring to an MTG node (node -> node.var), and x when we refer to a node attribute (x -> x + 1).","category":"section"},{"location":"tutorials/3.transform_mtg/#Introduction-to-MTG-transforming","page":"Transform an MTG","title":"Introduction to MTG transforming","text":"MTGs can be very large, and it quickly becomes impossible to manually change the attribute values of the nodes.\n\nInstead, you can compute new attributes for all nodes in an MTG using transform!.\n\nThe syntax of transform! is very close to the one from DataFrames.jl. It has several forms that allow to perform computations either on the node or the node attributes directly.\n\nHere is a summary of the different forms you can use:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or [:var_name1, :var_name2...] => function => :new_var_name. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to function. The new variable name is optional, and is automatically generated if not provided by concatenating the source column name(s) and the function name if any, this form would be used as: :var_name => function.\na function => :new_var_name form that applies a function to a node and puts the results in a new attribute. This form is usually applied when searching ancestors or descendants values.\na function form that applies a function that directly changes the node, without expecting any output. This form is used when your function already updates the node by itself, e.g. branching_order!.\n\nThis tutorial is a deep dive into these different forms.\n\nnote: Note\nAll examples use transform!, which updates the same MTG object in place. The version without ! (transform) returns a new modified copy instead. The copy version is usually a little slower, but it keeps your original MTG unchanged.","category":"section"},{"location":"tutorials/3.transform_mtg/#Form-1:-Rename-an-attribute","page":"Transform an MTG","title":"Form 1: Rename an attribute","text":"Renaming an attribute in an MTG is very simple. It uses the exact same syntax as DataFrames.jl. First, let's check which attributes are available in the MTG:\n\nget_attributes(mtg)\n\nLet's rename :Width to remove the capital letter and make it all lowercase:\n\ntransform!(mtg, :Width => :width)\n\nLet's check if the attribute name changed:\n\nprint(get_attributes(mtg))\n\nYes it did!\n\nThe equivalent call with the copy-returning version (transform, without !) is:\n\nnew_mtg = transform(mtg, :Width => :width)\n\nprint(get_attributes(new_mtg))","category":"section"},{"location":"tutorials/3.transform_mtg/#Form-2:-Compute-new-attributes-based-on-other-attributes","page":"Transform an MTG","title":"Form 2: Compute new attributes based on other attributes","text":"We can also compute a new attribute based on another one. For example we could need the length in meters instead of centimetres. To do so, we can compute it as follows:\n\ntransform!(mtg, :Length => (x -> x / 10) => :length_m, ignore_nothing = true)\n\nThe magic happens in the :Length => (x -> x / 10) => :length_m expression. transform! takes the :Length variable as input (LHS, Left-hand side of the expression), and use it as the argument for the anonymous function given in the middle of the expression: x -> x / 10. Then it puts the output of the function into a new variable named :length_m (RHS, Right-hand side of the expression)\n\nIn fewer words, we divide the :Length attribute by 10 for every node in the MTG, and put the results in a new attribute called :length_m.\n\nWe use ignore_nothing = true to tell transform! not to process the nodes with a value of nothing for the input variable (:Length). Otherwise our computation would error because the function we use do not handle nothing values well: nothing / 10 returns an error.\n\nwarning: Warning\nThe anonymous function must be surrounded by parenthesis (like in DataFrames.jl)\n\nLet's check if we can find :length_m in the list of our MTG attributes:\n\nprint(get_attributes(mtg))\n\nWe can also get its values by using descendants on the root node:\n\ndescendants(mtg, :length_m)\n\nWe can also inspect values through the MTG table view:\n\nto_table(mtg)\n\nWe can also provide several input variables if we need:\n\ntransform!(mtg, [:Length, :width] => ((x,y) -> π * x * y^2) => :volume_cm3, ignore_nothing = true)\n\nHere we provide the input attributes as a Vector of Symbols (could be String also), and given them to an anonymous function that takes two arguments as inputs. Our attributes are given to the anonymous function in order, i.e positional arguments. Then we name our new attribute :volume_cm3. Again, we use ignore_nothing = true to remove the nodes with nothing values for the input attributes :Length and :width.\n\nLet's see the results:\n\nto_table(mtg)\n\nThe new name of the attribute (the RHS) is optional though. We could write our first example as:\n\ntransform!(mtg, :Length => (x -> x / 10), ignore_nothing = true)\n\nIn this case the name of the new attribute is automatically computed based on the input variable name and the name of the function. If the function is anonymous, which is the case in our example, it uses the default \"function\" name instead. Our new variable name is then called :Length_function.\n\nIf we used a function with a name such as log instead of an anonymous function, the new attribute name would be :Length_log. Here's an example with the log function:\n\ntransform!(mtg, :Length => log, ignore_nothing = true)\n\nprint(get_attributes(mtg))","category":"section"},{"location":"tutorials/3.transform_mtg/#Form-3:-Compute-a-new-attribute-based-on-node-values","page":"Transform an MTG","title":"Form 3: Compute a new attribute based on node values","text":"We can compute a new attribute by providing a function directly as the right-hand side instead of an attribute name like so:\n\ntransform!(mtg, symbol => :Symbol)\n\nThe symbol function takes a node as its first (and only) argument, and returns its symbol. An alternative way of writing this would be:\n\ntransform!(mtg, node -> symbol(node) => :Symbol)\n\nThis particularly useful when we need to compute a new attribute based on the values of the node itself.\n\nHere we just copied the MTG symbol onto the attributes of the nodes. In this form, it is mandatory to provide a name for the newly created variable, else the function is considered to not return anything (see next form: Form 4: Apply a function to nodes).\n\nBecause this form expects a function that works on nodes directly, it is now possible to use the descendants and ancestors functions. For example we can compute the total length of the subtree of each node in an MTG (i.e. the length of all children of a node) as follows:\n\nfunction get_length_descendants(x)\n    nodes_lengths = descendants(x, :Length, ignore_nothing = true)\n    if length(nodes_lengths) == 0\n        return nothing\n    else\n        return sum(nodes_lengths)\n    end\nend\n\ntransform!(mtg, get_length_descendants => :length_subtree)\n\ndescendants(mtg, :length_subtree)\n\nnote: Note\nThis form cannot use ignore_nothing = true because it does not know which attributes to look for before-hand. You'll have to use the filter_fun argument or handle nothing values inside your function instead.\n\nHere we first declared a new function to get the length of all descendants of a node (get_length_descendants), and then compute the sum only if one or more values for length were found. Then we pass this function to transform! and define our new attribute name as :length_subtree. We define the function first for clarity because it needs to handle nothing values properly before the call to sum.\n\nAn alternative way to write this would be to first get the vector of length for each node, and then to compute the sum like so:\n\ntransform!(\n    mtg,\n    (node -> descendants(node, :Length, ignore_nothing = true)) => :length_subtree2,\n    :length_subtree2 => (x -> length(x) == 0 ? nothing : sum(x)) => :length_subtree2\n)\n\nBecause transform! computes the expressions sequentially, we can re-use a computation from the last expression. This is exactly what we are doing here. First we get the values of the length of all descendants of each node, and put the result in a new attribute :length_subtree2. Then we re-use the data from this attribute to compute its sum, but only if the length of the data is not 0, and put the result back to the same attribute :length_subtree2.\n\nWe can test if both calls returns the same output:\n\nall(descendants(mtg, :length_subtree2) .== descendants(mtg, :length_subtree))\n\nYes they are!","category":"section"},{"location":"tutorials/3.transform_mtg/#Form-4:-Apply-a-function-to-nodes","page":"Transform an MTG","title":"Form 4: Apply a function to nodes","text":"We can also apply a function that performs a computation on the node like Form 3, but does not return a new attribute value. For example it can be useful to use a printing function to help us debug another function call. Here's an example where we want to print the id of the nodes that are leaf nodes:\n\ntransform!(mtg, node -> isleaf(node) ? println(node_id(node),\" is a leaf\") : nothing)\n\nWe can also use this form to mutate the MTG of a node (which is not possible with Form 2). Here's an example where we change the \"Internode\" symbol into \"I\":\n\ntransform!(mtg, node -> symbol!(node, :I), symbol = :Internode)\n\nmtg\n\nnote: Note\nIf you change the values of the MTG field of the nodes, you can update the header of the MTG stored in the root node. For example here we updated the symbols, so we should do:mtg[:symbols] = get_classes(mtg).SYMBOL\nmtg[:description] = get_description(mtg)Note that it is not important for writing back to disc as they are automatically updated anyway.","category":"section"},{"location":"tutorials/3.transform_mtg/#Select-an-MTG","page":"Transform an MTG","title":"Select an MTG","text":"As in DataFrames, MultiScaleTreeGraph.jl provides a select! function for deleting all attributes not explicitly provided as arguments to the selection. The selection can also apply transformations on the fly following the same format used in transform!, with one more Form though: just the name of the variable to select.\n\nFor example we can compute the new length in meters, and keep only this result along with the width as follows:\n\nmtg_select = deepcopy(mtg)\n\nselect!(mtg_select, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\nto_table(mtg_select)\n\nThere is also a copy-returning version of the function (select, without !):\n\nmtg_select = select(mtg, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\nto_table(mtg_select)","category":"section"},{"location":"tutorials/3.transform_mtg/#Traverse-an-MTG","page":"Transform an MTG","title":"Traverse an MTG","text":"transform! and select! use traverse! under the hood to apply a function call to each node of an MTG. traverse! is just a little bit less easy to use as it only accepts Form 4. We can obtain the exact same results as the last example of transform! using the same call with traverse!. Let's change the Leaf symbol into L:\n\ntraverse!(mtg, node -> symbol!(node, :L), symbol = :Leaf)\n\nmtg\n\nA benefit of traverse! is it can be used with a do...end block notation for complex sets of instructions:\n\ntraverse!(mtg) do node\n    if isleaf(node)\n         println(node_id(node),\" is a leaf\")\n    end\nend","category":"section"},{"location":"tutorials/3.transform_mtg/#Mutate-an-MTG","page":"Transform an MTG","title":"Mutate an MTG","text":"For users coming from R, we also provide the @mutate_mtg! macro that is similar to transform! but uses a more tidyverse-alike syntax. All values coming from the MTG node must be preceded by a node., as with the .data$ in the tidyverse. The names of the attributes are shortened to just node.attr_name instead of node_attributes(node).attr_name though. Here's an example usage:\n\n@mutate_mtg!(mtg, volume = π * 2 * node.Length, symbol = :I)\n\nWe see that we first name the new attribute and assign the result of the computation. Constants are provided as is, and values coming from the nodes are prefixes by node..","category":"section"},{"location":"tutorials/3.transform_mtg/#Helpers","page":"Transform an MTG","title":"Helpers","text":"You can use helper functions provided by MultiScaleTreeGraph.jl for:\n\nFiltering nodes: isroot, isleaf\nCompute the number of leaf nodes in the subtree of a node: nleaves\nApply the pipe_model! to the MTG to compute the cross-section of all nodes based on an initial cross-section.\n\nThe pipe model is used in plant physiology (especially on trees) and is built around the coarse hypothesis that each leaf in a plant is (to some extent) connected to the roots via a \"pipe\" of constant cross-sectional area. The concepts of the pipe model are detailed in Lehnebach et al. (2018).\n\nThis package provides an implementation of the pipe model, used as follows:\n\nfirst_cross_section = 0.34 # the initial cross-section of the plant\n\ntransform!(mtg, (node -> pipe_model!(node, first_cross_section)) => :cross_section_pipe)\ndescendants(mtg, :cross_section_pipe)\n\nFor more information about the implementation, you can check the documentation of the function: pipe_model!.","category":"section"},{"location":"tutorials/3.transform_mtg/#References","page":"Transform an MTG","title":"References","text":"R. Lehnebach, R. Beyer, V. Letort, et P. Heuret, « The pipe model theory half a century on: a review », Annals of Botany, vol. 121, nᵒ 5, p. 773‑795, avr. 2018, doi: 10.1093/aob/mcx194.","category":"section"},{"location":"get_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"get_started/#Introduction","page":"Getting started","title":"Introduction","text":"This page let's you take a peek at what the package is capable of. If you want a better, more in-depth introduction to the package, take a look at the tutorials, starting from Read and Write MTGs. If you don't know what an MTG is, you can read more about starting from The MTG concept.","category":"section"},{"location":"get_started/#Installation","page":"Getting started","title":"Installation","text":"You must have a working Julia installation on your computer. The version of Julia should be greater than 1.3.\n\nIf you want to install Julia for the first time, you can download it frome julialang.org. If you want a little introduction on Julia + VSCode, you can check out this video.\n\nYou can install the latest stable version of MultiScaleTreeGraph.jl using this command:\n\n]add MultiScaleTreeGraph\n\nnote: Note\nThe ] is used to enter the package mode in the REPL.","category":"section"},{"location":"get_started/#Example","page":"Getting started","title":"Example","text":"Read a simple MTG file:\n\nusing MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nThen you can compute new variables in the MTG using transform!:\n\ntransform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 1000.) => :length_mm)\n\nThe design of transform! is heavily inspired from the eponym function from tabular workflows (notably DataFrames.jl), with little tweaks for MTGs.\n\nYou can see the newly-computed attributes using descendants like so:\n\ndescendants(mtg, :length_mm)\n\nOr by getting a tabular view of your MTG:\n\nto_table(mtg)\n\nYou can also select only a subset of attributes:\n\nto_table(mtg, vars=[:Length, :Width])\n\nOr directly transforming the MTG into a DataFrame:\n\nusing DataFrames\nDataFrame(mtg)\n\nThen you can write the MTG back to disk like so:\n\nwrite_mtg(\"test.mtg\",mtg)\n\nYou can also convert your MTG to a MetaGraph:\n\nMetaGraph(mtg)","category":"section"},{"location":"tutorials/1.manipulate_node/#Accessing-node-data","page":"Accessing node data","title":"Accessing node data","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/#Read-an-MTG-file","page":"Accessing node data","title":"Read an MTG file","text":"Let's first read a simple MTG file:\n\nusing MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnode: Node\nIf you print a node, it will always print its subtree. So if we print the root node it will print the entire MTG.\n\nread_mtg returns a Node object.\n\ntypeof(mtg)\n\nThis node is the root node of the MTG, meaning the first node of the MTG, the one without any parent.\n\nnote: Note\nRoot node and leaf node mean a node without any parent or children respectively. You can think of this like a family tree: the root is the first ancestor, and leaves are the endpoints.","category":"section"},{"location":"tutorials/1.manipulate_node/#The-Node-type","page":"Accessing node data","title":"The Node type","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/#What's-a-node?","page":"Accessing node data","title":"What's a node?","text":"As we learned in the previous section, the node is the basic building block of an MTG. In practice, it is just an object that stores information in named fields. See the MTG implementation section for more details.","category":"section"},{"location":"tutorials/1.manipulate_node/#Access-the-fields-of-a-node","page":"Accessing node data","title":"Access the fields of a node","text":"The first node of the whole MTG is all we need to access every other nodes in the MTG, because they are all linked together.\n\nYou can list the fields in a node like so:\n\nfieldnames(typeof(mtg))\n\nThese fields are considered internal to the package, and are not meant to be accessed directly like so. In any case, you can still access them using the getfield function, e.g.:\n\ngetfield(mtg, :MTG)\n\nBut the preferred way for accessing such values is to use the accessor functions provided by the package: parent, children, attribute, attributes, node_mtg, node_id.\n\nSo to get the values of the attributes (i.e. the variables), you can use:\n\nattributes(mtg, format=:dict)\n\nThe MTG field from the node helps us describe the node within the MTG. Let's see what's in it:\n\nnode_mtg(mtg) |> typeof |> fieldnames\n\nWe see that it holds the MTG fields: the scale, symbol, index and link to its parent.\n\nThe package also provide helper functions to access the MTG encoding of the node directly: symbol, scale, index and link.","category":"section"},{"location":"tutorials/1.manipulate_node/#Update-the-node","page":"Accessing node data","title":"Update the node","text":"Similarly, we can update the fields of a node using the setting functions provided by the package: reparent!, rechildren!. \n\nThe package also provides updating functions for the MTG encoding of the node directly: symbol!, scale!, index! and link!.\n\nnote: Note\nThere is no setting function for the attributes or the node id because they are not meant to be updated directly. The attribute structure shouldn't change, only its content should (see next paragraph). The node id is unique in the MTG, so it should never change.","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-other-nodes","page":"Accessing node data","title":"Get other nodes","text":"We can move from node to node in the MTG graph because we know every node parent and children. ","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-children-nodes","page":"Accessing node data","title":"Get children nodes","text":"To get the children of a node, you can use the children function:\n\nchildren(mtg)\n\nYou can also also index the node using an integer, and it will return the corresponding child (1 for the first child, 2 for the second, etc.):\n\nmtg[1]\n\nWe can iteratively index into the nodes to access the descendants of a node. For example if we need to access the 6th node (the 2nd Internode), we would do:\n\nnode_6 = mtg[1][1][1][2]","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-the-parent-node","page":"Accessing node data","title":"Get the parent node","text":"To get the parent you can use:\n\nparent(mtg)\n\nNote that it returns nothing here because the root node has no parent.","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-the-node-siblings","page":"Accessing node data","title":"Get the node siblings","text":"To get the node siblings:\n\nsiblings(mtg[1][1][1][1])\n\nnote: Note\nWe repeatedly index into the MTG (mtg[1][1][1][1]) to get the fourth generation descendant of the root node, because it is the only one with a sibling in our example MTG.","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-any-node","page":"Accessing node data","title":"Get any node","text":"To get any node in the MTG, you can get it by its id:\n\nget_node(mtg, 3)\n\nYou can list all node ids using list_nodes:\n\nlist_nodes(mtg)","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-the-root-node","page":"Accessing node data","title":"Get the root node","text":"To get the root node from any other node, simply use get_root:\n\nnode_5 = get_node(mtg, 5)\n\nget_root(node_5)","category":"section"},{"location":"tutorials/1.manipulate_node/#Get-the-attributes","page":"Accessing node data","title":"Get the attributes","text":"This section has its own tutorial! Head over the next page to learn how to get the nodes attributes.","category":"section"},{"location":"tutorials/1.manipulate_node/#Columnar-Attribute-Backend","page":"Accessing node data","title":"Columnar Attribute Backend","text":"By default, read_mtg now loads attributes using a typed columnar backend (per symbol). The node API remains simple:\n\nleaf = get_node(mtg, 5)\nattribute(leaf, :Width)\nattribute!(leaf, :new_var, 1.0)\nattribute_names(leaf)\nattributes(leaf, format=:namedtuple)\n\nFor schema-level operations on one symbol:\n\nadd_column!(mtg, :Leaf, :temperature, Float64, default=20.0)\nrename_column!(mtg, :Leaf, :temperature, :temp)\ndrop_column!(mtg, :Leaf, :temp)\n\nnode_attributes(node) is still available for compatibility, but new code should prefer attribute/attribute!/attributes.","category":"section"},{"location":"the_mtg/our_implementation/#MTG-implementation","page":"Our implementation","title":"MTG implementation","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Introduction","page":"Our implementation","title":"Introduction","text":"In this package, the MTG is represented as a tree (nodes linked by parent/children relationships).\n\nThe tree is built from nodes. Each node stores:\n\nhow it is connected to other nodes (its topology)\nits own measured or computed attributes\n\nnote: Note\nThe package use terms from computer science rather than plant biology. So we use words such as \"root\" in an MTG, which is not the plant root, but the first node in the tree, i.e. the one without any parent. Similarly a leaf node is not a leaf from a plant but a node without any children.","category":"section"},{"location":"the_mtg/our_implementation/#Data-types","page":"Our implementation","title":"Data types","text":"The nodes have their own data type called Node. A Node has several fields:\n\nfieldnames(Node)\n\nHere is a simple description of each field:\n\nid: The unique integer identifier of the node. It can be set by the user but is usually set automatically.\nparent: The parent node of the curent node. If the curent node is the root node, it will return nothing. You can test whether a node is a root node sing the isroot function.\nchildren: the child nodes.\nMTG: The MTG encoding of the node (see below, or NodeMTG)\nattributes: node values (for example length, diameter, color, 3D position).\ntraversal_cache: saved traversal results used to speed up repeated operations.\n\nThe values of these fields are accessed with helper functions such as node_id, parent, children, node_mtg, and node_attributes.\n\nThe MTG field of a node describes how the node is positioned in the graph: link with parent (/, <, +), symbol, index, and scale (see Node MTG and attributes and The MTG section for more details). It is stored as NodeMTG or MutableNodeMTG. These types have four fields:\n\nfieldnames(NodeMTG)\n\nCreating a NodeMTG is simple: pass the four values in order. For example, an Axis that decomposes its parent (\"/\"), with index 0 and scale 1:\n\naxis_mtg_encoding = NodeMTG(\"/\", \"Axis\", 0, 1)\n\nThen we can access data using dot syntax:\n\naxis_mtg_encoding.symbol\n\nnote: Note\nNodeMTG is immutable (cannot be changed after creation).   MutableNodeMTG can be changed.   Use mutable if you plan to edit node topology fields.","category":"section"},{"location":"the_mtg/our_implementation/#Learning-by-example","page":"Our implementation","title":"Learning by example","text":"Let's print again the example MTG from the previous section:\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))\n\nWe can use read_mtg from MultiScaleTreeGraph.jl to read this MTG:\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nread_mtg returns the first node of the MTG, of type Node:\n\ntypeof(mtg)\n\nnote: Note\ntypeof(mtg) shows extra type details (including MTG encoding type and attribute container type). You usually do not need to worry about these details to use the package.\n\nWe can access the fields of the node using the accessor functions:\n\nnode_id(mtg)\n\nparent(mtg)\n\nThis one returns nothing because the node is the root node, it has no parent, but we could use it on its child, and it would return the root again:\n\nmtg_child = mtg[1]\nparent(mtg_child) == mtg\n\nchildren(mtg)\n\nnode_mtg(mtg)\n\nnode_attributes(mtg)\n\nThe package also provide helper functions to access the MTG encoding of the node directly:\n\nsymbol(mtg)\n\nindex(mtg)\n\nscale(mtg)","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Node-attributes","page":"Node attributes","title":"Node attributes","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Get-attributes-of-a-node","page":"Node attributes","title":"Get attributes of a node","text":"Let's first read our example MTG:\n\nusing MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nYou can get all the attributes of a node using the node_attributes function:\n\nnode_attributes(mtg)\n\nnote: Note\nThe attributes of the root node always include the data from the header sections of an MTG file: the scales of the MTG, the description and the symbols. You can learn more in The MTG sections.\n\nWe can also access particular attribute values by indexing into the node with a Symbol:\n\nnode_5 = get_node(mtg, 5) # Get the 5th node of the MTG\n\nnode_5[:Length]\n\n... or a String:\n\nnode_5[\"Length\"]\n\nAnd even with the dot notation:\n\nnode_5.Length\n\nThis one even has autocompletion! It means that you can type node_5. and then press TAB to see all the available attributes, and when you start typing the name of an attribute, it will suggest the completion of the name.\n\nThe previous notations are both equivalent to:\n\nnode_attributes(node_5)[:Length]\n\nnode_attributes(node_5) returns the node attribute container view for this node (columnar backend by default), so reading and writing through it does update the MTG.\n\nHowever, we still recommend the higher-level APIs (node[:attr], attribute(node, :attr), and attribute!(node, :attr, value)) because they are clearer and keep user code backend-agnostic.\n\nThat is why the package implements the more generic node_5[:Length] notation that works with any structure used for the attributes, which helps develop more generic code.\n\nTo get the names of all attributes available in the node subtree, you can use get_attributes:\n\nget_attributes(node_5)\n\nWe also define an alias for a more DataFrame.jl-alike experience (names):\n\nnames(node_5)\n\nNote that it returns only two attributes here because \"node_5\" is a leaf (a node without children), and get_attributes and names only return the attributes present in the node's subtree. To be sure to get all the attributes available in the whole MTG, it is better to call get_attributes on the root node like so:\n\nget_attributes(mtg)\n\nIf you start from another node you can retrieve the root node using get_root:\n\nget_attributes(get_root(node_5))\n\nA simple way to get all nodes and their attributes is to use the unified table view:\n\nto_table(mtg)","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Descendants","page":"Node attributes","title":"Descendants","text":"An MTG can hold a lot of information, usually measured locally at one given scale. It is often interesting to compute new attributes based on the topological environment of the nodes.\n\nFor example one could be interested in computing the total length of all nodes in a plant. To do so we must get the attributes of all descendants of a node. This is quite easy to do using MultiScaleTreeGraph.jl. For example to get the length attributes we would do:\n\ndescendants(mtg, :Length)\n\nThe descendants function visits each child, then each child of each child, and so on until leaves. It returns values in the same order as nodes are visited.\n\nThe function can also help get the nodes directly if we don't pass any attribute:\n\ndescendants(mtg)\n\nThis is useful to get more information about the nodes, like their scale, symbol, index, or link to their parent. Of course you can still get their attributes using the node_attributes function, e.g.:\n\nnode_attributes.(descendants(mtg))","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Ancestors","page":"Node attributes","title":"Ancestors","text":"To get the values of an attribute from the ancestors of a node, we would similarly do:\n\nnode_5 = get_node(mtg, 5)\nancestors(node_5, :Length)","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Filters","page":"Node attributes","title":"Filters","text":"Sometimes we only want the values of descendants or ancestors based on a given information. It is possible to filter out nodes based on their scale, symbol, link, or really anything by using the keyword arguments.","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-scale","page":"Node attributes","title":"Filter by scale","text":"For example if we want the length of all descendants of the root node of our MTG that are of scale 3 (leaves & internodes), we would simply do:\n\ndescendants(mtg, :Length, scale = 3)","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-symbol","page":"Node attributes","title":"Filter by symbol","text":"If we need only the leaves, we would filter by their symbol (i.e. :Leaf):\n\ndescendants(mtg, :Length, symbol = :Leaf)","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-anything","page":"Node attributes","title":"Filter by anything","text":"And if we want to filter depending on an arbitrary value, we can use the filter_fun argument. For example if we want the length of the nodes, but only the ones with a width greater than 1, will would do like so:\n\ndescendants(mtg, :Length, filter_fun = x -> x[:Width] === nothing ? false : x[:Width] > 1)\n\nwarning: Warning\nBy default if a node does not have an attribute, trying to get its value returns nothing. So if one uses attributes in the function passed to filter_fun, the function must handle missing values. This is what we do here by first testing if x[:Width] is nothing (in which case we return false to filter out the node), and then apply our test on the value of the node width.\n\nnote: Note\nThe function passed to filter_fun must take a node as input, not attributes directly. This is because we want to be able to access any information the user could need.\n\nBecause filter_fun takes a node as input, we can even filter on the node's parent. Let's say for example we want the values for the :Length, but only for the nodes that are children of a an Internode that follows another node:\n\ndescendants(mtg, :Length, filter_fun = node -> !isroot(node) && symbol(parent(node)) == :Internode && link(parent(node)) == :<)\n\nIn this example it returns only one value, because there is only one node that corresponds to this criteria: The Leaf with id 7.\n\nWe could apply the same kind of filtering on the node's children, or any combination of topological information and attributes.\n\nNote that we first test if the node is not the root node, because the root node does not have a parent. We then test if the parent's symbol is :Internode and if the link is :<.","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-helpers","page":"Node attributes","title":"Filter helpers","text":"There are three other arguments to help filtering nodes.\n\nThe first one is all. It is used to stop the search for new nodes as soon as one node does not correspond to the filters the user asked for.\n\nIt is generally used to get all nodes that have a \"follow\" link (\"<\") with their parents for example. You can find an example usage here, where we compute the index of the segment nodes (\"S\") along an axis (\"A\"), except for branching nodes, i.e. only the nodes that either decompose (\"/\") or follow (\"<\").\n\nThe second one is the self argument. It is used to return the value of the node on which we call the function if its true, and only the ancestors / descendants if false (the default).\n\nThe third one is the recursivity_level, that is used to control the depth of the search for the  ancestors / descendants. It is set to -1 by default, which does not apply any filter on the depth. It is generally used to get e.g. only the children values of a node (recursivity_level = 1).\n\nThe fourth one is ignore_nothing. It is used to not return the values of a node if it is nothing. Note that it is applied after the filter, so filter_fun still has to handle nothing values.","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Transform-values","page":"Node attributes","title":"Transform values","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Assign-attributes-to-a-node","page":"Node attributes","title":"Assign attributes to a node","text":"It is possible to change the values of attributes in a node. For example one could be interested to compute the total length of all nodes for the scene in our example MTG. In this case we can do:\n\nmtg[:Length] = sum(descendants(mtg, :Length, ignore_nothing = true))","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Compute-attributes-in-an-MTG","page":"Node attributes","title":"Compute attributes in an MTG","text":"Now MTGs can be very large, and it quickly becomes cumbersome to manually visit each node to change its value.\n\nInstead, you can compute new attributes for all nodes in an MTG using transform. Head to the next tutorial for more information: Transform an MTG.","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Helpers","page":"Node attributes","title":"Helpers","text":"Some helper functions can be useful when filtering nodes. For example you can use isroot to test if a node is the root node of the MTG. This is particularly useful when searching for ancestor values, but need a special treatment for the root node.\n\nSimilarly, you can use isleaf to filter the leaf nodes of an MTG.\n\nYou also have nleaves to compute the number of leaf nodes on the sub-tree of a given node.","category":"section"},{"location":"#MultiScaleTreeGraph.jl","page":"Home","title":"MultiScaleTreeGraph.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)\n\nDocumentation for MultiScaleTreeGraph.jl.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"The goal of MultiScaleTreeGraph.jl is to read, write, analyse and plot MTG (Multi-scale Tree Graph) files.\n\nThe Multi-Scale Tree Graph (MTG) is a format used to describe plant structure (topology) and associated attributes (e.g. geometry, colours, state). It was developed in the AMAP lab in the 90's to provide a generic and scalable way to represent plant topology and measurements.\n\nThe format is described in details in the original paper from Godin et Caraglio (1998).\n\nThe MTG format helps describe the plant at different scales at the same time. For example we can describe a plant at the scale of the organ (e.g. leaf, internode), the scale of a growth unit, the scale of the axis, the crown or even at the whole plant.\n\nYou can find out how to use the package on the Getting started section, or more about the MTG format in the The MTG concept.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Godin, C., et Y. Caraglio. 1998. « A Multiscale Model of Plant Topological Structures ». Journal of Theoretical Biology 191 (1): 1‑46. https://doi.org/10.1006/jtbi.1997.0561.","category":"section"}]
}
