var documenterSearchIndex = {"docs":
[{"location":"tutorials/2.transform_mtg/#Transform-an-MTG","page":"Transform an MTG","title":"Transform an MTG","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"-","title":"-","text":"newname(mtg) maxname(mtg)","category":"page"},{"location":"the_mtg/mtg_format/#The-.mtg-file-format","page":"File format","title":"The .mtg file format","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The .mtg file format was developed in the AMAP lab to be able to describe a plant in the MTG format directly in a file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The file format is generally used when measuring a plant on the field or to write on disk the results of an architectural model such as AMAPSim or VPalm for example. This format helps exchange and archive data about plants in a standard and efficient way.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The format is described in details in the original paper from Godin et al. (1997), but our implementation in Julia is detailed in this section.","category":"page"},{"location":"the_mtg/mtg_format/#Example-MTG","page":"File format","title":"Example MTG","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's define a very simple virtual plant composed of only two internodes and two leaves:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"<div class=\"sketchfab-embed-wrapper\">\n<iframe title=\"A 3D model\" width=\"640\" height=\"480\" src=\"https://sketchfab.com/models/2a699871f6f6459faa11c206bf81ae9a/embed?autospin=0.2&amp;autostart=1&amp;preload=1&amp;ui_controls=1&amp;ui_infos=1&amp;ui_inspector=1&amp;ui_stop=1&amp;ui_watermark=1&amp;ui_watermark_link=1\" frameborder=\"0\" allow=\"autoplay; fullscreen; vr\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n<p style=\"font-size: 13px; font-weight: normal; margin: 5px; color: #4A4A4A;\">\n<a href=\"https://sketchfab.com/3d-models/a-simple-3d-plant-2a699871f6f6459faa11c206bf81ae9a?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">A simple 3D plant</a>\nby <a href=\"https://sketchfab.com/rvezy?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">rvezy</a>\non <a href=\"https://sketchfab.com?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">Sketchfab</a>\n</p>\n</div>","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The corresponding MTG file is provided with this package. Let's print it using Julia's built-in read method:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This is a consequent file for such a tiny plant! This is because MTG files have a header with several sections before the MTG of the plant itself, which only appears after the MTG: line.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's dig into the information we have here.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-sections","page":"File format","title":"The MTG sections","text":"","category":"section"},{"location":"the_mtg/mtg_format/#Introduction","page":"File format","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"An MTG file is divided into five sections. These sections are defined by a keyword and a colon. The content of each section appears on a new line right after the keyword. A section can appear right after the content of the previous section, or they can be separated by blank lines. In fact, all blank lines are ignored in an MTG file.","category":"page"},{"location":"the_mtg/mtg_format/#The-CODE-section","page":"File format","title":"The CODE section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first section of an MTG file is the CODE section. It must appear first in the file as it is used to determine which version of the format specification the MTG file is following. The standard format in 2021 is the FORM-A specification.","category":"page"},{"location":"the_mtg/mtg_format/#The-CLASSES-section","page":"File format","title":"The CLASSES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The CLASSES section lists all symbols used in the MTG, and associates the scale of each symbol.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The data is presented as a table with five columns:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"SYMBOL: the string used for the node symbol.\nSCALE: the scale of the symbol, meaning all nodes with the given symbol will have this scale.\nDECOMPOSITION: This is not used anymore\nINDEXATION: This is not used anymore\nDEFINITION: This is not used anymore","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first row of the table is reserved and shouldn't be updated. It is a standard to use the dollar sign as the symbol for the scene, i.e. the node with the higher scale that encompass all MTGs. This node is usually not used in an MTG because MTG files mostly describe just a single plant (or a part of), not a whole scene.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThe symbol must be a character string without any numbers at the end, because the index of a node is read as the numbers at the end of a node name, so if a node symbol ends with a number, it will be parsed as an index. For example a symbol written Axis1 with index 1 will give Axis11 in the MTG, which will be parsed as Axis for the symbol and 11 for the index. Numbers are allowed inside the symbol though, e.g. Ax1s is allowed.","category":"page"},{"location":"the_mtg/mtg_format/#The-DESCRIPTION-section","page":"File format","title":"The DESCRIPTION section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The DESCRIPTION section is a table with four columns, and it defines a set of topological rules the MTG nodes of a same scale must follow. The rules are completely optional, but the header of the section is mandatory. In other words, the table can be empty.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The LEFT column designates the symbol of a parent node, the RIGHT column the symbol of a child node, the RELTYPE column the type of links allowed between the two, and MAX the maximum number of times these types of connexions are allowed in the MTG. The user can use a question mark to denote no maximum.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nThe rules only apply between symbols sharing the same scale (e.g. a node with itself, or in our example, the Internode with a Leaf).","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"These rules are mainly used to check the integrity of an MTG that has been written by hand on the field.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the rules yet. You can let this section empty (with the header) for your mtg if you don't plan to read it with other tools than MultiScaleTreeGraph.jl.","category":"page"},{"location":"the_mtg/mtg_format/#The-FEATURES-section","page":"File format","title":"The FEATURES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is a table with two columns that define the name of the attributes (or features) that can be attached to nodes, and the type of these attributes. This section makes sure that attributes are interpreted correctly when parsing the file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The NAME column is used to give the name of an attribute, and the TYPE column its type. The type can be:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"REAL for real numbers, e.g. 0.1\nINT for integer numbers, e.g. 1\nSTRING for strings, e.g. broken\nALPHA for reserved keywords:\nNbEl: NumBer of ELements, the number of children at the next scale\nLength: the node length\nBottomDiameter, the bottom tapering applied to the node for computing its geometry\nTopDiameter, the tapering applied at the top\nState, defines the state of a node. It can take the value D (Dead), A (Alive), B (Broken) , P (Pruned), G (Growing), V (Vegetative), R (Resting), C (Completed), M (Modified), or any combination of these given letters.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the State of a node, and does not make use of the reserved keywords.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-section","page":"File format","title":"The MTG section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is the actual MTG. It describes the topology of the plant, and give the possibility to add attributes to them.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The MTG is encoded as a table with tabulation separated values. The header of this section defines the columns used for describing the topology and the ones used for the attributes. The first column name is reserved and must be named ENTITY-CODE. Then, a set of empty column names (i.e. just tabulations) that defines how many columns are used for the topology. Finally, the following columns are used to define the attributes of the nodes. Their names must match the ones given in The FEATURES section.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Each row of the table usually refers to a single node. The topology is and node description is given in the ENTITY-CODE columns.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"In our example MTG, the first node is the scene: /Scene0. In this package, this notation is called a NodeMTG. It is made out of three different information:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent node: /\nThe node Symbol: Scene\nThe node index: 0","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent can be either / (decomposition), < (following) or + (branching). you can read the Node MTG and attributes section for more details on the signification of each. In few words, a node decomposes its parent if it changes the scale of description, follows if it is continuing after its parent, or branching if it branches from its parent.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node symbol is used to determine the scale of the node and eventually its properties.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node index is completely free. It is mainly used to keep track of the number of following segments on an axis, or the branching order.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The second node in our example is ^/Individual0. It introduces a new character used as prefix: ^. This character is used to tell us the parent of the current node is the last node in the same column. If this character is absent, then the parent of the node is the last node found on the column before.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"We can find such example in the 5th row of the table where a leaf is declared like so: +Leaf0. The missing ^ tells us that the parent of this node is the one found on the column before, which is ^/Internode0.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nBecause there is no explicit need to change column when nodes are decomposing or following, we usually create a new column only when a node branches to reduce the number of columns in the ENTITY-CODE.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Attributes are then declared in their respective columns defined in the header. If there is no value for an attribute, it is usually declared as an empty column","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nMTGs entered manually on the field are usually done in a spreadsheet software such as MS Excel or Only Office / Open Office / Libre Office Calc. Here is an example spreadsheet used on the field. We have one with a Macro too. Just sent us an email to get one.","category":"page"},{"location":"tutorials/0.read_write/#Read-and-Write-MTGs","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/#Read","page":"Read and Write MTGs","title":"Read","text":"","category":"section"},{"location":"tutorials/0.read_write/#Reading-a-file","page":"Read and Write MTGs","title":"Reading a file","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Reading an MTG is done using the read_mtg function:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\n\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The file given in input can be either a .mtg, .csv, .xlsx or .xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Options","page":"Read and Write MTGs","title":"Options","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The function has two optional arguments to set the type used for the attributes, and the type used for the MTG field (see next section for more details). It also has a keyword argument to choose the sheet name in case you're reading an xlsx or xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Attributes-type","page":"Read and Write MTGs","title":"Attributes type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The type used for the attributes should be a NamedTuple-alike or a Dict-alike type. Here is a more in-depth recommendation, use:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"NamedTuple if you don't plan to modify the attributes of the MTG, e.g. to use them for plotting or computing statistics...\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes very often, e.g. recompute an attribute value...\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g. adding/removing attributes a lot","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nIf you don't know what to use, just use the default.","category":"page"},{"location":"tutorials/0.read_write/#MTG-encoding-type","page":"Read and Write MTGs","title":"MTG encoding type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The MTG encoding type can be either immutable or mutable. By default we use a mutable one (MutableNodeMTG), but you can use the immutable one by setting the mtg_type argument of the function to NodeMTG. If you're planning on modifying the MTG encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nAgain, if you don't know what to use, use the default.","category":"page"},{"location":"tutorials/0.read_write/#Sheet-name","page":"Read and Write MTGs","title":"Sheet name","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you're reading your MTG from a .xlsx or .xlsm file, you can choose the sheet you want to read by using the keyword argument sheet_name.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you don't provide anything for the sheet name, it will read the first one by default.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nKeyword arguments must be explicitly named in the function call. In this case it would be:file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file, sheet_name = \"A3H\")","category":"page"},{"location":"tutorials/0.read_write/#Write","page":"Read and Write MTGs","title":"Write","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Writing an MTG back to disk is as simple as this:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"temporary_file = tempname() # using a temporary file here, but you should put the path to the file you want to write\n\nwrite_mtg(temporary_file, mtg)","category":"page"},{"location":"api/#MultiScaleTreeGraph.jl-functions","page":"API","title":"MultiScaleTreeGraph.jl functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you'll be directed to the function help.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MultiScaleTreeGraph]","category":"page"},{"location":"api/#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T<:Union{Tuple, AbstractArray}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])\n\nConvert an MTG into a DataFrame.\n\nArguments\n\nmtg::Node: An mtg node (usually the root node).\nkey: The key, or attribute name. Used to list the variables that must be added to the\n\nDataFrame. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nDataFrame(mtg, :Length)\nDataFrame(mtg, [:Length, :Width])\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.MetaGraph-Tuple{Node}","page":"API","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g::Node)\n\nConvert an MTG into a MetaGraph.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nMetaGraph(mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.MutableNodeMTG","page":"API","title":"MultiScaleTreeGraph.MutableNodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.Node","page":"API","title":"MultiScaleTreeGraph.Node","text":"Type that defines an MTG node (i.e. an element) with the name of the node, its parent, children, siblings, MTG encoding (see NodeMTG or MutableNodeMTG) and attributes.\n\nThe node is an entry point to a Mutli-Scale Tree Graph, meaning we can move through the MTG from any of its node. The root node is the node without parent. A leaf node is a node without any children. Root and leaf nodes are used with their computer science meaning throughout the package, not in the biological sense.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.NodeMTG","page":"API","title":"MultiScaleTreeGraph.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"API","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Any}","page":"API","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Integer}","page":"API","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Node}","page":"API","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.print-Tuple{Node}","page":"API","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.transform!-Tuple{Node, Vararg{Any, N} where N}","page":"API","title":"DataFrames.transform!","text":"transform!(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\n\nReturns\n\nNothing, mutates the (sub-)tree in-place.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function or [:var_name1, :var_name2] => function pair. The variables\n\nare declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.\n\na :var_name => function => :new_var_name form that does the same as the previous form\n\nbut explicitly naming the resulting variable.\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 and 3 expect a function that uses one or more node attributes (== variables) as inputs, while form 4 and 5 expect a function that uses a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_features`](@ref) to know the new variable name:\nget_features(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)))\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle well those, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# The solution is to handle these cases in our own functions instead:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length)\ndescendants(mtg, :log_length, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finnaly, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M<:AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.addchild!","text":"Add a new child to a parent node, and add the parent node as the parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\nignore_nothing = false: ignore nothing values\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = mtg.children[\"node_2\"].children[\"node_3\"].children[\"node_4\"].children[\"node_5\"]\n\nancestors(leaf_node, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\nancestors(leaf_node, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1, type = Float64)\nancestors(leaf_node, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = \"Internode\")\nancestors(leaf_node, :Length, symbol = (\"Axis\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.branching_order!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.branching_order!","text":"branching_order!(mtg; ascend = true)\n\nCompute the topological branching order of the nodes in an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nNotes\n\nThe order of a node is computed from the maximum order of their children when using the basipetal computation.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nbranching_order!(mtg)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\nbranching_order!(mtg, ascend = false)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.check_filters-Union{Tuple{Any}, Tuple{T}} where T","page":"API","title":"MultiScaleTreeGraph.check_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = \"Leaf\", link = \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.children-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.children","text":"children(node::Node)\n\nReturn the immediate children of node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.clean_cache!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.coordinates!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.coordinates!","text":"coordinates!(mtg; angle = 45; force = false)\n\nCompute dummy 3d coordinates for the mtg nodes using an alterning phyllotaxy. Used when coordinates are missing. Coordinates are just node attributes with reserved names: :XX, :YY and :ZZ.\n\nReturns\n\nNothing, mutates the mtg in-place (adds :XX, :YY and :ZZ to nodes).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncoordinates!(mtg)\nDataFrame(mtg, [:XX, :YY, :ZZ])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_node!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_node!","text":"delete_node!(node)\n\nDelete a node and re-parent the children to its own parent. If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, symbol = \"Leaf\")\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (\"Leaf\",\"Internode\"))\n\n# Make the mtg match field measurements made only at branching points for the scales 1 + 2:\nmtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.descendants","page":"API","title":"MultiScaleTreeGraph.descendants","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\nignore_nothing = false: ignore nothing values\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants!","page":"API","title":"MultiScaleTreeGraph.descendants!","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\nignore_nothing = false: ignore nothing values\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants_!-NTuple{11, Any}","page":"API","title":"MultiScaleTreeGraph.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MultiScaleTreeGraph.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.extend_pos-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.extend_pos","text":"Add a new point after (x1,y1) using same direction and length relative to it\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_classes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_description-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_features-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_features","text":"get_features(mtg)\n\nCompute the mtg features based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_leading_tabs-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_leading_tabs","text":"get_leading_tabs(node)\n\nGet the number of tabulation the node should have when writting it to a file based on the topology of its parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node-Tuple{Node, Any}","page":"API","title":"MultiScaleTreeGraph.get_node","text":"get_node(node::Node, name)\n\nGet a node in an mtg by name.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6 = get_node(mtg, \"node_6\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_printing-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_reference-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_reference","text":"get_reference(node)\n\nGet the preceding \"^\" keyword if needed, i.e. in case we refer to the parent node in the same mtg file column.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_root-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_root","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_node!-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.insert_node!","text":"insert_node!(node, template, max_id)\n\nInsert a node as the new parent of node.\n\nArguments\n\nnode::Node: The node at which to insert a node as a parent.\ntemplate::Node: A template node used as the inserted nodes.\nmax_id::Vector{Int64}: The maximum id of the mtg as a vector of 1 value, used to compute\n\nthe name of the inserted node. It is incremented in the function.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmax_id = parse(Int, MultiScaleTreeGraph.max_name(mtg)[6:end])\nmtg = insert_node!(mtg[1][1], template, max_id)\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.insert_nodes!","text":"insert_nodes!(mtg::Node,template,<keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note that it always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate::Node: A template node used for all inserted nodes.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\nwhere to insert.\n\nNotes\n\nThe nodes are always inserted before a filtered node because we can't decide if a new node would\n\nbe considered a new child or a new parent of the children otherwise.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ninserting nodes. So if you insert a branching node, the whole subtree will be branched.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"A1B1.mtg\")\nmtg = read_mtg(file)\n\nmtg = insert_nodes!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2) # Will insert new nodes before all scale 2\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.is_segment!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isleaf-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isroot-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.max_name-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.max_name","text":"max_name(mtg)\n\nReturns the maximum name of the mtg based on its index\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.mtg_coordinates_df-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.mtg_coordinates_df","text":"mtg_coordinates_df(mtg; force = false)\nmtg_coordinates_df!(mtg; force = false)\n\nExtract the coordinates of the nodes of the mtg and the coordinates of their parents (:XXfrom, :YYfrom, :ZZ_from) and output a DataFrame.\n\nThe coordinates are computed using coordinates! if missing, or if force = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_name-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.new_name","text":"new_name(mtg)\nnew_name(mtg,max_name)\n\nMake a new unique identifier by incrementing on the maximum name (names are names+index). Hint: prefer using max_name = max_name(mtg) and then new_name(mtg,max_name) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.nleaves","page":"API","title":"MultiScaleTreeGraph.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves!","page":"API","title":"MultiScaleTreeGraph.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}","page":"API","title":"MultiScaleTreeGraph.node_attributes","text":"Instantiate a attr_type struct with node_attr keys and values\n\nArguments\n\nattr_type::DataType: the type of the structure used to hold the attributes\nnode_attr::String: The node attributes as a Base.Dict\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ordered_children-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.ordered_children","text":"ordered_children(node)\n\nReturn the children as an array, ordered first by \"+\"\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nattr_type::DataType: the type of the structure used to hold the attributes\nfeatures::DataFrame: The features data.frame\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))\nMultiScaleTreeGraph.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}","page":"API","title":"MultiScaleTreeGraph.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MultiScaleTreeGraph.next_line!(f,line)\n\nwhile MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],\"CLASSES\")\n    l[1] = MultiScaleTreeGraph.next_line!(f,line)\nend\n\nclasses = MultiScaleTreeGraph.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.paste_mtg_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.paste_mtg_node","text":"paste_mtg_node(node)\n\nParse the mtg node as it should appear in the mtg file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, var_name, threshold_value; allow_missing = false)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (:var_name) is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nallow_missing=false: Allow missing values for var_name, in which case the cross-section is\n\nrecomputed using the pipe model. Please use this option only if you know why.\n\nDetails\n\nThe node cross-section is partitioned from parent to children according to the number of leaves (i.e. terminal nodes) each child bear, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves. If :var_name of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.\n\nWord of caution\n\nSome tips when using this function:\n\nUser must ensure that :var_name has a value for all nodes in the mtg before calling this\n\nversion of pipe_model!, unless allow_missing=true.\n\nNodes with untrusted values should be\n\nset to a value below the threshold value to make pipe_model! recompute them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, root_value)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation is as follows: the algorithm first checks how many children a node has. If it has one child only, the child cross-section is equal to the node cross-section. If more children, the node cross-section is shared between the children according to the number of leaves they bear, i.e. the total number of terminal nodes of their sub-tree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.read_mtg","page":"API","title":"MultiScaleTreeGraph.read_mtg","text":"read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG; sheet_name = nothing)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nsheet_name = nothing: the sheet name in case you're reading an xlsx or xlsm file. It\n\nreads the first sheet if nothing (default behavior).\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:\nmtg = read_mtg(file,Dict);\n\n# We can also read an mtg directly from an excel file from the field:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}","page":"API","title":"MultiScaleTreeGraph.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.name)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.name)\n\ntest = :(x = node.foo)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.attributes[:foo])\n\ntest = :(x = node.MTG.symbol)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.MTG.symbol)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.rotate_point-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.rotate_point","text":"Rotate a point (x1,y1) around (x0, y0) with angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.siblings-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\", r\"(?<=.)(?=[</+])\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.strip_comments","page":"API","title":"MultiScaleTreeGraph.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.traverse!","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\n\nReturns\n\nNothing for traverse! because it mutates the (sub-)tree in-place, or an Array of whatever the function returns for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}","page":"API","title":"MultiScaleTreeGraph.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"api/#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MultiScaleTreeGraph.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"the_mtg/mtg_concept/#The-MTG-concept","page":"Concept","title":"The MTG concept","text":"","category":"section"},{"location":"the_mtg/mtg_concept/#Introduction","page":"Concept","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The Multi-scale Tree Graph -or MTG for short- is a data structure for describing a tree-alike object at one or several scales.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Let's take a grass plant as an example:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 1. A Typical grass plant.[1]","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"This plant can be described at the individual scale, as a whole (Fig. 2a). At this scale, we see some attributes such as its species, its spatial coordinates, its height, and if we measure it, its total biomass, or leaf area.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Now if we get closer to the plant we see more details, for example we can now see the dominant axes of the plant (Fig. 2b). This is a new scale of description, let's say the axis scale. We can measure new attributes at this scale such as the biomass or total leaf area of each axis for example.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"If we get closer again, each axis can be described with more details, and we can now differentiate each phytomer (Fig. 2c), i.e. the compound of the leaf and the internode. This is a new scale again, and attributes can be associated to each metamer, for example its length, diameter, biomass, leaf area or volume.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 2. A grass plant described at three different scales: (a) the plant, (b) the axis and (c) the phytomer. The corresponding MTG graph (mono-scale) is shown on the right of each description.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Figure 2 shows a different graph for each scale used for the description, but we can join all scales into a single MTG instead. In the MTG, all scales live together in the same data structure. The elementary object is called a node. The nodes are denoted by the little circles in Figure 2. There is one node for the plant scale (Fig. 2a), two nodes for the axis because there are two tillers (Fig. 2b), and six nodes for the phytomers, one for each (Fig. 2c).","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The resulting MTG describing all scales at once in the same graph can be represented as follows:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: MTG of a grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 3. Multi-scale Tree Graph of a grass plant described at three different scales: the plant (P), the axis (A) and the phytomer (I).","category":"page"},{"location":"the_mtg/mtg_concept/#Node-MTG-and-attributes","page":"Concept","title":"Node MTG and attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Each node, represented as circles in Figure 2 & 3, is described by a set of informations. These informations include the node scale, its symbol and index, its parent and the type of connection -or link- they share, a list of children and some attributes.","category":"page"},{"location":"the_mtg/mtg_concept/#The-scale","page":"Concept","title":"The scale","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"We already talked about the node scale above, it is defined by an integer used to describe the level of description of the object. Usually the value of the scale is 0 for the first node, and increase going towards the finer descriptions. In our example MTG, the plant would be of scale 0, the axes of scale 1 and the phytomers of scale 2.","category":"page"},{"location":"the_mtg/mtg_concept/#The-symbol","page":"Concept","title":"The symbol","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The symbol is used as a name for the type of nodes used in the MTG. In our example MTG in Figure 2 & 3 we had the Plant, the Axis and the Phytomer. A symbol can be present at one scale only, but several symbols can be used in the same scale.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"For example we could add a finer scale of description to our example MTG: the organ scale. At this scale we would have at least three different types of organs: the leaf, the internode and the inflorescence. Each one would share the same scale (i.e. Organ -> scale 3), but would have a different name for their symbol.","category":"page"},{"location":"the_mtg/mtg_concept/#The-index","page":"Concept","title":"The index","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The index of a node is an integer with a completely free value. It is generally used by the user to e.g. keep track of the count of nodes or the branching order. In our example MTG, we incremented our phytomers one by one, but we could start our numbering for each axis for example, allowing us to keep track rapidly of how many phytomers there are in each axis.","category":"page"},{"location":"the_mtg/mtg_concept/#Links","page":"Concept","title":"Links","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Like any other tree graph, each node in an MTG keeps track of which node is its parent, and which are its children. One originality of the MTG is having the choice of using three different types of links between a node and its parent:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"decomposition (/): this link is used when the node decomposes its parent, meaning it has a different scale. For example in Figure 3 the first axis node (A1) decomposes the Plant node (P1).\nfollow (<): it is used when a node follows its parent node with the same scale. In Figure 3, the second phytomer (I3) of the first axis (A1) follows the first one (I1).\nbranch (+): the node branches from its parent. In Figure 3, the second axis (A2) branches from the first phytomer (A1) of the first axis (A1) of the plant.","category":"page"},{"location":"the_mtg/mtg_concept/#Attributes","page":"Concept","title":"Attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Attributes are used to attach data about a node. The MTG standard for the .mtg file format specifies that attributes can be of type a integer, real or character only. But in Julia it is also possible to use any type (e.g. a DataFrame, a user type...). As soon as you don't plan to write it to the disk it is completely fine.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"[1]: The SVG was made by Kelvin13 and found on Wikimedia.","category":"page"},{"location":"get_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"get_started/#Introduction","page":"Getting started","title":"Introduction","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"This page let's you take a peek at what the package is capable of. If you want a better, more in-depth introduction to the package, take a look at the tutorials, starting from Read and Write MTGs. If you don't know what an MTG is, you can read more about starting from The MTG concept.","category":"page"},{"location":"get_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can install the latest stable version of MultiScaleTreeGraph.jl using this command:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"]add MultiScaleTreeGraph","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"note: Note\nThe ] is used to enter the package mode in the REPL.","category":"page"},{"location":"get_started/#Example","page":"Getting started","title":"Example","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntransform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 100.) => :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Read a simple MTG file:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can compute new variables in the MTG using transform!:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"transform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 100.) => :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The design of transform! is heavily inspired from the eponym function from DataFrame.jl, with little tweaks for MTGs.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"If you prefer a more R-like design, you can use @mutate_mtg! instead:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"@mutate_mtg!(mtg, length_mm = node.Length * 100., filter_fun = x -> !isnothing(x[:Length]))","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can write the MTG back to disk like so:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"write_mtg(\"test.mtg\",mtg)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can also transform it into a DataFrame while selecting the variables you want:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"DataFrame(mtg, [:length_mm, :XX])","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Or convert it to a MetaGraph:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"MetaGraph(mtg)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Finally, we can plot the MTG using any backends from Plots, e.g. Plotly for the 3d:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using Plots\n# import Pkg; Pkg.add(\"PlotlyJS\")\nplotlyjs()\n\nplot(mtg, mode = \"3d\") # use mode = \"2d\" for a 2d plot\nsavefig(\"mtgplot3d.html\"); nothing # hide","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"<object type=\"text/html\" data=\"mtgplot3d.html\" style=\"width:100%;height:2100px;\"></object>","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"<object type=\"text/html\" data=\"mtgplot.html\" style=\"width:100%;height:2100px;\"></object>","category":"page"},{"location":"tutorials/1.manipulate_node/#Manipulate-nodes","page":"Manipulate nodes","title":"Manipulate nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/#Read-an-MTG-file","page":"Manipulate nodes","title":"Read an MTG file","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Let's first read a simple MTG file:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node: Node\nIf you print a node, it will always print its subtree. So if we print the root node it will print the entire MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"read_mtg returns a Node object.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"typeof(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"This node is the root node of the MTG, meaning the first node of the MTG, the one without any parent.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"note: Note\nRoot node and leaf node mean a node without any parent or children respectively. These terms are used in the sense of a tree data structure.","category":"page"},{"location":"tutorials/1.manipulate_node/#The-Node-type","page":"Manipulate nodes","title":"The Node type","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/#What's-a-node?","page":"Manipulate nodes","title":"What's a node?","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"As we learned in the previous section, the node is used as the elementary object to build the MTG. In this package, a node is a data structure used to hold these informations (i.e. fields):","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"name: the name of the node. It is usually generated when read from a file and unique in the MTG;\nparent: the parent node;\nchildren: a dictionary of the children nodes, or nothing if no children;\nsiblings: a dictionary of sibling(s) node(s) if any, or else nothing. Can be nothing if not computed too;\nMTG: the MTG encoding of the node (see below, or NodeMTG);\nattributes: the node attributes. Can be a NamedTuple, a MutableNamedTuple or a Dict or similar (e.g. OrderedDict). The choice of the data structure used depends on how much you plan to change the attributes and their values. Attributes include for example the length or diameter of a node, its colour, 3d position...","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-node's-fields","page":"Manipulate nodes","title":"Get the node's fields","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get a field of a node, you can use the dot notation, e.g.:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.attributes","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"The MTG field from the node helps us describe the node within the MTG. Let's see what's in it:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"fieldnames(typeof(mtg.MTG))","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"We see that it holds the MTG fields: the scale, symbol, index and link to its parent.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-other-nodes","page":"Manipulate nodes","title":"Get other nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"We can move in the MTG from node to node because we know its parents and children.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To do so, we use either the dot notation, or the corresponding functions.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-children-nodes","page":"Manipulate nodes","title":"Get children nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the children of a node, you can use either:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.children","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"or:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"children(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"You can also index the node using an integer, and it will return the corresponding child:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg[1]","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-parent-node","page":"Manipulate nodes","title":"Get the parent node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the parent you can use:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"mtg.parent","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Or:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"parent(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"Note that it returns nothing here because the root node has no parent.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-node-siblings","page":"Manipulate nodes","title":"Get the node siblings","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the node siblings:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"siblings(mtg[1][1][1][1])","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"note: Note\nWe repeatedly index into the MTG (mtg[1][1][1][1]) to get the fourth generation descendant of the root node, because it is the only one with a sibling in our example MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-any-node","page":"Manipulate nodes","title":"Get any node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get any node in the MTG, you can get it by its name:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"get_node(mtg, \"node_5\")","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-root-node","page":"Manipulate nodes","title":"Get the root node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"To get the root node from any other node, simply use get_root:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Manipulate nodes","title":"Manipulate nodes","text":"node_5 = get_node(mtg, \"node_5\")\n\nget_root(mtg, node_5)","category":"page"},{"location":"the_mtg/our_implementation/#MTG-implementation","page":"Our implementation","title":"MTG implementation","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Introduction","page":"Our implementation","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6 = get_node(mtg, \"node_6\")","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"In this package, the MTG is represented as a tree data structure.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The tree is built from a series of nodes with different fields that describe the topology (i.e. how nodes are connected together) and the attributes of the node.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe package use terms from computer science rather than plant biology. So we use words such as \"root\" in an MTG, which is not the plant root, but the first node in the tree, i.e. the one without any parent. Similarly a leaf node is not a leaf from a plant but a node without any children.","category":"page"},{"location":"the_mtg/our_implementation/#Data-types","page":"Our implementation","title":"Data types","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The nodes have their own data type called Node. A Node has several fields:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(Node)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Here is a little description of each field:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"name: The name of the node. It is completely free, but is usually computing automatically when reading the MTG. The automatic name is based on the index of the node in the MTG, e.g. \"node_1\" for the first node.\nparent: The parent node of the curent node. If the curent node is the root node, it will return nothing. You can test whether a node is a root node sing the isroot function.\nchildren: A dictionary with the children of the current node as values, and their name as keys.\nsiblings: A dictionary with the siblings of the current node as values, and their name as keys.\nMTG: The MTG description of the node (see below)\nattributes: the node attributes, usually of the form of a dictionary, but the type is optional (can be a vector, a tuple...).","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The MTG field of a node describes the topology of the node (see Node MTG and attributes and The MTG section for more details). It is a data structure called NodeMTG, which has four fields:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(NodeMTG)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"These fields correspond to the topology encoding of the node: the type of link with the parent node (decompose: /, follow: <, and branch: +), the symbol of the node, its index, and its description scale.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nNodeMTG is the immutable data type, meaning that information cannot be changed once read. By default the package the mutable equivalent called MutableNodeMTG. Accessing the information of a mutable data structure is slower, but it is more convenient if we need to change its values.","category":"page"},{"location":"the_mtg/our_implementation/#Learning-by-example","page":"Our implementation","title":"Learning by example","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Read-an-MTG","page":"Our implementation","title":"Read an MTG","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Let's print again the example MTG from the previous section:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can use read_mtg from MultiScaleTreeGraph.jl to read this MTG:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"read_mtg returns the first node of the MTG, of type Node","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"typeof(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe Node is a parametric type, that's why typeof(mtg) also returns the type used for the MTG data in the node (MutableNodeMTG) and the type used for the attributes (Dict{Symbol, Any}). But this is not important here.","category":"page"},{"location":"the_mtg/our_implementation/#Accessing-a-node","page":"Our implementation","title":"Accessing a node","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The first node of the whole MTG is all we need to access every other nodes in the MTG, because they are all linked together. For example we can access the data of its child either using its name:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.children[\"node_2\"]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or directly by indexing the node with an integer:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg[1]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can iteratively index into the nodes to access the descendants of a node. For example if we need to access the 6th node (the 2nd Internode), we would do:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6 = mtg[1][1][1][2]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or more simply, we can use the get_node function with the name of the node:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6 = get_node(mtg, \"node_6\")","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"To access the parent of a node, we would do:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6.parent","category":"page"},{"location":"the_mtg/our_implementation/#Accessing-node-data","page":"Our implementation","title":"Accessing node data","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can access the data of a node using the dot notation. For example to get its MTG data:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.MTG","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Or its attributes:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg.attributes","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe attributes of the root node always include the data from the header sections of an MTG file: the scales of the MTG, the description and the symbols. You can learn more in The MTG sections if you want.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can also access the attributes of a node by indexing the node with a Symbol:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6[:Length]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"... or a String:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6[\"Length\"]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Which are both equivalent to:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_6.attributes[:Length]","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"You'll find more information on how to make computations over the MTG, how to transform it into a DataFrame, how to write it back to disk, or how to delete and insert new nodes in the tutorials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiScaleTreeGraph","category":"page"},{"location":"#MultiScaleTreeGraph.jl","page":"Home","title":"MultiScaleTreeGraph.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultiScaleTreeGraph.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of MultiScaleTreeGraph.jl is to read, write, analyse and plot MTG (Multi-scale Tree Graph) files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Multi-Scale Tree Graph, or MTG, is a data structure used to encode a plant to describe its topology (i.e. structure) and any attributes (e.g. geometry, colours, state...). It was developed in the AMAP lab in the 90's to cope with the need of a generic yet scalable structure for plant topology and traits measurement, analysis and modelling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The format is described in details in the original paper from Godin et al. (1997).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MTG format helps describe the plant at different scales at the same time. For example we can describe a plant at the scale of the organ (e.g. leaf, internode), the scale of a growth unit, the scale of the axis, the crown or even at the whole plant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can find out how to use the package on the Getting started section, or more about the MTG format in the The MTG concept.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Godin, C., et Y. Caraglio. 1998. « A Multiscale Model of Plant Topological Structures ». Journal of Theoretical Biology 191 (1): 1‑46. https://doi.org/10.1006/jtbi.1997.0561.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Image: https://upload.wikimedia.org/wikipedia/commons/4/44/Grassygrassplant.svg","category":"page"}]
}
