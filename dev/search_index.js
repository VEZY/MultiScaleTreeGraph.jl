var documenterSearchIndex = {"docs":
[{"location":"get_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The Multi-Scale Tree Graph, or MTG, is a data structure used to encode a plant. It was developed in the AMAP lab in the 90's to cope with the need of a generic yet scalable structure for plant topology and traits measurement, analysis and modelling.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The format is described in details in the original paper from Godin et al. (1997).","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The MTG format helps describe the plant at different scales at the same time. For example we can describe a plant at the scale of the organ (e.g. leaf, internode), the scale of a growth unit, the scale of the axis, the crown or even just the plant.","category":"page"},{"location":"get_started/#References","page":"Getting started","title":"References","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Godin, C., et Y. Caraglio. 1998. « A Multiscale Model of Plant Topological Structures ». Journal of Theoretical Biology 191 (1): 1‑46. https://doi.org/10.1006/jtbi.1997.0561.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Plant svg original file from Kelvinsong — CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=27509689","category":"page"},{"location":"api/#MTG.jl-functions","page":"API","title":"MTG.jl functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is a list of all exported functions from MTG.jl. For more details, click on the link and you'll be directed to the function help.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MTG]","category":"page"},{"location":"api/#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T<:Union{Tuple, AbstractArray}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])\n\nConvert an MTG into a DataFrame.\n\nArguments\n\nmtg::Node: An mtg node (usually the root node).\nkey: The key, or attribute name. Used to list the variables that must be added to the\n\nDataFrame. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nDataFrame(mtg, :Length)\nDataFrame(mtg, [:Length, :Width])\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.AbstractNodeMTG","page":"API","title":"MTG.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MTG.NodeMTG","page":"API","title":"MTG.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#MetaGraphsNext.MetaGraph-Tuple{Node}","page":"API","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g::Node)\n\nConvert an MTG into a MetaGraph.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nMetaGraph(mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"API","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Any}","page":"API","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Integer}","page":"API","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Node}","page":"API","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.print-Tuple{Node}","page":"API","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.transform!-Tuple{Node, Vararg{Any, N} where N}","page":"API","title":"DataFrames.transform!","text":"transform!(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\n\nReturns\n\nNothing, mutates the (sub-)tree in-place.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl.\n\nThe args... provided can be of the two following forms:\n\na cols => function pair. The cols are declared as a Symbol or a String (or a vector of),\n\nand they are passed as positional arguments to the function. This form automatically generates the new column name by concatenating the source column name(s) and the function name if any.\n\na cols => function => target_col form explicitly specifying the name of teh target column.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_features`](@ref) to know the new variable name:\nget_features(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)))\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle well those, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# The solution is to handle these cases in our own functions instead:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length)\ndescendants(mtg, :log_length, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# Finally, we can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M<:AbstractNodeMTG","page":"API","title":"MTG.addchild!","text":"Add a new child to a parent node, and add the parent node as the parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.ancestors-Tuple{Any, Any}","page":"API","title":"MTG.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = mtg.children[\"node_2\"].children[\"node_3\"].children[\"node_4\"].children[\"node_5\"]\n\nancestors(leaf_node, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\nancestors(leaf_node, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1, type = Float64)\nancestors(leaf_node, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = \"Internode\")\nancestors(leaf_node, :Length, symbol = (\"Axis\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.branching_order!-Tuple{Any}","page":"API","title":"MTG.branching_order!","text":"branching_order!(mtg; ascend = true)\n\nCompute the topological branching order of the nodes in an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nNotes\n\nThe order of a node is computed from the maximum order of their children when using the basipetal computation.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nbranching_order!(mtg)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\nbranching_order!(mtg, ascend = false)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.check_filters-Union{Tuple{Any}, Tuple{T}} where T","page":"API","title":"MTG.check_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = \"Leaf\", link = \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.children-Tuple{Node}","page":"API","title":"MTG.children","text":"children(node::Node)\n\nReturn the immediate children of node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.clean_cache!-Tuple{Any}","page":"API","title":"MTG.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.delete_node!-Tuple{Any}","page":"API","title":"MTG.delete_node!","text":"delete_node!(node)\n\nDelete a node and re-parent the children to its own parent. If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.delete_nodes!-Tuple{Any}","page":"API","title":"MTG.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, symbol = \"Leaf\")\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (\"Leaf\",\"Internode\"))\n\n# Make the mtg match field measurements made only at branching points for the scales 1 + 2:\nmtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.descendants","page":"API","title":"MTG.descendants","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.descendants!","page":"API","title":"MTG.descendants!","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.descendants_!-NTuple{10, Any}","page":"API","title":"MTG.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.expand_node!-Tuple{Any, Any}","page":"API","title":"MTG.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MTG.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_classes-Tuple{Any}","page":"API","title":"MTG.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_description-Tuple{Any}","page":"API","title":"MTG.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_features-Tuple{Any}","page":"API","title":"MTG.get_features","text":"get_features(mtg)\n\nCompute the mtg features based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_leading_tabs-Tuple{Any}","page":"API","title":"MTG.get_leading_tabs","text":"get_leading_tabs(node)\n\nGet the number of tabulation the node should have when writting it to a file based on the topology of its parent.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_node-Tuple{Node, Any}","page":"API","title":"MTG.get_node","text":"get_node(node::Node, name)\n\nGet a node in an mtg by name.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_printing-Tuple{Node}","page":"API","title":"MTG.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.get_reference-Tuple{Any}","page":"API","title":"MTG.get_reference","text":"get_reference(node)\n\nGet the preceding \"^\" keyword if needed, i.e. in case we refer to the parent node in the same mtg file column.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.getroot-Tuple{Node}","page":"API","title":"MTG.getroot","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.insert_node!-Tuple{Any, Any, Any}","page":"API","title":"MTG.insert_node!","text":"insert_node!(node, template, max_id)\n\nInsert a node as the new parent of node.\n\nArguments\n\nnode::Node: The node at which to insert a node as a parent.\ntemplate::Node: A template node used as the inserted nodes.\nmax_id::Vector{Int64}: The maximum id of the mtg as a vector of 1 value, used to compute\n\nthe name of the inserted node. It is incremented in the function.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\ntemplate = MTG.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmax_id = parse(Int, MTG.max_name(mtg)[6:end])\nmtg = insert_node!(mtg[1][1], template, max_id)\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.insert_nodes!-Tuple{Any, Any}","page":"API","title":"MTG.insert_nodes!","text":"insert_nodes!(mtg::Node,template,<keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note that it always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate::Node: A template node used for all inserted nodes.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\nwhere to insert.\n\nNotes\n\nThe nodes are always inserted before a filtered node because we can't decide if a new node would\n\nbe considered a new child or a new parent of the children otherwise.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ninserting nodes. So if you insert a branching node, the whole subtree will be branched.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\nmtg = insert_nodes!(mtg, MTG.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2) # Will insert new nodes before all scale 2\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.is_filtered-NTuple{5, Any}","page":"API","title":"MTG.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.is_segment!-Tuple{Any}","page":"API","title":"MTG.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.isleaf-Tuple{Node}","page":"API","title":"MTG.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.isroot-Tuple{Node}","page":"API","title":"MTG.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.issection-Tuple{Any, Any}","page":"API","title":"MTG.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.issection-Tuple{Any}","page":"API","title":"MTG.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.max_name-Tuple{Any}","page":"API","title":"MTG.max_name","text":"max_name(mtg)\n\nReturns the maximum name of the mtg based on its index\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.new_name-Tuple{Any, Any}","page":"API","title":"MTG.new_name","text":"new_name(mtg)\nnew_name(mtg,max_name)\n\nMake a new unique identifier by incrementing on the maximum name (names are names+index). Hint: prefer using max_name = max_name(mtg) and then new_name(mtg,max_name) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.next_line!-Tuple{Any, Any}","page":"API","title":"MTG.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.nleaves","page":"API","title":"MTG.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.nleaves!","page":"API","title":"MTG.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.nleaves_siblings!-Tuple{Any}","page":"API","title":"MTG.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}","page":"API","title":"MTG.node_attributes","text":"Instantiate a attr_type struct with node_attr keys and values\n\nArguments\n\nattr_type::DataType: the type of the structure used to hold the attributes\nnode_attr::String: The node attributes as a Base.Dict\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.ordered_children-Tuple{Any}","page":"API","title":"MTG.ordered_children","text":"ordered_children(node)\n\nReturn the children as an array, ordered first by \"+\"\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.parse_MTG_node-Tuple{Any}","page":"API","title":"MTG.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.parse_MTG_node_attr-NTuple{5, Any}","page":"API","title":"MTG.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nattr_type::DataType: the type of the structure used to hold the attributes\nfeatures::DataFrame: The features data.frame\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.parse_macro_args-Tuple{Any}","page":"API","title":"MTG.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))\nMTG.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.parse_mtg!-NTuple{7, Any}","page":"API","title":"MTG.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.parse_section!-NTuple{5, Any}","page":"API","title":"MTG.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MTG.next_line!(f,line)\n\nwhile !MTG.issection(l[1]) || !MTG.issection(l[1],\"CLASSES\")\n    l[1] = MTG.next_line!(f,line)\nend\n\nclasses = MTG.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.paste_mtg_node-Tuple{Any}","page":"API","title":"MTG.paste_mtg_node","text":"paste_mtg_node(node)\n\nParse the mtg node as it should appear in the mtg file.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.pipe_model!-Tuple{Any, Any, Any}","page":"API","title":"MTG.pipe_model!","text":"pipe_model!(node, var_name, threshold_value; allow_missing = false)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (:var_name) is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nallow_missing=false: Allow missing values for var_name, in which case the cross-section is\n\nrecomputed using the pipe model. Please use this option only if you know why.\n\nDetails\n\nThe node cross-section is partitioned from parent to children according to the number of leaves (i.e. terminal nodes) each child bear, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves. If :var_name of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.\n\nWord of caution\n\nSome tips when using this function:\n\nUser must ensure that :var_name has a value for all nodes in the mtg before calling this\n\nversion of pipe_model!, unless allow_missing=true.\n\nNodes with untrusted values should be\n\nset to a value below the threshold value to make pipe_model! recompute them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.pipe_model!-Tuple{Any, Any}","page":"API","title":"MTG.pipe_model!","text":"pipe_model!(node, root_value)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation is as follows: the algorithm first checks how many children a node has. If it has one child only, the child cross-section is equal to the node cross-section. If more children, the node cross-section is shared between the children according to the number of leaves they bear, i.e. the total number of terminal nodes of their sub-tree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.read_mtg","page":"API","title":"MTG.read_mtg","text":"read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attibutes a lot\n\nThe MTG package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation for the MTG format from the OpenAlea webpage for further details.\n\nReturns\n\nThe MTG data.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:\nmtg = read_mtg(file,Dict);\n\n# We can also read an mtg directly from an excel file from the field:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.rewrite_expr!-Tuple{Any, Expr}","page":"API","title":"MTG.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.name)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.name)\n\ntest = :(x = node.foo)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.attributes[:foo])\n\ntest = :(x = node.MTG.symbol)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.MTG.symbol)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.siblings-Tuple{Node}","page":"API","title":"MTG.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.split_MTG_elements-Tuple{Any}","page":"API","title":"MTG.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\", r\"(?<=.)(?=[</+])\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.strip_comments","page":"API","title":"MTG.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MTG.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}","page":"API","title":"MTG.traverse!","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\n\nReturns\n\nNothing for traverse! because it mutates the (sub-)tree in-place, or an Array of whatever the function returns for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.unsafe_getindex-Tuple{Node, Symbol}","page":"API","title":"MTG.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.write_mtg-Tuple{Any, Any}","page":"API","title":"MTG.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MTG.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"api/#MTG.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}","page":"API","title":"MTG.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MTG","category":"page"},{"location":"#MTG.jl","page":"Home","title":"MTG.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTG.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of MTG.jl is to read, write, analyse and plot MTG (Multi-scale Tree Graph) files. These files describe a plant topology (i.e. structure) along with some attributes for each node (e.g. geometry, colours, state...).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is under intensive development and is in a very early version. The functions may heavily change from one version to another until a more stable version is released.","category":"page"},{"location":"#.-Installation","page":"Home","title":"1. Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install the development version of MTG.jl from GitHub using Pkg:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/VEZY/MTG.jl\", rev=\"master\")","category":"page"},{"location":"#.-Example","page":"Home","title":"2. Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read a simple MTG file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MTG\n\nfile = download(\"https://raw.githubusercontent.com/VEZY/XploRer/master/inst/extdata/simple_plant.mtg\");\n\nmtg = read_mtg(file);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can compute new variables in the MTG like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@mutate!(mtg, length_mm = node.Length * 100.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then write the mtg back to disk:","category":"page"},{"location":"","page":"Home","title":"Home","text":"write_mtg(\"test.mtg\",mtg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also transform it into a DataFrame as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DataFrame(mtg, [:length_mm, :XX])","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can learn more about MTG.jl in the next page.","category":"page"}]
}
