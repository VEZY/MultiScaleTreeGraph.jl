var documenterSearchIndex = {"docs":
[{"location":"tutorials/6.add_remove_nodes/#Add/remove-nodes","page":"Add/remove nodes","title":"Add/remove nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"using MultiScaleTreeGraph","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Make-an-MTG-manually","page":"Add/remove nodes","title":"Make an MTG manually","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It is very easy to add or remove nodes in an MTG. Actually, we can even construct an MTG completely manually.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Root-node","page":"Add/remove nodes","title":"Root node","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Create the root node:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg = Node(MutableNodeMTG(\"/\", \"Plant\", 0, 1), Dict{Symbol,Any}(:species => \"Grassy-plant\"))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The first argument to Node is the name. For the root node we usually use \"node_1\". The second argument is a MutableNodeMTG (or a NodeMTG) that defines the topology of the node: its link to its parent (the root node always decomposes), its symbol, its index and its scale. The third and last argument is used to add attributes to the MTG.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Node-id","page":"Add/remove nodes","title":"Node id","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The ids of the nodes should be unique. They are automatically computed using new_id starting by 1 at the root node:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"new_id(mtg)","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Adding-new-nodes","page":"Add/remove nodes","title":"Adding new nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"To create a child node, we use a different method of Node. This method is close to the one we used for the root, except there is a new argument at the second position: the parent node. Here we use the root node as the parent (mtg), and the unique id (new_id) as the child name.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"IN1 = Node(mtg, MutableNodeMTG(\"/\", \"Internode\", 0, 2), Dict{Symbol,Any}(:diameter => 0.1, :length => 0.5))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Now the MTG has two nodes:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can continue like this indefinitely. For example we can add a leaf to the first internode:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Node(IN1, MutableNodeMTG(\"+\", \"Leaf\", 0, 2), Dict{Symbol,Any}(:area => 0.2))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"note: Note\nIf a node has no children, there is no need to keep track of it in an object.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And an internode following the first internode:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"IN2 = Node(IN1, MutableNodeMTG(\"<\", \"Internode\", 1, 2), Dict{Symbol,Any}(:diameter => 0.15, :length => 0.3))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And a leaf to it:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Node(IN2, MutableNodeMTG(\"+\", \"Leaf\", 1, 2), Dict{Symbol,Any}(:area => 0.2))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And here is our resulting MTG:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"And the attributes:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"DataFrame(mtg, get_attributes(mtg))","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Inserting-nodes","page":"Add/remove nodes","title":"Inserting nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insertion-functions","page":"Add/remove nodes","title":"Insertion functions","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Adding nodes recursively is easy, but sometimes we want to insert nodes in-between other nodes. We can still use Node to do so, but it becomes a bit cumbersome because you'll have to handle manually the changes in parents, children and siblings.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We provide some helper functions that does it for you instead:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"insert_parent!: add a new parent node\ninsert_child!: add a new child node\ninsert_sibling!: add a new sibling node\ninsert_generation!: add a new child node, but this new child is considered a whole new generation, meaning the previous children of the node become the children of the new node.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"warning: Warning\nNote the singular form for the name of the functions. The plural form does the job on the whole MTG for selected nodes (see Insert nodes at position).","category":"page"},{"location":"tutorials/6.add_remove_nodes/#The-NodeMTG","page":"Add/remove nodes","title":"The NodeMTG","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Those functions use a NodeMTG (or MutableNodeMTG), and automatically:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"find a unique id for the node\nadd its children, parents and siblings\nupdate the links of the parents / siblings / children","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ninsert_parent!(mtg_2, NodeMTG(\"/\", \"Scene\", 0, 0))\n\nmtg_2 = get_root(mtg_2)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The NodeMTG can also be computed based on the node on which we insert the new node. In this case we can pass a function that take the node as input and returns the template for us:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ninsert_parent!(\n    mtg_2,\n    node -> (\n        link = link(node),\n        symbol = \"Scene\",\n        index = index(node),\n        scale = scale(node) - 1\n    )\n)\nmtg_2 = get_root(mtg_2)\n\nnode_mtg(mtg_2)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The MTG encoding field of the newly-created root node (node_mtg(mtg_2)) used some of the information from the MTG to compute its values.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"note: Note\nWe use get_root to recompute mtg_2 because insert_parent! always return the input node, which is not the root node of the MTG anymore.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Node-attributes","page":"Add/remove nodes","title":"Node attributes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can also provide attributes for the new node using the attr_fun argument. attr_fun expects a function that computes new attributes based on the input node. This function must return attribute values of the same type as the one used for other nodes attributes in the MTG (e.g. Dict or NamedTuple).","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"To know what is the type used for the attributes of your MTG, you can use typeof as follows:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"typeof(node_attributes(mtg))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"If you just need to pass attributes values to a node, you can do as follows:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ninsert_child!(\n    mtg_2,\n    NodeMTG(\"/\", \"Axis\", 0, 2),\n    node -> Dict{Symbol, Any}(:length => 2, :area =>  0.1)\n)\n\nnode_attributes(mtg_2[1])","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"But we can also compute our attributes based on other nodes data:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ninsert_child!(\n    mtg_2,\n    NodeMTG(\"/\", \"Axis\", 0, 2),\n    node -> Dict{Symbol, Any}(:total_length => sum(descendants(node, :length, ignore_nothing = true)))\n)\n\nnode_attributes(mtg_2[1])","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We use mtg_2[1] here to get the first child of the root node.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Delete-a-node","page":"Add/remove nodes","title":"Delete a node","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It is possible to remove a single node in an MTG using delete_node!. For example if we want to delete the second internode (node 4):","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 4))\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"As we can see the new MTG has only one internode now, and the children of the second internode are now the children of its parents, the first internode.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"But what if we deleted the first internode?","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 2))\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We don't see it here in the documentation but this expressions returns a warning now. It says:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Warning: Scale of the child node branched but its deleted parent was decomposing. Keep branching, please check if the decomposition is still correct.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"This is because we don't really know what should be the new link for a branching child replacing a decomposing node. So by default we don't make any assumption and keep the scale of the child as it is, in the hope the user will look into it.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"In our example the first leaf is now branching from the plant, while it should decompose it because it is not of the same scale. But a leaf decomposing a Plant has no meaning botanically. The best approach would be to keep an intermediary node, as it was before.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The user can define its own rules for the new links using the child_link_fun keyword argument of delete_node! (click to see an example usage). It expect a function that takes the child node as input and return its new link.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"For example one could decide to never replace the children link and manage them afterward. In this case we can use the identity function like this:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_del = deepcopy(mtg)\n\ndelete_node!(get_node(mtg_del, 2), child_link_fun = link)\n\nmtg_del","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"It didn't change anything here because the child already kept its own link. But it will differ for other types of parent / children links.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Insert/remove-nodes-programmatically","page":"Add/remove nodes","title":"Insert/remove nodes programmatically","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Sometimes we want to remove or add a lot of nodes in an MTG. This is possible to do it programmatically using dedicated functions.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Delete-nodes","page":"Add/remove nodes","title":"Delete nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can remove all nodes that meet specific conditions given by the usual node filters (see Filters for more details). For example one could remove all nodes of scale 2 in an MTG, i.e. all nodes except the Plant in our example:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_2 = deepcopy(mtg)\n\ndelete_nodes!(mtg_2, scale = 2)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can also remove nodes with more complex filters, for example all nodes with an index greater or equal to 1:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_3 = deepcopy(mtg)\n\ndelete_nodes!(mtg_3, filter_fun = node -> node_mtg(node).index >= 1)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"note: Note\ndelete_nodes! always return the root node of the MTG. If the root node of the original MTG is deleted, its child becomes the new root node. If the root had several children, it returns an error. The function always return the root node of the new MTG, so if the root has not been modified, it remains the same, but if it has been deleted, the new root is returned. That is why it is preferable to use delete_nodes! has a non-mutating function and re-assign the results to an object if it is planned to remove the root node.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"As for delete_node! (singular), by default delete_nodes! (plural) uses new_child_link to re-link the children of the deleted nodes, but the user can provide a custom function. See the function details to learn more about it.","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Insert-nodes","page":"Add/remove nodes","title":"Insert nodes","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/#Insert-nodes-at-position","page":"Add/remove nodes","title":"Insert nodes at position","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"We can add new nodes in an MTG programmatically using:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"insert_parents!: add a new parent node to the filtered nodes\ninsert_children!: add a new child node to the filtered nodes\ninsert_siblings!: add a new sibling node to the filtered nodes\ninsert_generations!: add a new child node to the filtered nodes, but this new child is considered a whole new generation, meaning the previous children of the targeted nodes become the children of the new child node (i.e. a new generation).","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"warning: Warning\nNote the plural form for the name of the functions. The singular form does the same thing but only on the node we provide as input. The plural forms do the job for every filtered node in the MTG.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The functions insert new nodes based either on a template NodeMTG or a function that computes it. The attributes of the nodes are empty by default, be can also be provided by the user either as is, or as a function that computes them.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The id of the inserted node is automatically computed using new_id.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"For example if we need to insert new Flower nodes as parents of each Leaf, we would do:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_4 = deepcopy(mtg)\ntemplate = MutableNodeMTG(\"+\", \"Flower\", 0, 2)\ninsert_parents!(mtg_4, template, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Similarly, we can add a new child to leaves using insert_children!:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"template = MutableNodeMTG(\"/\", \"Leaflet\", 0, 3)\ninsert_children!(mtg_4, template, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Usually, the flower is positioned as a sibling of the leaf though. To do so, we can use insert_siblings!:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"mtg_5 = deepcopy(mtg)\ntemplate = MutableNodeMTG(\"+\", \"Flower\", 0, 2)\ninsert_siblings!(mtg_5, template, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Compute-the-template-on-the-fly","page":"Add/remove nodes","title":"Compute the template on the fly","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The template for the NodeMTG can also be computed on the fly for more complex designs:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"insert_children!(\n    mtg_5,\n    node -> if node_id(node) == 3 MutableNodeMTG(\"/\", \"Spear\", 0, 3) else MutableNodeMTG(\"/\", \"Leaflet\", 0, 3) end,\n    symbol = \"Leaf\"\n)","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Compute-attributes-on-the-fly","page":"Add/remove nodes","title":"Compute attributes on the fly","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"The same is true for the attributes. We can provide them as is:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"insert_siblings!(\n    mtg_5,\n    MutableNodeMTG(\"+\", \"Leaf\", 0, 2),\n    Dict{Symbol, Any}(:area => 0.1),\n    symbol = \"Leaf\"\n)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Or compute them based on the node on which we insert the new nodes. For example if we want the new node to take twice the values of the area of the node it is inserted on, we would do:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"insert_siblings!(\n    mtg_5,\n    MutableNodeMTG(\"+\", \"Leaf\", 0, 2),\n    node -> node[:area] === nothing  ? nothing : Dict{Symbol, Any}(:area => node[:area] * 2),\n    symbol = \"Leaf\"\n)","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"danger: Danger\nThe function used to compute the attributes must return data using the same structure as the one used for the other nodes attributes. In our example it returns a Dict{Symbol, Any}, but it can be different depending on your MTG. To know which structure you should use, use this command:typeof(node_attributes(mtg))","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Let's see the results for the area of our leaves:","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"DataFrame(mtg_5, :area)","category":"page"},{"location":"tutorials/6.add_remove_nodes/#Write-the-MTG","page":"Add/remove nodes","title":"Write the MTG","text":"","category":"section"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"Finally, we can write our newly created MTG to disk using write_mtg. The header of the MTG file will be computed automatically based on the information in the MTG. If you want to pass your own header information you can use the corresponding arguments in the function, e.g. classes.","category":"page"},{"location":"tutorials/6.add_remove_nodes/","page":"Add/remove nodes","title":"Add/remove nodes","text":"write_mtg(\"myMTG.mtg\",mtg)","category":"page"},{"location":"tutorials/7.performance_considerations/#Performance-Considerations","page":"Performance Considerations","title":"Performance Considerations","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/#Introduction","page":"Performance Considerations","title":"Introduction","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"This tutorial covers some of the performance considerations when using MultiScaleTreeGraph.jl. It is not meant to be a comprehensive guide, but rather a starting point for users to understand the performance implications of their code.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"It is important to note that MultiScaleTreeGraph.jl is high-performance by design. The package is designed to be as fast as possible considering the most common use cases. However, there are some things that the user can do to improve performance.","category":"page"},{"location":"tutorials/7.performance_considerations/#Performance-Tips","page":"Performance Considerations","title":"Performance Tips","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/#Attribute-types","page":"Performance Considerations","title":"Attribute types","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"The type used to store the attributes in the nodes are completely free, and can have a significant impact on performance. By default, the attributes are stored in a Dict{Symbol, Any}. This is a very flexible type that allows for getting attributes by name, updating their values, and adding or deleting attributes. However, this flexibility comes at a cost. The Dict type is fast but slower than more optimized types. ","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"If the user just wants to read an MTG and extract information from it, but not update values or add new attributes, it is recommended to use a NamedTuple instead. This will improve performance significantly.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"If the user still want to update values, but does not need to repeatedly add or delete attributes, it is recommended to use a MutableNamedTuple. This will improve performance significantly over Dicts.","category":"page"},{"location":"tutorials/7.performance_considerations/#MTG-encoding","page":"Performance Considerations","title":"MTG encoding","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"The MTG encoding is the type used to store the MTG information about the node, i.e. the scale, index, symbol and link.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"By default, MultiScaleTreeGraph.jl uses a mutable encoding (MutableNodeMTG), which allows for modifying this information. However, if the user does not need to modify these, it is recommended to use an immutable encoding instead (NodeMTG). This will improve performance significantly.","category":"page"},{"location":"tutorials/7.performance_considerations/#Traversal:-node-caching","page":"Performance Considerations","title":"Traversal: node caching","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"MultiScaleTreeGraph.jl traverses all nodes by default when performing tree traversal. The traversal is done in a recursive manner so it is performant, but not always as fast as it could be. For example, we could have a very large tree with only two leaves at the top. In this case, we would traverse all nodes in the tree, even though we only need to traverse two nodes.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"To improve performance, it is possible to cache any type of traversal, including any kind of filter on the nodes, and then use the cached traversal instead of the default one. This will improve performance significantly.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"note: Note\nA cache is a data structure that stores the result of a computation so that it can be reused later. In this case, the cache stores a pointer to the nodes from the traversal so that it can be efficiently reused later. This is a common technique to improve performance at the cost of memory, though the memory cost is usually very small.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"To cache a traversal, you can use cache_nodes!. For example, if you want to cache all the leaf nodes in the MTG, you can do:","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"cache_nodes!(mtg, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"This will cache all the nodes with the symbol \"Leaf\" in the MTG. Then, the tree traversal functions will use the cached traversal to iterate over the nodes.","category":"page"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"tip: Tip\nTree traversal is very fast, so caching nodes is not always necessary. Caching should be used when the traversal is needed multiple times, and the traversal is sparse, i.e. a lot of nodes are filtered-out.","category":"page"},{"location":"tutorials/7.performance_considerations/#Traversal:-descendants-values-caching","page":"Performance Considerations","title":"Traversal: descendants values caching","text":"","category":"section"},{"location":"tutorials/7.performance_considerations/","page":"Performance Considerations","title":"Performance Considerations","text":"Similarly to caching nodes during tree traversal, the mutating version of descendants -descendants!- provides a way to cache the values from the descendants of a node. This is useful when the descendants of a node are needed multiple times, as it avoids traversing the tree multiple times. For example, this is useful when computing the total biomass of all wood each segment supports in a tree, as the biomass of a node is the sum of the biomass of its descendants.","category":"page"},{"location":"tutorials/4.convert_mtg/#Converting-MTGs","page":"Converting MTGs","title":"Converting MTGs","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"We can do a lot using the MTG format, but sometimes we want our data in another format.","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"That's why MultiScaleTreeGraph.jl provide functions to convert an MTG into a DataFrame or into a Graph.","category":"page"},{"location":"tutorials/4.convert_mtg/#MTG-to-DataFrame","page":"Converting MTGs","title":"MTG to DataFrame","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"To convert an MTG into a DataFrame, you can simply use this command:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"df = DataFrame(mtg, :Width)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"This will convert your MTG into a DataFrame along with the selected variable (here the Width). The node MTG is always reported in new columns:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"tree: a pretty-printing of the MTG\nid: the unique ID of the node, taken from the node name (e.g. mtg.name)\nsymbol: the node symbol\nscale: the node scale\nindex: the node index\nparent_id: the node's parent id\nlink: the link between the node and its parent","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"It is also possible to get several attributes as columns by passing their names as a vector:","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"DataFrame(mtg, [:Width, :Length])","category":"page"},{"location":"tutorials/4.convert_mtg/#MTG-to-MetaGraph","page":"Converting MTGs","title":"MTG to MetaGraph","text":"","category":"section"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"We can convert an MTG into a MetaGraph using MetaGraph():","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"mg = MetaGraph(mtg)","category":"page"},{"location":"tutorials/4.convert_mtg/","page":"Converting MTGs","title":"Converting MTGs","text":"This is particularly useful if you want to benefit from the algorithm provided by Graphs.jl and MetaGraphsNext.jl, such as writing into more standard formats such as DOTFormat or MGFormat (or any other available from GraphIO.jl), plotting with GraphPlot.jl or NetworkLayout.jl, or computing e.g. flow with GraphsFlows.jl.","category":"page"},{"location":"the_mtg/mtg_format/#The-.mtg-file-format","page":"File format","title":"The .mtg file format","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The .mtg file format was developed in the AMAP lab to be able to describe a plant in the MTG format directly in a file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The file format is generally used when measuring a plant on the field or to write on disk the results of an architectural model such as AMAPSim or VPalm for example. This format helps exchange and archive data about plants in a standard and efficient way.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The format is described in details in the original paper from Godin et al. (1998), but our implementation in Julia is detailed in this section.","category":"page"},{"location":"the_mtg/mtg_format/#Example-MTG","page":"File format","title":"Example MTG","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's define a very simple virtual plant composed of only two internodes and two leaves:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"<div class=\"sketchfab-embed-wrapper\">\n<iframe title=\"A 3D model\" width=\"640\" height=\"480\" src=\"https://sketchfab.com/models/2a699871f6f6459faa11c206bf81ae9a/embed?autospin=0.2&amp;autostart=1&amp;preload=1&amp;ui_controls=1&amp;ui_infos=1&amp;ui_inspector=1&amp;ui_stop=1&amp;ui_watermark=1&amp;ui_watermark_link=1\" frameborder=\"0\" allow=\"autoplay; fullscreen; vr\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n<p style=\"font-size: 13px; font-weight: normal; margin: 5px; color: #4A4A4A;\">\n<a href=\"https://sketchfab.com/3d-models/a-simple-3d-plant-2a699871f6f6459faa11c206bf81ae9a?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">A simple 3D plant</a>\nby <a href=\"https://sketchfab.com/rvezy?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">rvezy</a>\non <a href=\"https://sketchfab.com?utm_medium=embed&utm_source=website&utm_campaign=share-popup\" target=\"_blank\" style=\"font-weight: bold; color: #1CAAD9;\">Sketchfab</a>\n</p>\n</div>","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The corresponding MTG file is provided with this package. Let's print it using Julia's built-in read method:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This is a consequent file for such a tiny plant! This is because MTG files have a header with several sections before the MTG of the plant itself, which only appears after the MTG: line.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Let's dig into the information we have here.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-sections","page":"File format","title":"The MTG sections","text":"","category":"section"},{"location":"the_mtg/mtg_format/#Introduction","page":"File format","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"An MTG file is divided into five sections. These sections are defined by a keyword and a colon. The content of each section appears on a new line right after the keyword. A section can appear right after the content of the previous section, or they can be separated by blank lines. In fact, all blank lines are ignored in an MTG file.","category":"page"},{"location":"the_mtg/mtg_format/#The-CODE-section","page":"File format","title":"The CODE section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first section of an MTG file is the CODE section. It must appear first in the file as it is used to determine which version of the format specification the MTG file is following. The standard format in 2021 is the FORM-A specification. A new format is under reflexion but is not yet available.","category":"page"},{"location":"the_mtg/mtg_format/#The-CLASSES-section","page":"File format","title":"The CLASSES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The CLASSES section lists all symbols used in the MTG, and associates the scale of each symbol.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The data is presented as a table with five columns:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"SYMBOL: the string used for the node symbol.\nSCALE: the scale of the symbol, meaning all nodes with the given symbol will have this scale.\nDECOMPOSITION: This is not used anymore\nINDEXATION: This is not used anymore\nDEFINITION: This is not used anymore","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The first row of the table is reserved and shouldn't be updated. It is a standard to use the dollar sign as the symbol for the scene, i.e. the node with the higher scale that encompass all MTGs. This node is usually not used in an MTG because MTG files mostly describe just a single plant (or a part of), not a whole scene.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThe symbol must be a character string without any numbers at the end, because the index of a node is read as the numbers at the end of a node name, so if a node symbol ends with a number, it will be parsed as an index. For example a symbol written Axis1 with index 1 will give Axis11 in the MTG, which will be parsed as Axis for the symbol and 11 for the index. Numbers are allowed inside the symbol though, e.g. Ax1s is allowed.","category":"page"},{"location":"the_mtg/mtg_format/#The-DESCRIPTION-section","page":"File format","title":"The DESCRIPTION section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The DESCRIPTION section is a table with four columns, and it defines a set of topological rules the MTG nodes of a same scale must follow. The rules are completely optional, but the header of the section is mandatory. In other words, the table can be empty.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The LEFT column designates the symbol of a parent node, the RIGHT column the symbol of a child node, the RELTYPE column the type of links allowed between the two, and MAX the maximum number of times these types of connexions are allowed in the MTG. The user can use a question mark to denote no maximum.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nThe rules only apply between symbols sharing the same scale (e.g. a node with itself, or in our example, the Internode with a Leaf).","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"These rules are mainly used to check the integrity of an MTG that has been written by hand on the field.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the rules yet. You can let this section empty (with the header) for your MTG if you don't plan to read it with other tools than MultiScaleTreeGraph.jl.","category":"page"},{"location":"the_mtg/mtg_format/#The-FEATURES-section","page":"File format","title":"The FEATURES section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is a table with two columns that define the name of the attributes (or features) that can be attached to nodes, and the type of these attributes. This section makes sure that attributes are interpreted correctly when parsing the file.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The NAME column is used to give the name of an attribute, and the TYPE column its type. The type can be:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"REAL for real numbers, e.g. 0.1\nINT for integer numbers, e.g. 1\nSTRING for strings, e.g. broken\nALPHA for reserved keywords:\nNbEl: NumBer of ELements, the number of children at the next scale\nLength: the node length\nBottomDiameter, the bottom tapering applied to the node for computing its geometry\nTopDiameter, the tapering applied at the top\nState, defines the state of a node. It can take the value D (Dead), A (Alive), B (Broken) , P (Pruned), G (Growing), V (Vegetative), R (Resting), C (Completed), M (Modified), or any combination of these given letters.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"warning: Warning\nThis package does not implement any check on the State of a node, and does not make use of the reserved keywords.","category":"page"},{"location":"the_mtg/mtg_format/#The-MTG-section","page":"File format","title":"The MTG section","text":"","category":"section"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This section is the actual MTG. It describes the topology of the plant, and give the possibility to add attributes to them.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The MTG is encoded as a table with tabulation separated values. The header of this section defines the columns used for describing the topology and the ones used for the attributes. The first column name is reserved and must be named ENTITY-CODE. Then, a set of empty column names (i.e. just tabulations) that defines how many columns are used for the topology. Finally, the following columns are used to define the attributes of the nodes. Their names must match the ones given in The FEATURES section.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Each row of the table usually refers to a single node. The topology is and node description is given in the ENTITY-CODE columns.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"In our example MTG, the first node is the scene: /Scene0. In this package, this notation is called a NodeMTG. It is made out of three different information:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent node: /\nThe node Symbol: Scene\nThe node index: 0","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The link to the parent can be either / (decomposition), < (following) or + (branching). you can read the Node MTG and attributes section for more details on the signification of each. In few words, a node decomposes its parent if it changes the scale of description, follows if it is continuing after its parent, or branching if it branches from its parent.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node symbol is used to determine the scale of the node and eventually its properties.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The node index is completely free. It is mainly used to keep track of the number of following segments on an axis, or the branching order.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"The second node in our example is ^/Individual0. It introduces a new character used as a prefix: ^. By default the parent of a node is defined as the last node present in the column preceding it, e.g.:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"node1 \n node2\n node3","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Here node1 is the parent of node2 and node3. But if we want node2 as the parent of node3, we would have to create a new column:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"node1  \n node2 \n  node3","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"This means large MTGs would require a lot of columns for the topology encoding. This is where ^ becomes useful. It allows us to write a child in the same column as its parent, as long as the parent has only on child:","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"node1 \n node2\n ^node3","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"In the example above, node1 is the parent of node2, and node2 is the parent of node3.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nBecause there is no explicit need to change column when nodes are decomposing or following, we usually create a new column only when a node branches to reduce the number of columns in the ENTITY-CODE.","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"Attributes are then declared in their respective columns defined in the header. If there is no value for an attribute, it is usually declared as an empty column","category":"page"},{"location":"the_mtg/mtg_format/","page":"File format","title":"File format","text":"note: Note\nMTGs entered manually on the field are usually done in a spreadsheet software such as MS Excel or Only Office / Open Office / Libre Office Calc. Here is an example spreadsheet used on the field.","category":"page"},{"location":"tutorials/0.read_write/#Read-and-Write-MTGs","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/#Read","page":"Read and Write MTGs","title":"Read","text":"","category":"section"},{"location":"tutorials/0.read_write/#Reading-a-file","page":"Read and Write MTGs","title":"Reading a file","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Reading an MTG is done using the read_mtg function:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\n\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The file given in input can be either a .mtg, .csv, .xlsx or .xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Options","page":"Read and Write MTGs","title":"Options","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The function has two optional arguments to set the type used for the attributes, and the type used for the MTG field (see next section for more details). It also has a keyword argument to choose the sheet name in case you're reading an xlsx or xlsm file.","category":"page"},{"location":"tutorials/0.read_write/#Attributes-type","page":"Read and Write MTGs","title":"Attributes type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The type used for the attributes should be a NamedTuple-alike or a Dict-alike type. Here is a more in-depth recommendation, use:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"NamedTuple if you don't plan to modify the attributes of the MTG, e.g. to use them for plotting or computing statistics...\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes very often, e.g. recompute an attribute value...\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g. adding/removing attributes a lot","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nIf you don't know what to use, just use the default.","category":"page"},{"location":"tutorials/0.read_write/#MTG-encoding-type","page":"Read and Write MTGs","title":"MTG encoding type","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"The MTG encoding type can be either immutable or mutable. By default we use a mutable one (MutableNodeMTG), but you can use the immutable one by setting the mtg_type argument of the function to NodeMTG. If you're planning on modifying the MTG encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nAgain, if you don't know what to use, use the default.","category":"page"},{"location":"tutorials/0.read_write/#Sheet-name","page":"Read and Write MTGs","title":"Sheet name","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you're reading your MTG from a .xlsx or .xlsm file, you can choose the sheet you want to read by using the keyword argument sheet_name.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"If you don't provide anything for the sheet name, it will read the first one by default.","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"note: Note\nKeyword arguments must be explicitly named in the function call. In this case it would be:file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file, sheet_name = \"A3H\")","category":"page"},{"location":"tutorials/0.read_write/#Write","page":"Read and Write MTGs","title":"Write","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"Writing an MTG back to disk is as simple as this:","category":"page"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"temporary_file = tempname() # using a temporary file here, but you should put the path to the file you want to write\n\nwrite_mtg(temporary_file, mtg)","category":"page"},{"location":"tutorials/0.read_write/#Build-manually","page":"Read and Write MTGs","title":"Build manually","text":"","category":"section"},{"location":"tutorials/0.read_write/","page":"Read and Write MTGs","title":"Read and Write MTGs","text":"It is also possible to build an MTG from scratch using MultiScaleTreeGraph.jl. It is explained in a further tutorial Make an MTG manually.","category":"page"},{"location":"api/#MultiScaleTreeGraph.jl-functions","page":"API","title":"MultiScaleTreeGraph.jl functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is a list of all exported functions from MultiScaleTreeGraph.jl. For more details, click on the link and you'll be directed to the function help.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MultiScaleTreeGraph]","category":"page"},{"location":"api/#DataFrames.DataFrame-Union{Tuple{T}, Tuple{A}, Tuple{N}, Tuple{Node{N, A}, T}} where {N<:AbstractNodeMTG, A, T<:Union{Tuple, Vector{Symbol}}}","page":"API","title":"DataFrames.DataFrame","text":"DataFrame(mtg::Node)\nDataFrame(mtg::Node, key)\n\nConvert an MTG into a DataFrame.\n\nArguments\n\nmtg::Node: An mtg node (usually the root node).\nkey: The attribute(s) name(s). Select a list of variables given either as a Symbol\n\n(faster), a String, or an Array of (or a Tuple).\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Full DataFrame:\nDataFrame(mtg)\n\n# Select just :Length:\nDataFrame(mtg, :Length)\n\n# Select just :Length and :Width:\nDataFrame(mtg, [:Length, :Width])\n\n\n\n\n\n","category":"method"},{"location":"api/#MetaGraphsNext.MetaGraph-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MetaGraphsNext.MetaGraph","text":"MetaGraph(g::Node)\n\nConvert an MTG into a MetaGraph.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nMetaGraph(mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.MutableNodeMTG","page":"API","title":"MultiScaleTreeGraph.MutableNodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.Node","page":"API","title":"MultiScaleTreeGraph.Node","text":"Node(MTG<:AbstractNodeMTG)\nNode(parent::Node, MTG<:AbstractNodeMTG)\nNode(id::Int, MTG<:AbstractNodeMTG, attributes)\nNode(name::String, id::Int, MTG<:AbstractNodeMTG, attributes)\nNode(id::Int, parent::Node, MTG<:AbstractNodeMTG, attributes)\nNode(name::String, id::Int, parent::Node, MTG<:AbstractNodeMTG, attributes)\nNode(\n    name::String,\n    id::Int,\n    parent::Node,\n    children::Vector{Node},\n    MTG<:AbstractNodeMTG,\n    attributes\n)\nNode(\n    name::String,\n    id::Int,\n    parent::Node,\n    children::Vector{Node},\n    MTG<:AbstractNodeMTG,\n    attributes;\n    traversal_cache\n)\n\nType that defines an MTG node (i.e. an element) with:\n\nname: the name of the node\nid: its unique id\nparent: the parent node (if not the root node)\nchildren: an optional array of children nodes\nMTG: the MTG description, or encoding (see NodeMTG or\n\nMutableNodeMTG)\n\nattributes: the node attributes, that can be anything but \n\nusually a Dict{String,Any}\n\ntraversal_cache: a cache for the traversal, used by e.g. traverse to traverse more efficiently particular nodes in the MTG\n\nThe node is an entry point to a Mutli-Scale Tree Graph, meaning we can move through the MTG from any of its node. The root node is the node without parent. A leaf node is a node without any children. Root and leaf nodes are used with their computer science meaning throughout the package, not in the biological sense.\n\nNote that it is possible to create a whole MTG using only the Node type, because it has methods to create a node as a child of another node (see example below). \n\nExamples\n\nmtg = Node(NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(\n    mtg,\n    NodeMTG(\"/\", \"Internode\", 1, 2)\n)\n# Note that the node is created with a parent, so it is not necessary to add it as a child of the `mtg ` Node\n\nmtg\n\n\n\n\n\n","category":"type"},{"location":"api/#MultiScaleTreeGraph.NodeMTG","page":"API","title":"MultiScaleTreeGraph.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.children-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"AbstractTrees.children","text":"AbstractTrees.children(node::Node{T,A}) where {T,A}\n\nGet the children of a MultiScaleTreeGraph node.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractTrees.parent-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"AbstractTrees.parent","text":"AbstractTrees.parent(node::Node{T,A})\n\nGet the parent of a MultiScaleTreeGraph node. If the node is the root, it returns nothing.\n\nSee also reparent! to update the parent of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractNodeMTG","page":"API","title":"Base.:==","text":"==(a::Node, b::Node)\n\nTest AbstractNodeMTG equality.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Union{Tuple{T}, Tuple{T, T}} where T<:Node","page":"API","title":"Base.:==","text":"==(a::Node, b::Node)\n\nTest Node equality. The parent, children and siblings are not tested, only their id is.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"API","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple, GenericNode}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict, GenericNode}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Any}","page":"API","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Node, Integer}","page":"API","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Node}","page":"API","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.names-Tuple{T} where T<:Node","page":"API","title":"Base.names","text":"names(mtg)\n\nGet all attributes names available on the mtg and its children. This is an alias for get_attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parent-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"Base.parent","text":"Base.parent(node::Node{T,A})\n\nGet the parent of a MultiScaleTreeGraph node. If the node is the root, it returns nothing.\n\nSee also reparent! to update the parent of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.print-Tuple{Node}","page":"API","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.select!-Tuple{Node, Vararg{Any}}","page":"API","title":"DataFrames.select!","text":"select!(node::Node, args..., <keyword arguments>)\nselect(node::Node, args..., <keyword arguments>)\n\nDelete all attributes not selected in args..., and optionally apply transformations on the fly on the selected variables. This function works similarly to transform! except it keeps only the selected variables, while transform! add new variables.\n\nSee the documentation of transform! for more details on the format of args and on how to use the arguments.\n\nThis function adds one more form to args...: a variable name to just select a variable.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nselect!(mtg, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.transform","page":"API","title":"DataFrames.transform","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or\n\n[:var_name1, :var_name2...] => function => :new_var_name pair. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. The new attribute name is optional and is automatically generated if not provided by concatenating the source column name(s) and the function name if any.\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 expect a function that takes one or more node attributes (== variables) as inputs, while form 3 and 4 expect a function that takes a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finally, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#DataFrames.transform!","page":"API","title":"DataFrames.transform!","text":"transform!(node::Node, args..., <keyword arguments>)\ntransform(node::Node, args..., <keyword arguments>)\n\nTransform (mutate) an MTG (node) in place (transform!) or on a copy (transform) to add attributes specified by args....\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nargs::Any: the transformations (see details)\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nignore_nothing = false: filter-out the nodes with nothing values for the given\nattributes used as inputs (apply only to the form :var_name => ...)\n\nReturns\n\ntransform!: Nothing, mutates the (sub-)tree in-place. transform: A mutated copy of node.\n\nNotes\n\nCarefull, transform is much slower than transform! because it makes a copy of the whole MTG each time.\n\nDetails\n\nThe interface of the function is inspired from the one used in DataFrames.jl, but adapted to an MTG.\n\nThe args... provided can be of the following forms:\n\na :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or\n\n[:var_name1, :var_name2...] => function => :new_var_name pair. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to the function. The new attribute name is optional and is automatically generated if not provided by concatenating the source column name(s) and the function name if any.\n\na function => :new_var_name form that applies a function to a node and puts the results\n\nin a new attribute. This form is usually applied when searching ancestors or descendants values.\n\na function form that applies a mutating function to a node, without expecting any output.\n\nThis form is adapted when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.\n\nCarefull to the form you use! Form 2 expect a function that takes one or more node attributes (== variables) as inputs, while form 3 and 4 expect a function that takes a node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# We can use transform to apply a function over all nodes (same as using [`traverse!`](@ref))\ntransform!(mtg,  x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can compute a new variable based on another. For example to know if the value of the\n# `:Length` attribute is provided or not, we can do:\ntransform!(mtg, :Length => isnothing)\n# To check the values we first call [`get_attributes`](@ref) to know the new variable name:\nget_attributes(mtg)\n# And then we get the values using [`descendants`](@ref)\ndescendants(mtg, :Length_isnothing, self = true)\n# Or DataFrame:\nDataFrame(mtg, :Length_isnothing)\n\n# We can also set the attribute name ourselves like so:\ntransform!(mtg, :Length => isnothing => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# We can provide anonymous functions if we want to:\ntransform!(mtg, :Length => (x -> isnothing(x)) => :no_length)\ndescendants(mtg, :no_length, self = true)\n\n# When a node does not have an attribute, it returns `nothing`. Most basic functions do not\n# handle those very well, e.g.:\ntransform!(mtg, :Length => log)\n# It does not work because some nodes have no value for `:Length`.\n# To remove automatically the nodes with `nothing` values, use `ignore_nothing`:\ntransform!(mtg, :Length => log => :log_length, ignore_nothing = true)\ndescendants(mtg, :log_length, self = true)\n\n# Or you could handle these manually in your function if you prefer:\ntransform!(mtg, :Length => (x -> x === nothing ? nothing : log(x)) => :log_length2)\ndescendants(mtg, :log_length2, self = true)\n\n# Another way is to give a filtering function as an argument:\ntransform!(mtg, :Length => log => :log_length, filter_fun = x -> x[:Length] !== nothing)\n\n# We can use more than one attribute as input to our function like so:\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :volume,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\ndescendants(mtg, :volume, self = true)\n\n# Note that `filter_fun` filter the node, so we use the node[:attribute] notation here.\n\n# We can also chain operations, and they will be executed sequentially so we can use variables\n# computed on the instruction just before:\ndensity = 0.6\ntransform!(\n    mtg,\n    [:Width, :Length] => ((x, y) -> (x/2)^2 * π * y) => :vol,\n    :vol => (x -> x * density) => :biomass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :biomass])\n\n# We can also rename a variable like so:\ntransform!(\n    mtg,\n    :biomass => :mass,\n    filter_fun = x -> x[:Length] !== nothing && x[:Width] !== nothing\n)\nDataFrame(mtg, [:vol, :mass])\n\n# Finally, we can use variables from ancestors/descendants using the `function => :new_var` form:\nfunction get_mass_descendants(x)\n    masses = descendants(x, :mass, ignore_nothing = true)\n    if length(masses) == 0\n        nothing\n    else\n        sum(masses)\n    end\nend\n\ntransform!(\n    mtg,\n    get_mass_descendants => :mass_beared\n)\nDataFrame(mtg, [:mass, :mass_beared])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.addchild!-Union{Tuple{M}, Tuple{Node, Int64, M, Any}} where M<:AbstractNodeMTG","page":"API","title":"MultiScaleTreeGraph.addchild!","text":"addchild!(p::Node, id::Int, MTG<:AbstractNodeMTG, attributes)\naddchild!(p::Node, MTG<:AbstractNodeMTG, attributes)\naddchild!(p::Node, MTG<:AbstractNodeMTG)\naddchild!(p::Node, child::Node; force=false)\n\nAdd a new child to a parent node (p), and add the parent node as the parent. Returns the child node.\n\nSee also insert_child!, or directly Node where we  can pass the parent, and it uses addchild! under the hood.\n\nExamples\n\n# Create a root node:\nmtg = MultiScaleTreeGraph.Node(\n    NodeMTG(\"/\", \"Plant\", 1, 1),\n    Dict{Symbol,Any}()\n)\n\nroots = addchild!(\n    mtg, \n    NodeMTG(\"+\", \"RootSystem\", 1, 2)\n)\n\nstem = addchild!(\n    mtg, \n    NodeMTG(\"+\", \"Stem\", 1, 2)\n)\n\nphyto = addchild!(\n    stem, \n    NodeMTG(\"/\", \"Phytomer\", 1, 3)\n)\n\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\nancestors(node::Node,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal), or the ancestor nodes that are not filtered-out.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. It is only mandatory for the first method that search for attributes values. The second method returns the node directly. \n\nMake it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = get_node(mtg, 5)\n\nancestors(leaf_node, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\nancestors(leaf_node, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1, type = Float64)\nancestors(leaf_node, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = \"Internode\")\nancestors(leaf_node, :Length, symbol = (\"Axis\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.branching_order!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.branching_order!","text":"branching_order!(mtg; ascend = true)\n\nCompute the topological branching order of the nodes in an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nNotes\n\nThe order of a node is computed from the maximum order of their children when using the basipetal computation.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nbranching_order!(mtg)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\nbranching_order!(mtg, ascend = false)\nDataFrame(mtg, :branching_order)\n# 7×2 DataFrame\n#  Row │ tree                        branching_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.cache_name-Tuple","page":"API","title":"MultiScaleTreeGraph.cache_name","text":"cache_name(vars...)\n\nMake a unique name based on the vars names.\n\nExamples\n\ncache_name(\"test\",\"var\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.cache_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.cache_nodes!","text":"cache_nodes!(node; scale=nothing, symbol=nothing, link=nothing, filter_fun=nothing, overwrite=false)\n\nCache the nodes of the mtg based on the filters that would be applied to a traversal. This is automatically usually for traversal then when using traverse! or transform!.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))), \"test\", \"files\", \"simple_plant.mtg\")\nmtg = read_mtg(file, Dict)\n\n# Cache all leaf nodes:\ncache_nodes!(mtg, symbol=\"Leaf\")\n\n# Cached nodes are stored in the traversal_cache field of the mtg (here, the two leaves):\n@test MultiScaleTreeGraph.node_traversal_cache(mtg)[\"_cache_c0bffb8cc8a9b075e40d26be9c2cac6349f2a790\"] == [get_node(mtg, 5), get_node(mtg, 7)]\n\n# Then you can use the cached nodes in a traversal:\ntraverse(mtg, x -> symbol(x), symbol=\"Leaf\") == [\"Leaf\", \"Leaf\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.check_filters-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.check_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = \"Leaf\", link = \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.clean_cache!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.components","page":"API","title":"MultiScaleTreeGraph.components","text":"symbols(mtg)\ncomponents(mtg)\n\nGet all the symbols names, a.k.a. components of an MTG.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.delete_node!-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.delete_node!","text":"deletenode!(node; childlinkfun = newchild_link)\n\nDelete a node and re-parent the children to its own parent.\n\nIf the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nchild_link_fun is a function that takes the child node of a deleted node as input and returns its new link. The default function is new_child_link, which tries to be clever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nchild_link_fun = new_child_link: a function that takes the child node of a deleted node\n\nas input and returns its new link (see details).\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nThe default function used for child_link_fun is new_child_link, which tries to be\n\nclever considering the parent and child links. See its help page for more information. If the link shouldn't be modified, use the link function instead.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, symbol = \"Leaf\")\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (\"Leaf\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.descendants","page":"API","title":"MultiScaleTreeGraph.descendants","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants(node::Node,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants of the node (acropetal). The first method returns an array of values, the second an array of nodes that respect the filters, and the third the mutating version of the  first one that caches the results in the mtg.\n\nThe mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster when descendants is called repeateadly for the same computation on large trees, but require to clean the chache sometimes  (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name (only mandatory for the first and third methods). Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = Inf: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If Inf (the default) or a negative value is provided, there is no  recursion limitation.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Can make the function run much\n\nfaster if provided (e.g. ≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XEuler, scale = 3, type = Union{Nothing, Float64})\ndescendants(mtg, :Length, scale = 3, type = Float64) # No `nothing` value here, no need of a union type\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# You can also ask for different attributes by passing them as a vector:\ndescendants(mtg, [:Width, :Length]; filter_fun = isleaf)\n# The output is an array of arrays of length of the attributes you asked for.\n\n# It is possible to cache the results in the mtg using the mutating version `descendants!` (note the `!` \n# at the end of the function name):\ntransform!(mtg, node -> sum(descendants!(node, :Length)) => :subtree_length, symbol = \"Internode\")\n\n# Or using `@mutate_mtg!` instead of `transform!`:\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length)), symbol = \"Internode\")\n\n# The cache is stored in a temporary variable with a name that starts with `_cache_` followed by the SHA\n# of the function call, *e.g.*: `:_cache_5c1e97a3af343ce623cbe83befc851092ca61c8d`:\nnode_attributes(mtg[1][1][1])\n\n# You can then clean the cache to avoid using too much memory:\nclean_cache!(mtg)\nnode_attributes(mtg[1][1][1])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants!","page":"API","title":"MultiScaleTreeGraph.descendants!","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants(node::Node,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants of the node (acropetal). The first method returns an array of values, the second an array of nodes that respect the filters, and the third the mutating version of the  first one that caches the results in the mtg.\n\nThe mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster when descendants is called repeateadly for the same computation on large trees, but require to clean the chache sometimes  (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name (only mandatory for the first and third methods). Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = Inf: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If Inf (the default) or a negative value is provided, there is no  recursion limitation.\n\nignore_nothing = false: filter-out the nodes with nothing values for the given key\ntype::Union{Union,DataType}: The type of the attribute. Can make the function run much\n\nfaster if provided (e.g. ≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XEuler, scale = 3, type = Union{Nothing, Float64})\ndescendants(mtg, :Length, scale = 3, type = Float64) # No `nothing` value here, no need of a union type\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# You can also ask for different attributes by passing them as a vector:\ndescendants(mtg, [:Width, :Length]; filter_fun = isleaf)\n# The output is an array of arrays of length of the attributes you asked for.\n\n# It is possible to cache the results in the mtg using the mutating version `descendants!` (note the `!` \n# at the end of the function name):\ntransform!(mtg, node -> sum(descendants!(node, :Length)) => :subtree_length, symbol = \"Internode\")\n\n# Or using `@mutate_mtg!` instead of `transform!`:\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length)), symbol = \"Internode\")\n\n# The cache is stored in a temporary variable with a name that starts with `_cache_` followed by the SHA\n# of the function call, *e.g.*: `:_cache_5c1e97a3af343ce623cbe83befc851092ca61c8d`:\nnode_attributes(mtg[1][1][1])\n\n# You can then clean the cache to avoid using too much memory:\nclean_cache!(mtg)\nnode_attributes(mtg[1][1][1])\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.descendants_!-NTuple{10, Any}","page":"API","title":"MultiScaleTreeGraph.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.expand_node!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MultiScaleTreeGraph.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.filter_fun_nothing-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.filter_fun_nothing","text":"filter_fun_nothing(filter_fun, ignore_nothing, attr_keys)\n\nReturns a new filtering function that adds a filter on the keys value for nothing if ignore_nothing is true\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_attributes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_attributes","text":"get_attributes(mtg)\n\nGet all attributes names available on the mtg and its children.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_classes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_description-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_features-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.get_features","text":"get_features(mtg)\n\nCompute the mtg features section based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node-Tuple{Node, Int64}","page":"API","title":"MultiScaleTreeGraph.get_node","text":"get_node(node::Node, id::Int)\n\nGet a node in an mtg by id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6_2 = get_node(mtg, 6)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_node_printing!","page":"API","title":"MultiScaleTreeGraph.get_node_printing!","text":"get_node_printing!(node, lead, ref, print_node, node_lead=0, node_ref=\"\")\n\nGet the number of tabulation (in lead) and the \"^\" (in ref) used as a prefix for the node when writting it to a file, based on the topology of its parent. Also get the node printing (e.g. \"/Axis0\") in print_node.\n\nThe function modifies the lead, ref and print_node vectors in place.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nlead = Int[]\nref = String[]\nget_node_printing!(mtg, lead, ref)\n\nlead\nref\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.get_printing-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.get_root-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.get_root","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.index!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.index!","text":"index(node::Node)\n\nGet the index from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.index-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.index","text":"index(node::Node)\n\nGet the index from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_child!","page":"API","title":"MultiScaleTreeGraph.insert_child!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1]))\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_children!","page":"API","title":"MultiScaleTreeGraph.insert_children!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generation!","page":"API","title":"MultiScaleTreeGraph.insert_generation!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1]))\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_generations!","page":"API","title":"MultiScaleTreeGraph.insert_generations!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_nodes!-Union{Tuple{A}, Tuple{N}, Tuple{Node{N, A}, Any, Any}, Tuple{Node{N, A}, Any, Any, Any}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.insert_nodes!","text":"Actual workhorse of insertparents!, insertgenerations!, insertchildren!, insertsiblings!\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.insert_parent!","page":"API","title":"MultiScaleTreeGraph.insert_parent!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1]))\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_parents!","page":"API","title":"MultiScaleTreeGraph.insert_parents!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_sibling!","page":"API","title":"MultiScaleTreeGraph.insert_sibling!","text":"insert_parent!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_generation!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_child!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\ninsert_sibling!(node, template, attr_fun = node -> typeof(node_attributes(node))(), max_id = [max_id(node)])\n\nInsert a node in an MTG as:\n\na new parent of node: insert_parent!\na new child of node: insert_child!\na new sibling of node: insert_sibling!\na new child of node, but the children of node become the children of the inserted node:\n\ninsert_generation!\n\nArguments\n\nnode::Node: The node from which to insert a node (as its parent, child or sibling).\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr_fun: A function to compute new attributes based on the filtered node. Must return\n\nattribute values of the same type as the one used in other nodes from the MTG (e.g. Dict or NamedTuple). If you just need to pass attributes values to a node use x -> your_values.\n\nmax_id::Vector{Int64}: The maximum id of the nodes in the MTG as a vector of length one.\n\nUsed to compute the name of the inserted node. It is incremented in the function, and use by default the value from max_id.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ntemplate = MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\ninsert_parent!(mtg[1][1], template)\nmtg\n\n# The template can be a function that returns the template. For example a dummy example would\n# be a function that uses the NodeMTG of the first child of the node:\n\ninsert_parent!(\n    mtg[1][1],\n    node -> (\n        link = link(node[1]),\n        symbol = symbol(node[1]),\n        index = index(node[1]),\n        scale = scale(node[1]))\n    )\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.insert_siblings!","page":"API","title":"MultiScaleTreeGraph.insert_siblings!","text":"insert_parents!(node::Node, template, <keyword arguments>)\ninsert_generations!(node::Node, template, <keyword arguments>)\ninsert_children!(node::Node, template, <keyword arguments>)\ninsert_siblings!(node::Node, template, <keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note the function always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nInsert nodes programmatically in an MTG as:\n\nnew parents of the filtered nodes: insert_parents!\nnew children of the filtered nodes: insert_children!\nnew siblings of the filtered node: insert_siblings!\nnew children of the filtered nodes, but the previous children of the filtered node become\n\nthe children of the inserted node: insert_generations!\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate:\nA template NodeMTG or MutableNodeMTG used for the inserted node,\nA NamedTuple with values for link, symbol, index, and scale\nOr a function taking the node as input and returning said template\nattr: Attributes for the node. Similarly to template, can be:\nAn attribute of the same type as of node attributes (e.g. a Dict or a NamedTuple)\nA function to compute new attributes (should also return same type for the attributes)\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\non which node the insertion will be based on.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Insert new Shoot nodes before all scale 2 nodes:\nmtg = insert_parents!(mtg, MultiScaleTreeGraph.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2)\n\nmtg\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.is_filtered-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.is_segment!-Union{Tuple{Node{N, A}}, Tuple{A}, Tuple{N}} where {N<:AbstractNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isleaf-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.isroot-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.issection-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.lastchild-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.lastchild","text":"lastchild(node::Node)\n\nGet the last child of node, or nothing if the node is a leaf.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.lastsibling-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.lastsibling","text":"lastsibling(node::Node)\n\nReturn the last sibling of node (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.link!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.link!","text":"link(node::Node)\n\nGet the link from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.link-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.link","text":"link(node::Node)\n\nGet the link from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.list_nodes-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.list_nodes","text":"list_nodes(mtg)\n\nList all nodes IDs in the subtree of mtg.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.max_id-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.max_id","text":"max_id(mtg)\n\nReturns the maximum id of the mtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_child_link-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.new_child_link","text":"new_child_link(node)\n\nCompute the new link of the child node when deleting a parent node. The rule is to give the child node link of its parent node that is deleted, except when the parent was following its own parent.\n\nThe node given as input is the child node here.\n\nThe rule is summarized in the following table:\n\nDeleted node link Child node link New child node link warning\n/ / / \n/ + + yes (1)\n/ < / \n+ / / yes (2)\n+ + + \n+ < + \n< / / \n< + + \n< < < \n\nThe warnings happens when there is no satisfactory way to handle the new link, i.e. when mixing branching and change in scale.\n\nNote that in the case (1) of the warning the first child only takes the \"/\" link, the others keep their links.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_id-Tuple{Int64}","page":"API","title":"MultiScaleTreeGraph.new_id","text":"new_id(mtg)\nnew_id(mtg, max_id)\n\nMake a new unique identifier by incrementing on the maximum node id. Hint: prefer using max_id = max_id(mtg) and then new_id(mtg, max_is) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.new_node_MTG-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.new_node_MTG","text":"new_node_MTG(node, template<:Union{NodeMTG,MutableNodeMTG,NamedTuple,MutableNamedTuple})\nnew_node_MTG(node, fn)\n\nReturns a new NodeMTG matching the one used in node (either NodeMTG or MutableNodeMTG) based on a template, or on a function that takes a node as input and return said template.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# using a NodeMTG as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, NodeMTG(\"/\", \"Leaf\", 1, 2))\n# Note that it returns a MutableNodeMTG because `mtg` is using this type instead of a `NodeMTG`\n\n# using a NamedTuple as a template:\nMultiScaleTreeGraph.new_node_MTG(mtg, (link = \"/\", symbol = \"Leaf\", index = 1, scale = 2))\n\n# using a function that returns a template based on the first child of the node:\nMultiScaleTreeGraph.new_node_MTG(\n    mtg,\n    x -> (\n            link = link(x[1]),\n            symbol = symbol(x[1]),\n            index = index(x[1]),\n            scale = scale(x[1]))\n        )\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.next_line!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.nleaves","page":"API","title":"MultiScaleTreeGraph.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves!","page":"API","title":"MultiScaleTreeGraph.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.nleaves_siblings!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, A}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.node_attributes!","text":"node_attributes!(node::Node)\n\nSet the attributes of a node, i.e. replace the whole structure by another. This function is internal,  and should not be used directly. Use e.g. node.key = value to set a single attribute of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes-Union{Tuple{Node{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.node_attributes","text":"node_attributes(node::Node)\n\nGet the attributes of a node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}","page":"API","title":"MultiScaleTreeGraph.node_attributes","text":"Instantiate a attr_type struct with node_attr keys and values\n\nArguments\n\nattr_type::DataType: the type of the structure used to hold the attributes\nnode_attr::String: The node attributes as a Dict\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_id-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_id","text":"node_id(node::Node)\n\nGet the unique id of the node in the MTG.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_mtg-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_mtg","text":"node_mtg(node::Node)\n\nGet the MTG encoding of the node, i.e. the MTG description (see NodeMTG or MutableNodeMTG):\n\nscale: the scale of the node (e.g. 1)\nsymbol: the symbol of the node (e.g. \"Axis\")\nindex: the index of the node (e.g. 1, this is free)\nlink: the link of the node (\"/\", \"+\" or \"<\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.node_traversal_cache-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.node_traversal_cache","text":"node_traversal_cache(node::Node)\n\nGet the traversal cache of the node if any.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_MTG_node_attr-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nattr_type::DataType: the type of the structure used to hold the attributes\nfeatures::DataFrame: The features data.frame\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_line_to_node!-NTuple{10, Any}","page":"API","title":"MultiScaleTreeGraph.parse_line_to_node!","text":"parse_line_to_node!(tree_dict, l, line, attr_column_start, node_id, attr_type, mtg_type, features,classes)\n\nParse a line of the MTG file to a node and add it to the tree dictionary. It may also add several nodes if the line contains several MTG elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_macro_args-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))\nMultiScaleTreeGraph.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_mtg!-NTuple{7, Any}","page":"API","title":"MultiScaleTreeGraph.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.parse_section!-NTuple{5, Any}","page":"API","title":"MultiScaleTreeGraph.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MultiScaleTreeGraph.next_line!(f,line)\n\nwhile MultiScaleTreeGraph.issection(l[1]) || MultiScaleTreeGraph.issection(l[1],\"CLASSES\")\n    l[1] = MultiScaleTreeGraph.next_line!(f,line)\nend\n\nclasses = MultiScaleTreeGraph.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, var_name, threshold_value; allow_missing = false)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section (:var_name) is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nallow_missing=false: Allow missing values for var_name, in which case the cross-section is\n\nrecomputed using the pipe model. Please use this option only if you know why.\n\nDetails\n\nThe node cross-section is partitioned from parent to children according to the number of leaves (i.e. terminal nodes) each child subtree has, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves. If :var_name of the siblings are higher than the parent value, the cross-section of the node is computed only using the number of leaves as it should not be bigger.\n\nWord of caution\n\nSome tips when using this function:\n\nUser must ensure that :var_name has a value for all nodes in the mtg before calling this\n\nversion of pipe_model!, unless allow_missing=true.\n\nNodes with untrusted values should be\n\nset to a value below the threshold value to make pipe_model! recompute them.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.pipe_model!","text":"pipe_model!(node, root_value; name=:_cache_a7118a60b2a624134bf9eac2d64f2bb32798626a)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation uses the following algorithm:\n\nFirst, check how many children a node has.\n\nIf it has one child only, the child cross-section is equal to the node cross-section.\n\nIf more children, the node cross-section is shared between the children according to the number of leaf nodes their subtree has, i.e. the total number of terminal nodes of their subtree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.prune!-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.prune!","text":"prune!(node)\n\nPrune a tree at node, i.e. delete the entire sub-tree starting at node (including it).\n\nReturns an error if the node is a root, or the parent node of the (deleted) node.\n\nExamples\n\nusing MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nprune!(get_node(mtg, 6))\n\nmtg\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.read_mtg","page":"API","title":"MultiScaleTreeGraph.read_mtg","text":"read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG; sheet_name = nothing)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nsheet_name = nothing: the sheet name in case you're reading an xlsx or xlsm file. It\n\nreads the first sheet if nothing (default behavior).\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attributes a lot\n\nThe MultiScaleTreeGraph package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation of the MTG format from the package documentation for further details, e.g. The MTG concept.\n\nReturns\n\nThe MTG root node.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:\nmtg = read_mtg(file,Dict);\n\n# We can also read an mtg directly from an excel file from the field:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"tree3h.xlsx\")\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.rechildren!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Array{Node{T, A}, 1}}} where {T, A}","page":"API","title":"MultiScaleTreeGraph.rechildren!","text":"rechildren!(node::Node{T,A}, chnodes::Vector{Node{T,A}}) where {T,A}\n\nSet the children of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.reparent!-Union{Tuple{N2}, Tuple{N}, Tuple{A}, Tuple{T}, Tuple{N, N2}} where {T, A, N<:Node{T, A}, N2<:Union{Nothing, Node{T, A}}}","page":"API","title":"MultiScaleTreeGraph.reparent!","text":"reparent!(node::N, p::N) where N<:Node{T,A}\n\nSet the parent of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.rewrite_expr!-Tuple{Any, Expr}","page":"API","title":"MultiScaleTreeGraph.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.name)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = mtg.name)\n\ntest = :(x = node.foo)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = mtg[:foo])\n\ntest = :(x = symbol(node))\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = symbol(mtg))\n\ntest = :(x = node_mtg(node) |> symbol)\nMultiScaleTreeGraph.rewrite_expr!(:mtg,test)\ntest\n# :(mtg[:x] = node_mtg(mtg) |> symbol)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scale!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.scale!","text":"scale(node::Node)\n\nGet the scale from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scale-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.scale","text":"scale(node::Node)\n\nGet the scale from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.scales-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.scales","text":"scales(mtg)\n\nGet all the scales of an MTG.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.siblings-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.split_MTG_elements-Tuple{Any}","page":"API","title":"MultiScaleTreeGraph.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit_MTG_elements(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\")\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.strip_comments","page":"API","title":"MultiScaleTreeGraph.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.symbol!-Union{Tuple{A}, Tuple{T}, Tuple{Node{T, A}, Any}} where {T<:MutableNodeMTG, A}","page":"API","title":"MultiScaleTreeGraph.symbol!","text":"symbol!(node::Node, symbol)\n\nSet the symbol of the MTG encoding node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.symbol-Tuple{Node}","page":"API","title":"MultiScaleTreeGraph.symbol","text":"symbol(node::Node)\n\nGet the symbol from the MTG encoding of the node.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.symbols","page":"API","title":"MultiScaleTreeGraph.symbols","text":"symbols(mtg)\ncomponents(mtg)\n\nGet all the symbols names, a.k.a. components of an MTG.\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse","page":"API","title":"MultiScaleTreeGraph.traverse","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that is filtered out (false).\ntype::Type = Any: The elements type of the returned array. This can speed-up things. Only available for the non-mutating version.\nrecursivity_level::Int = Inf: The maximum depth of the traversal. Default is Inf (i.e. no limit).\n\nReturns\n\nnothing for traverse! because it mutates the (sub-)tree in-place, or an Array{type} (or Array{Any} if type is not given) for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.traverse!","page":"API","title":"MultiScaleTreeGraph.traverse!","text":"traverse!(node::Node, f::Function[, args...], <keyword arguments>)\ntraverse(node::Node, f::Function[, args...], <keyword arguments>)\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n<keyword arguments>:\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that is filtered out (false).\ntype::Type = Any: The elements type of the returned array. This can speed-up things. Only available for the non-mutating version.\nrecursivity_level::Int = Inf: The maximum depth of the traversal. Default is Inf (i.e. no limit).\n\nReturns\n\nnothing for traverse! because it mutates the (sub-)tree in-place, or an Array{type} (or Array{Any} if type is not given) for traverse.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n# We can also use the `do...end` block notation when we have a complex set of instructions:\ntraverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#MultiScaleTreeGraph.unsafe_getindex-Tuple{Node, Symbol}","page":"API","title":"MultiScaleTreeGraph.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.write_mtg-Tuple{Any, Any}","page":"API","title":"MultiScaleTreeGraph.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiScaleTreeGraph.@mutate_mtg!-Tuple{Any, Vararg{Any}}","page":"API","title":"MultiScaleTreeGraph.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2, filter_fun = node -> node.scales !== nothing)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node_id(node)), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node_id(node))\n\n\n\n\n\n","category":"macro"},{"location":"api/#MultiScaleTreeGraph.@mutate_node!-Tuple{Any, Vararg{Any}}","page":"API","title":"MultiScaleTreeGraph.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node_id(node)), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node_id(node))\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/5.plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"The companion package PlantGeom.jl provides plots recipes to plot MTGs using either Plots.jl or Makie.jl.","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"To do so, you just have to use either of the packages, and choose a backend. Let's plot the MTG using CairoMakie:","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"# import Pkg; Pkg.add(\"CairoMakie\"); Pkg.add(\"PlantGeom\")\nusing CairoMakie, PlantGeom\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndiagram(mtg)","category":"page"},{"location":"tutorials/5.plotting/","page":"Plotting","title":"Plotting","text":"(Image: A diagram of the MTG)","category":"page"},{"location":"the_mtg/mtg_concept/#The-MTG-concept","page":"Concept","title":"The MTG concept","text":"","category":"section"},{"location":"the_mtg/mtg_concept/#Introduction","page":"Concept","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The Multi-scale Tree Graph -or MTG for short- is a data structure for describing a tree-alike object at one or several scales.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Let's take a grass plant as an example:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 1. A Typical grass plant.[1]","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"This plant can be described at the individual scale, as a whole (Fig. 2a). At this scale, we see some attributes such as its species, its spatial coordinates, its height, and if we measure it, its total biomass, or leaf area.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Now if we get closer to the plant we see more details, for example we can now see the dominant axes of the plant (Fig. 2b). This is a new scale of description, let's say the axis scale. We can measure new attributes at this scale such as the biomass or total leaf area of each axis for example.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"If we get closer again, each axis can be described with more details, and we can now differentiate each phytomer (Fig. 2c), i.e. the compound of the leaf and the internode. This is a new scale again, and attributes can be associated to each metamer, for example its length, diameter, biomass, leaf area or volume.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: A grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 2. A grass plant described at three different scales: (a) the plant, (b) the axis and (c) the phytomer. The corresponding MTG graph (mono-scale) is shown on the right of each description.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Figure 2 shows a different graph for each scale used for the description, but we can join all scales into a single MTG instead. In the MTG, all scales live together in the same data structure. The elementary object is called a node. The nodes are denoted by the little circles in Figure 2. There is one node for the plant scale (Fig. 2a), two nodes for the axis because there are two tillers (Fig. 2b), and six nodes for the phytomers, one for each (Fig. 2c).","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The resulting MTG describing all scales at once in the same graph can be represented as follows:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"(Image: MTG of a grass plant described at different scales)","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Fig. 3. Multi-scale Tree Graph of a grass plant described at three different scales: the plant (P), the axis (A) and the phytomer (I).","category":"page"},{"location":"the_mtg/mtg_concept/#Node-MTG-and-attributes","page":"Concept","title":"Node MTG and attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Each node, represented as circles in Figure 2 & 3, is described by a set of informations. These informations include the node scale, its symbol and index, its parent and the type of connection -or link- they share, a list of children and some attributes.","category":"page"},{"location":"the_mtg/mtg_concept/#The-scale","page":"Concept","title":"The scale","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"We already talked about the node scale above, it is defined by an integer used to describe the level of description of the object. Usually the value of the scale is 0 for the first node, and increase going towards the finer descriptions. In our example MTG, the plant would be of scale 0, the axes of scale 1 and the phytomers of scale 2.","category":"page"},{"location":"the_mtg/mtg_concept/#The-symbol","page":"Concept","title":"The symbol","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The symbol is used as a name for the type of nodes used in the MTG. In our example MTG in Figure 2 & 3 we had the Plant, the Axis and the Phytomer. A symbol can be present at one scale only, but several symbols can be used in the same scale.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"For example we could add a finer scale of description to our example MTG: the organ scale. At this scale we would have at least three different types of organs: the leaf, the internode and the inflorescence. Each one would share the same scale (i.e. Organ -> scale 3), but would have a different name for their symbol.","category":"page"},{"location":"the_mtg/mtg_concept/#The-index","page":"Concept","title":"The index","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"The index of a node is an integer with a completely free value. It is generally used by the user to e.g. keep track of the count of nodes or the branching order. In our example MTG, we incremented our phytomers one by one, but we could start our numbering for each axis for example, allowing us to keep track rapidly of how many phytomers there are in each axis.","category":"page"},{"location":"the_mtg/mtg_concept/#Links","page":"Concept","title":"Links","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Like any other tree graph, each node in an MTG keeps track of which node is its parent, and which are its children. One originality of the MTG is having the choice of using three different types of links between a node and its parent:","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"decomposition (/): this link is used when the node decomposes its parent, meaning it has a different scale. For example in Figure 3 the first axis node (A1) decomposes the Plant node (P1).\nfollow (<): it is used when a node follows its parent node with the same scale. In Figure 3, the second phytomer (I3) of the first axis (A1) follows the first one (I1).\nbranch (+): the node branches from its parent. In Figure 3, the second axis (A2) branches from the first phytomer (A1) of the first axis (A1) of the plant.","category":"page"},{"location":"the_mtg/mtg_concept/#Attributes","page":"Concept","title":"Attributes","text":"","category":"section"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"Attributes are used to attach data about a node. The MTG standard for the .mtg file format specifies that attributes can be of type integer, real or character only. But in Julia it is also possible to use any type (e.g. a DataFrame, a user type...). As soon as you don't plan to write it to the disk it is completely fine.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"note: Note\nMultiScaleTreeGraph.jl does not check if the attributes are in the correct format when writing to disk. The user should check before writing. This is because the package allows all types for attribues, so we cannot filter on type.","category":"page"},{"location":"the_mtg/mtg_concept/","page":"Concept","title":"Concept","text":"[1]: The SVG was made by Kelvin13 and found on Wikimedia.","category":"page"},{"location":"tutorials/3.transform_mtg/#Transform-an-MTG","page":"Transform an MTG","title":"Transform an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/3.transform_mtg/#A-note-on-anonymous-functions","page":"Transform an MTG","title":"A note on anonymous functions","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"A lot of examples in this tutorial use anonymous functions. These functions are just a way to quickly define a function. For example a function that adds 1 to its input argument would usually be declared as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"function plus_one(x)\n    x + 1\nend","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we have a name for our function: \"plus_one\". But sometimes we don't need to name our function because its only usage is to be passed to another function. In this case we can declare an anonymous function like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"x -> x + 1","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This is exactly the same function, but without a name.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nWe use x here because it is more or less of a standard, but we could use any other argument name. You'll see that we use node instead when referring to an MTG node (node -> node.name), and x when we refer to a node attribute (x -> x + 1).","category":"page"},{"location":"tutorials/3.transform_mtg/#Introduction-to-MTG-transforming","page":"Transform an MTG","title":"Introduction to MTG transforming","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"MTGs can be very large, and it quickly becomes impossible to manually change the attribute values of the nodes.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Instead, you can compute new attributes for all nodes in an MTG using transform!.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The syntax of transform! is very close to the one from DataFrames.jl. It has several forms that allow to perform computations either on the node or the node attributes directly.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here is a summary of the different forms you can use:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"a :var_name => :new_var_name pair. This form is used to rename an attribute name\na :var_name => function => :new_var_name or [:var_name1, :var_name2...] => function => :new_var_name. The variables are declared as a Symbol or a String (or a vector of), and they are passed as positional arguments to function. The new variable name is optional, and is automatically generated if not provided by concatenating the source column name(s) and the function name if any, this form would be used as: :var_name => function.\na function => :new_var_name form that applies a function to a node and puts the results in a new attribute. This form is usually applied when searching ancestors or descendants values.\na function form that applies a mutating function to a node, without expecting any output. This form is used when using a function that already mutates the node, without the need to return anything, e.g. branching_order!.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This tutorial is a deep dive into these different forms.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nAll examples use the mutating version transform!, but there is a non-mutating version too (transform). It is used likewise but returns a modified copy of the mtg, which is a little bit slower.","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-1:-Rename-an-attribute","page":"Transform an MTG","title":"Form 1: Rename an attribute","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Renaming an attribute in an MTG is very simple. It uses the exact same syntax as DataFrames.jl. First, let's check which attributes are available in the MTG:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"get_attributes(mtg)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's rename :Width to remove the capital letter and make it all lowercase:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Width => :width)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's check if the attribute name changed:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"print(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Yes it did!","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The equivalent call with the non-mutating version of transform is:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"new_mtg = transform(mtg, :Width => :width)\n\nprint(get_attributes(new_mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-2:-Compute-new-attributes-based-on-other-attributes","page":"Transform an MTG","title":"Form 2: Compute new attributes based on other attributes","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also compute a new attribute based on another one. For example we could need the length in meters instead of centimetres. To do so, we can compute it as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => (x -> x / 10) => :length_m, ignore_nothing = true)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The magic happens in the :Length => (x -> x / 10) => :length_m expression. transform! takes the :Length variable as input (LHS, Left-hand side of the expression), and use it as the argument for the anonymous function given in the middle of the expression: x -> x / 10. Then it puts the output of the function into a new variable named :length_m (RHS, Right-hand side of the expression)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"In fewer words, we divide the :Length attribute by 10 for every node in the MTG, and put the results in a new attribute called :length_m.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We use ignore_nothing = true to tell transform! not to process the nodes with a value of nothing for the input variable (:Length). Otherwise our computation would error because the function we use do not handle nothing values well: nothing / 10 returns an error.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"warning: Warning\nThe anonymous function must be surrounded by parenthesis (like in DataFrames.jl)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's check if we can find :length_m in the list of our MTG attributes:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"print(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also get its values by using descendants on the root node:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"descendants(mtg, :length_m)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also get the values in the form of a DataFrame instead:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"DataFrame(mtg, :length_m)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also provide several input variables if we need:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, [:Length, :width] => ((x,y) -> π * x * y^2) => :volume_cm3, ignore_nothing = true)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we provide the input attributes as a Vector of Symbols (could be String also), and given them to an anonymous function that takes two arguments as inputs. Our attributes are given to the anonymous function in order, i.e positional arguments. Then we name our new attribute :volume_cm3. Again, we use ignore_nothing = true to remove the nodes with nothing values for the input attributes :Length and :width.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Let's see the results:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"DataFrame(mtg, [:Length, :width, :volume_cm3])","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The new name of the attribute (the RHS) is optional though. We could write our first example as:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => (x -> x / 10), ignore_nothing = true)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"In this case the name of the new attribute is automatically computed based on the input variable name and the name of the function. If the function is anonymous, which is the case in our example, it uses the default \"function\" name instead. Our new variable name is then called :Length_function.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"If we used a function with a name such as log instead of an anonymous function, the new attribute name would be :Length_log. Here's an example with the log function:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, :Length => log, ignore_nothing = true)\n\nprint(get_attributes(mtg))","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-3:-Compute-a-new-attribute-based-on-node-values","page":"Transform an MTG","title":"Form 3: Compute a new attribute based on node values","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can compute a new attribute by providing a function directly as the right-hand side instead of an attribute name like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, symbol => :Symbol)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The symbol function takes a node as its first (and only) argument, and returns its symbol. An alternative way of writing this would be:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, node -> symbol(node) => :Symbol)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This particularly useful when we need to compute a new attribute based on the values of the node itself.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we just copied the MTG symbol onto the attributes of the nodes. In this form, it is mandatory to provide a name for the newly created variable, else the function is considered to not return anything (see next form: Form 4: Apply a function to nodes).","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Because this form expects a function that works on nodes directly, it is now possible to use the descendants and ancestors functions. For example we can compute the total length of the subtree of each node in an MTG (i.e. the length of all children of a node) as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"function get_length_descendants(x)\n    nodes_lengths = descendants(x, :Length, ignore_nothing = true)\n    if length(nodes_lengths) == 0\n        return nothing\n    else\n        return sum(nodes_lengths)\n    end\nend\n\ntransform!(mtg, get_length_descendants => :length_subtree)\n\ndescendants(mtg, :length_subtree)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nThis form cannot use ignore_nothing = true because it does not know which attributes to look for before-hand. You'll have to use the filter_fun argument or handle nothing values inside your function instead.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Here we first declared a new function to get the length of all descendants of a node (get_length_descendants), and then compute the sum only if one or more values for length were found. Then we pass this function to transform! and define our new attribute name as :length_subtree. We define the function first for clarity because it needs to handle nothing values properly before the call to sum.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"An alternative way to write this would be to first get the vector of length for each node, and then to compute the sum like so:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(\n    mtg,\n    (node -> descendants(node, :Length, ignore_nothing = true)) => :length_subtree2,\n    :length_subtree2 => (x -> length(x) == 0 ? nothing : sum(x)) => :length_subtree2\n)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Because transform! computes the expressions sequentially, we can re-use a computation from the last expression. This is exactly what we are doing here. First we get the values of the length of all descendants of each node, and put the result in a new attribute :length_subtree2. Then we re-use the data from this attribute to compute its sum, but only if the length of the data is not 0, and put the result back to the same attribute :length_subtree2.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can test if both calls returns the same output:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"all(descendants(mtg, :length_subtree2) .== descendants(mtg, :length_subtree))","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Yes they are!","category":"page"},{"location":"tutorials/3.transform_mtg/#Form-4:-Apply-a-function-to-nodes","page":"Transform an MTG","title":"Form 4: Apply a function to nodes","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also apply a function that performs a computation on the node like Form 3, but does not return a new attribute value. For example it can be useful to use a printing function to help us debug another function call. Here's an example where we want to print the name of the nodes that are leaf nodes:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, node -> isleaf(node) ? println(node.name,\" is a leaf\") : nothing)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We can also use this form to mutate the MTG of a node (which is not possible with Form 2). Here's an example where we change the \"Internode\" symbol into \"I\":","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform!(mtg, node -> symbol!(node, \"I\"), symbol = \"Internode\")\n\nmtg","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"note: Note\nIf you change the values of the MTG field of the nodes, you can update the header of the MTG stored in the root node. For example here we updated the symbols, so we should do:mtg[:symbols] = get_classes(mtg).SYMBOL\nmtg[:description] = get_description(mtg)Note that it is not important for writing back to disc as they are automatically updated anyway.","category":"page"},{"location":"tutorials/3.transform_mtg/#Select-an-MTG","page":"Transform an MTG","title":"Select an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"As in DataFrames, MultiScaleTreeGraph.jl provides a select! function for deleting all attributes not explicitly provided as arguments to the selection. The selection can also apply transformations on the fly following the same format used in transform!, with one more Form though: just the name of the variable to select.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"For example we can compute the new length in meters, and keep only this result along with the width as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"mtg_select = deepcopy(mtg)\n\nselect!(mtg_select, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\nDataFrame(mtg_select)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"There is also a non-mutating version of the function:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"mtg_select = select(mtg, :Length => (x -> x / 10) => :length_m, :Width, ignore_nothing = true)\n\nDataFrame(mtg_select)","category":"page"},{"location":"tutorials/3.transform_mtg/#Traverse-an-MTG","page":"Transform an MTG","title":"Traverse an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"transform! and select! use traverse! under the hood to apply a function call to each node of an MTG. traverse! is just a little bit less easy to use as it only accepts Form 4. We can obtain the exact same results as the last example of transform! using the same call with traverse!. Let's change the Leaf symbol into L:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"traverse!(mtg, node -> symbol!(node, \"L\"), symbol = \"Leaf\")\n\nmtg","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"A benefit of traverse! is it can be used with a do...end block notation for complex sets of instructions:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"traverse!(mtg) do x\n    if isleaf(x)\n         println(x.name,\" is a leaf\")\n    end\nend","category":"page"},{"location":"tutorials/3.transform_mtg/#Mutate-an-MTG","page":"Transform an MTG","title":"Mutate an MTG","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"For users coming from R, we also provide the @mutate_mtg! macro that is similar to transform! but uses a more tidyverse-alike syntax. All values coming from the MTG node must be preceded by a node., as with the .data$ in the tidyverse. The names of the attributes are shortened to just node.attr_name instead of node_attributes(node).attr_name though. Here's an example usage:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"@mutate_mtg!(mtg, volume = π * 2 * node.Length, symbol = \"I\")","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"We see that we first name the new attribute and assign the result of the computation. Constants are provided as is, and values coming from the nodes are prefixes by node..","category":"page"},{"location":"tutorials/3.transform_mtg/#Helpers","page":"Transform an MTG","title":"Helpers","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"You can use helper functions provided by MultiScaleTreeGraph.jl for:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"Filtering nodes: isroot, isleaf\nCompute the number of leaf nodes in the subtree of a node: nleaves\nApply the pipe_model! to the MTG to compute the cross-section of all nodes based on an initial cross-section.","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"The pipe model is used in plant physiology (especially on trees) and is built around the coarse hypothesis that each leaf in a plant is (to some extent) connected to the roots via a \"pipe\" of constant cross-sectional area. The concepts of the pipe model are detailed in Lehnebach et al. (2018).","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"This package provides an implementation of the pipe model, used as follows:","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"first_cross_section = 0.34 # the initial cross-section of the plant\n\ntransform!(mtg, (node -> pipe_model!(node, first_cross_section)) => :cross_section_pipe)\nDataFrame(mtg, :cross_section_pipe)","category":"page"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"For more information about the implementation, you can check the documentation of the function: pipe_model!.","category":"page"},{"location":"tutorials/3.transform_mtg/#References","page":"Transform an MTG","title":"References","text":"","category":"section"},{"location":"tutorials/3.transform_mtg/","page":"Transform an MTG","title":"Transform an MTG","text":"R. Lehnebach, R. Beyer, V. Letort, et P. Heuret, « The pipe model theory half a century on: a review », Annals of Botany, vol. 121, nᵒ 5, p. 773‑795, avr. 2018, doi: 10.1093/aob/mcx194.","category":"page"},{"location":"get_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"get_started/#Introduction","page":"Getting started","title":"Introduction","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"This page let's you take a peek at what the package is capable of. If you want a better, more in-depth introduction to the package, take a look at the tutorials, starting from Read and Write MTGs. If you don't know what an MTG is, you can read more about starting from The MTG concept.","category":"page"},{"location":"get_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You must have a working Julia installation on your computer. The version of Julia should be greater than 1.3.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"If you want to install Julia for the first time, you can download it frome julialang.org. If you want a little introduction on Julia + VSCode, you can check out this video.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can install the latest stable version of MultiScaleTreeGraph.jl using this command:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"]add MultiScaleTreeGraph","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"note: Note\nThe ] is used to enter the package mode in the REPL.","category":"page"},{"location":"get_started/#Example","page":"Getting started","title":"Example","text":"","category":"section"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Read a simple MTG file:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can compute new variables in the MTG using transform!:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"transform!(mtg, :Length => (x -> isnothing(x) ? nothing : x * 1000.) => :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"The design of transform! is heavily inspired from the eponym function from DataFrame.jl, with little tweaks for MTGs.","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can see the newly-computed attributes using descendants like so:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"descendants(mtg, :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Or by transforming your MTG into a DataFrame:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"DataFrame(mtg, :length_mm)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"Then you can write the MTG back to disk like so:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"write_mtg(\"test.mtg\",mtg)","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"You can also convert your MTG to a MetaGraph:","category":"page"},{"location":"get_started/","page":"Getting started","title":"Getting started","text":"MetaGraph(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/#Accessing-node-data","page":"Accessing node data","title":"Accessing node data","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/#Read-an-MTG-file","page":"Accessing node data","title":"Read an MTG file","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"Let's first read a simple MTG file:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"node: Node\nIf you print a node, it will always print its subtree. So if we print the root node it will print the entire MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"read_mtg returns a Node object.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"typeof(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"This node is the root node of the MTG, meaning the first node of the MTG, the one without any parent.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"note: Note\nRoot node and leaf node mean a node without any parent or children respectively. These terms are used in the sense of a tree data structure.","category":"page"},{"location":"tutorials/1.manipulate_node/#The-Node-type","page":"Accessing node data","title":"The Node type","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/#What's-a-node?","page":"Accessing node data","title":"What's a node?","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"As we learned in the previous section, the node is used as the elementary object to build the MTG. In this package, a node is a data structure used to hold these informations (i.e. fields). See the MTG implementation section for more details.","category":"page"},{"location":"tutorials/1.manipulate_node/#Access-the-fields-of-a-node","page":"Accessing node data","title":"Access the fields of a node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"The first node of the whole MTG is all we need to access every other nodes in the MTG, because they are all linked together.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"You can list the fields in a node like so:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"fieldnames(typeof(mtg))","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"These fields are considered internal to the package, and are not meant to be accessed directly like so. In any case, you can still access them using the getfield function, e.g.:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"getfield(mtg, :MTG)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"But the preferred way for accessing such values is to use the accessor functions provided by the package: parent, children, node_attributes, node_mtg, node_id.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"So to get the values of the attributes (i.e. the variables), you can use:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"node_attributes(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"The MTG field from the node helps us describe the node within the MTG. Let's see what's in it:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"node_mtg(mtg) |> typeof |> fieldnames","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"We see that it holds the MTG fields: the scale, symbol, index and link to its parent.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"The package also provide helper functions to access the MTG encoding of the node directly: symbol, scale, index and link.","category":"page"},{"location":"tutorials/1.manipulate_node/#Update-the-node","page":"Accessing node data","title":"Update the node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"Similarly, we can update the fields of a node using the setting functions provided by the package: reparent!, rechildren!. ","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"The package also provides updating functions for the MTG encoding of the node directly: symbol!, scale!, index! and link!.","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"note: Note\nThere is no setting function for the attributes or the node id because they are not meant to be updated directly. The attribute structure shouldn't change, only its content should (see next paragraph). The node id is unique in the MTG, so it should never change.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-other-nodes","page":"Accessing node data","title":"Get other nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"We can move from node to node in the MTG graph because we know every node parent and children. ","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-children-nodes","page":"Accessing node data","title":"Get children nodes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"To get the children of a node, you can use the children function:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"children(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"You can also also index the node using an integer, and it will return the corresponding child (1 for the first child, 2 for the second, etc.):","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"mtg[1]","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"We can iteratively index into the nodes to access the descendants of a node. For example if we need to access the 6th node (the 2nd Internode), we would do:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"node_6 = mtg[1][1][1][2]","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-parent-node","page":"Accessing node data","title":"Get the parent node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"To get the parent you can use:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"parent(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"Note that it returns nothing here because the root node has no parent.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-node-siblings","page":"Accessing node data","title":"Get the node siblings","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"To get the node siblings:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"siblings(mtg[1][1][1][1])","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"note: Note\nWe repeatedly index into the MTG (mtg[1][1][1][1]) to get the fourth generation descendant of the root node, because it is the only one with a sibling in our example MTG.","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-any-node","page":"Accessing node data","title":"Get any node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"To get any node in the MTG, you can get it by its id:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"get_node(mtg, 3)","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"You can list all node ids using list_nodes:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"list_nodes(mtg)","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-root-node","page":"Accessing node data","title":"Get the root node","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"To get the root node from any other node, simply use get_root:","category":"page"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"node_5 = get_node(mtg, 5)\n\nget_root(node_5)","category":"page"},{"location":"tutorials/1.manipulate_node/#Get-the-attributes","page":"Accessing node data","title":"Get the attributes","text":"","category":"section"},{"location":"tutorials/1.manipulate_node/","page":"Accessing node data","title":"Accessing node data","text":"This section has its own tutorial! Head over the next page to learn how to get the nodes attributes.","category":"page"},{"location":"the_mtg/our_implementation/#MTG-implementation","page":"Our implementation","title":"MTG implementation","text":"","category":"section"},{"location":"the_mtg/our_implementation/#Introduction","page":"Our implementation","title":"Introduction","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode_6 = get_node(mtg, 6)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"In this package, the MTG is represented as a tree data structure.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The tree is built from a series of nodes with different fields that describe the topology (i.e. how nodes are connected together) and the attributes of the node.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe package use terms from computer science rather than plant biology. So we use words such as \"root\" in an MTG, which is not the plant root, but the first node in the tree, i.e. the one without any parent. Similarly a leaf node is not a leaf from a plant but a node without any children.","category":"page"},{"location":"the_mtg/our_implementation/#Data-types","page":"Our implementation","title":"Data types","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The nodes have their own data type called Node. A Node has several fields:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(Node)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Here is a little description of each field:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"name: The name of the node. It is completely free, but is usually set automatically when reading the MTG. The automatic name is based on the id of the node in the MTG, e.g. \"node_1\" for the first node.\nid: The unique integer identifier of the node. It can be set by the user but is usually set automatically.\nparent: The parent node of the curent node. If the curent node is the root node, it will return nothing. You can test whether a node is a root node sing the isroot function.\nchildren: a dictionary of the children nodes with their id as key, or nothing if none;\nMTG: The MTG encoding of the node (see below, or NodeMTG)\nattributes: the node attributes. Usually a NamedTuple, a MutableNamedTuple or a Dict or similar (e.g. OrderedDict), but the type is optional. The choice of the data structure depends mainly on how much you plan to change the attributes and their values. Attributes include for example the length or diameter of a node, its colour, 3d position...\ntraversal_cache: a cache for the traversal, used by e.g. traverse to traverse more efficiently particular nodes in the MTG","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The value of tee fields are accessed using accessor functions: node_id, parent, children, node_mtg, node_attributes, and the last one get_traversal_cache which is not exported because users shouldn't use it directly.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The MTG field of a node describes the topology encoding of the node: its type of link with its parent (decompose: /, follow: <, and branch: +), its symbol, index, and scale (see Node MTG and attributes and The MTG section for more details). The MTG field must be encoded in a data structure called NodeMTG or in a MutableNodeMTG. They have four fields corresponding to the topology encoding:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"fieldnames(NodeMTG)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Creating a NodeMTG is very simple, just pass the arguments by position. For example if we have an Axis that decomposes its parent node (\"/\"), with an index 0 and a scale of 1, we would declare it as follows:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"axis_mtg_encoding = NodeMTG(\"/\", \"Axis\", 0, 1)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The we can access the data using the dot syntax:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"axis_mtg_encoding.symbol","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nNodeMTG is the immutable data type, meaning that information cannot be changed once read. By default the package the mutable equivalent called MutableNodeMTG. Accessing the information of a mutable data structure is slower, but it is more convenient if we need to change its values.","category":"page"},{"location":"the_mtg/our_implementation/#Learning-by-example","page":"Our implementation","title":"Learning by example","text":"","category":"section"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"Let's print again the example MTG from the previous section:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nprintln(read(file, String))","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can use read_mtg from MultiScaleTreeGraph.jl to read this MTG:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"read_mtg returns the first node of the MTG, of type Node:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"typeof(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"note: Note\nThe Node is a parametric type, that's why typeof(mtg) also returns the type used for the MTG data in the node (MutableNodeMTG) and the type used for the attributes (Dict{Symbol, Any}). But this is not important here.","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"We can access the fields of the node using the accessor functions:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_id(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"parent(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"This one returns nothing because the node is the root node, it has no parent, but we could use it on its child, and it would return the root again:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"mtg_child = mtg[1]\nparent(mtg_child) == mtg","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"children(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_mtg(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"node_attributes(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"The package also provide helper functions to access the MTG encoding of the node directly:","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"symbol(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"index(mtg)","category":"page"},{"location":"the_mtg/our_implementation/","page":"Our implementation","title":"Our implementation","text":"scale(mtg)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Node-attributes","page":"Node attributes","title":"Node attributes","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"using MultiScaleTreeGraph\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Get-attributes-of-a-node","page":"Node attributes","title":"Get attributes of a node","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Let's first read our example MTG:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"using MultiScaleTreeGraph\n\nfile = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"You can get all the attributes of a node using the node_attributes function:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_attributes(mtg)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"note: Note\nThe attributes of the root node always include the data from the header sections of an MTG file: the scales of the MTG, the description and the symbols. You can learn more in The MTG sections.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"We can also access particular attribute values by indexing into the node with a Symbol:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_5 = get_node(mtg, 5) # Get the 5th node of the MTG\n\nnode_5[:Length]","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"... or a String:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_5[\"Length\"]","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"And even with the dot notation:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_5.Length","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"This one even has autocompletion! It means that you can type node_5. and then press TAB to see all the available attributes, and when you start typing the name of an attribute, it will suggest the completion of the name.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The previous notations are both equivalent to:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_attributes(node_5)[:Length]","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"But we strongly recommend to avoid this last notation. In our case the attributes are stored in a Dictionary (Dict, the default), so we access their values using the Dict notation: node_attributes(node_5)[:Length]. But if the attributes are stored as a NamedTuple-alike structure, we must use the dot notation instead: node_attributes(node_5).Length (see Attributes type for more details). That is why the package implements the more generic node_5[:Length] notation that works with any structure used for the attributes, which helps develop more generic code.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"To get the names of all attributes available in the node subtree, you can use get_attributes:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"get_attributes(node_5)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"We also define an alias for a more DataFrame.jl-alike experience (names):","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"names(node_5)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Note that it returns only two attributes here because \"node_5\" is a leaf (a node without children), and get_attributes and names only return the attributes present in the node's subtree. To be sure to get all the attributes available in the whole MTG, it is better to call get_attributes on the root node like so:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"get_attributes(mtg)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"If you start from another node you can retrieve the root node using get_root:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"get_attributes(get_root(node_5))","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"A more simple way to get all nodes and their attributes is to convert the MTG into a DataFrame like so:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"DataFrame(mtg)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Descendants","page":"Node attributes","title":"Descendants","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"An MTG can hold a lot of information, usually measured locally at one given scale. It is often interesting to compute new attributes based on the topological environment of the nodes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"For example one could be interested in computing the total length of all nodes in a plant. To do so we must get the attributes of all descendants of a node. This is quite easy to do using MultiScaleTreeGraph.jl. For example to get the length attributes we would do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg, :Length)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The descendants function visits every children nodes recursively until finding a leaf node. It returns the values in the same order than the visited nodes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The function can also help get the nodes directly if we don't pass any attribute:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"This is useful to get more information about the nodes, like their scale, symbol, index, or link to their parent. Of course you can still get their attributes using the node_attributes function, e.g.:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_attributes.(descendants(mtg))","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Ancestors","page":"Node attributes","title":"Ancestors","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"To get the values of an attribute from the ancestors of a node, we would similarly do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"node_5 = get_node(mtg, 5)\nancestors(node_5, :Length)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filters","page":"Node attributes","title":"Filters","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Sometimes we only want the values of descendants or ancestors based on a given information. It is possible to filter out nodes based on their scale, symbol, link, or really anything by using the keyword arguments.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-scale","page":"Node attributes","title":"Filter by scale","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"For example if we want the length of all descendants of the root node of our MTG that are of scale 3 (leaves & internodes), we would simply do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg, :Length, scale = 3)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-symbol","page":"Node attributes","title":"Filter by symbol","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"If we need only the leaves, we would filter by their symbol (i.e. \"Leaf\"):","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg, :Length, symbol = \"Leaf\")","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-by-anything","page":"Node attributes","title":"Filter by anything","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"And if we want to filter depending on an arbitrary value, we can use the filter_fun argument. For example if we want the length of the nodes, but only the ones with a width greater than 1, will would do like so:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg, :Length, filter_fun = x -> x[:Width] === nothing ? false : x[:Width] > 1)","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"warning: Warning\nBy default if a node does not have an attribute, trying to get its value returns nothing. So if one uses attributes in the function passed to filter_fun, the function must handle missing values. This is what we do here by first testing if x[:Width] is nothing (in which case we return false to filter out the node), and then apply our test on the value of the node width.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"note: Note\nThe function passed to filter_fun must take a node as input, not attributes directly. This is because we want to be able to access any information the user could need.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Because filter_fun takes a node as input, we can even filter on the node's parent. Let's say for example we want the values for the :Length, but only for the nodes that are children of a an Internode that follows another node:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"descendants(mtg, :Length, filter_fun = node -> !isroot(node) && symbol(parent(node)) == \"Internode\" && link(parent(node)) == \"<\")","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"In this example it returns only one value, because there is only one node that corresponds to this criteria: The Leaf with id 7.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"We could apply the same kind of filtering on the node's children, or any combination of topological information and attributes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Note that we first test if the node is not the root node, because the root node does not have a parent. We then test if the parent's symbol is \"Internode\" and if the link is \"<\".","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Filter-helpers","page":"Node attributes","title":"Filter helpers","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"There are three other arguments to help filtering nodes.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The first one is all. It is used to stop the search for new nodes as soon as one node does not correspond to the filters the user asked for.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"It is generally used to get all nodes that have a \"follow\" link (\"<\") with their parents for example. You can find an example usage here, where we compute the index of the segment nodes (\"S\") along an axis (\"A\"), except for branching nodes, i.e. only the nodes that either decompose (\"/\") or follow (\"<\").","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The second one is the self argument. It is used to return the value of the node on which we call the function if its true, and only the ancestors / descendants if false (the default).","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The third one is the recursivity_level, that is used to control the depth of the search for the  ancestors / descendants. It is set to -1 by default, which does not apply any filter on the depth. It is generally used to get e.g. only the children values of a node (recursivity_level = 1).","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"The fourth one is ignore_nothing. It is used to not return the values of a node if it is nothing. Note that it is applied after the filter, so filter_fun still has to handle nothing values.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Transform-values","page":"Node attributes","title":"Transform values","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/#Assign-attributes-to-a-node","page":"Node attributes","title":"Assign attributes to a node","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"It is possible to change the values of attributes in a node. For example one could be interested to compute the total length of all nodes for the scene in our example MTG. In this case we can do:","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"mtg[:Length] = sum(descendants(mtg, :Length, ignore_nothing = true))","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Compute-attributes-in-an-MTG","page":"Node attributes","title":"Compute attributes in an MTG","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Now MTGs can be very large, and it quickly becomes cumbersome to manually visit each node to change its value.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Instead, you can compute new attributes for all nodes in an MTG using transform. Head to the next tutorial for more information: Transform an MTG.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/#Helpers","page":"Node attributes","title":"Helpers","text":"","category":"section"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Some helper functions can be useful when filtering nodes. For example you can use isroot to test if a node is the root node of the MTG. This is particularly useful when searching for ancestor values, but need a special treatment for the root node.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"Similarly, you can use isleaf to filter the leaf nodes of an MTG.","category":"page"},{"location":"tutorials/2.descendants_ancestors_filters/","page":"Node attributes","title":"Node attributes","text":"You also have nleaves to compute the number of leaf nodes on the sub-tree of a given node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiScaleTreeGraph","category":"page"},{"location":"#MultiScaleTreeGraph.jl","page":"Home","title":"MultiScaleTreeGraph.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultiScaleTreeGraph.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of MultiScaleTreeGraph.jl is to read, write, analyse and plot MTG (Multi-scale Tree Graph) files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Multi-Scale Tree Graph, or MTG, is a data structure used to encode a plant to describe its topology (i.e. structure) and any attributes (e.g. geometry, colours, state...). It was developed in the AMAP lab in the 90's to cope with the need of a generic yet scalable structure for plant topology and traits measurement, analysis and modelling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The format is described in details in the original paper from Godin et Caraglio (1998).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MTG format helps describe the plant at different scales at the same time. For example we can describe a plant at the scale of the organ (e.g. leaf, internode), the scale of a growth unit, the scale of the axis, the crown or even at the whole plant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can find out how to use the package on the Getting started section, or more about the MTG format in the The MTG concept.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Godin, C., et Y. Caraglio. 1998. « A Multiscale Model of Plant Topological Structures ». Journal of Theoretical Biology 191 (1): 1‑46. https://doi.org/10.1006/jtbi.1997.0561.","category":"page"}]
}
