var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MTG","category":"page"},{"location":"#MTG","page":"Home","title":"MTG","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTG.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MTG]","category":"page"},{"location":"#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T<:Union{Tuple, AbstractArray}","page":"Home","title":"DataFrames.DataFrame","text":"DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])\n\nConvert an MTG into a DataFrame.\n\nArguments\n\nmtg::Node: An mtg node (usually the root node).\nkey: The key, or attribute name. Used to list the variables that must be added to the\n\nDataFrame. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nDataFrame(mtg, :Length)\nDataFrame(mtg, [:Length, :Width])\n\n\n\n\n\n","category":"method"},{"location":"#MTG.AbstractNodeMTG","page":"Home","title":"MTG.AbstractNodeMTG","text":"Abstract supertype for all types describing the MTG coding for a node.\n\nSee NodeMTG and MutableNodeMTG for examples of implementation.\n\n\n\n\n\n","category":"type"},{"location":"#MTG.NodeMTG","page":"Home","title":"MTG.NodeMTG","text":"NodeMTG(link, symbol, index, scale)\nMutableNodeMTG(link, symbol, index, scale)\n\nNodeMTG structure\n\nBuilds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.\n\nNote\n\nThe symbol should match the possible values listed in the SYMBOL column of the CLASSES section\n\nin the mtg file if read from a file.\n\nThe index is totaly free, and can be used as a way to e.g. keep track of the branching order.\n\nNodeMTG(\"<\", \"Leaf\", 2, 0)\n\n\n\n\n\n","category":"type"},{"location":"#Base.append!-Union{Tuple{T}, Tuple{M}, Tuple{Node{M, T}, Any}} where {M<:AbstractNodeMTG, T<:MutableNamedTuples.MutableNamedTuple}","page":"Home","title":"Base.append!","text":"append!(node::Node{M<:AbstractNodeMTG, <:MutableNamedTuple}, attr)\nappend!(node::Node{M<:AbstractNodeMTG, <:Dict}, attr)\n\nAppend new attributes to a node attributes.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{Node, Any}","page":"Home","title":"Base.getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"]\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{Node, Integer}","page":"Home","title":"Base.getindex","text":"Indexing a Node using an integer will index in its children\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Node}","page":"Home","title":"Base.length","text":"Returns the length of the subtree below the node (including it)\n\n\n\n\n\n","category":"method"},{"location":"#Base.print-Tuple{Node}","page":"Home","title":"Base.print","text":"Print a node to io using an UTF-8 formatted representation of the tree. Most of the code from DataTrees.jl\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nmtg\n# / 1: $\n# └─ / 2: Individual\n#    └─ / 3: Axis\n#       └─ / 4: Internode\n#          ├─ + 5: Leaf\n#          └─ < 6: Internode\n#             └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"#MTG.addchild!-Union{Tuple{M}, Tuple{Node, String, M, Any}} where M<:AbstractNodeMTG","page":"Home","title":"MTG.addchild!","text":"Add a new child to a parent node, and add the parent node as the parent.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.ancestors-Tuple{Any, Any}","page":"Home","title":"MTG.ancestors","text":"ancestors(node::Node,key,<keyword arguments>)\n\nGet attribute values from the ancestors (basipetal).\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the parent only: recursivity_level = 1, for parent + grand-parent: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the root.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing an example mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Using a leaf node from the mtg:\nleaf_node = mtg.children[\"node_2\"].children[\"node_3\"].children[\"node_4\"].children[\"node_5\"]\n\nancestors(leaf_node, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\nancestors(leaf_node, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\nancestors(leaf_node, :XX, scale = 1, type = Float64)\nancestors(leaf_node, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\nancestors(leaf_node, :Length, symbol = \"Internode\")\nancestors(leaf_node, :Length, symbol = (\"Axis\",\"Internode\"))\n\n\n\n\n\n","category":"method"},{"location":"#MTG.check_filters-Union{Tuple{Any}, Tuple{T}} where T","page":"Home","title":"MTG.check_filters","text":"check_filters(node; scale = nothing, symbol = nothing, link = nothing)\n\nCheck if the filters are consistant with the mtg onto which they are applied\n\nExamples\n\ncheck_filters(mtg, scale = 1)\ncheck_filters(mtg, scale = (1,2))\ncheck_filters(mtg, scale = (1,2), symbol = \"Leaf\", link = \"<\")\n\n\n\n\n\n","category":"method"},{"location":"#MTG.children-Tuple{Node}","page":"Home","title":"MTG.children","text":"children(node::Node)\n\nReturn the immediate children of node.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.clean_cache!-Tuple{Any}","page":"Home","title":"MTG.clean_cache!","text":"clean_cache!(mtg)\n\nClean the cached variables in the mtg, usually added from descendants!.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.delete_node!-Tuple{Any}","page":"Home","title":"MTG.delete_node!","text":"delete_node!(node)\n\nDelete a node and re-parent the children to its own parent. If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.\n\nThe function returns the parent node (or the new root if the node is a root)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.delete_nodes!-Tuple{Any}","page":"Home","title":"MTG.delete_nodes!","text":"delete_nodes!(mtg::Node,<keyword arguments>)\n\nDelete nodes in mtg following filters rules.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale to delete. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to delete. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to delete. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first deletion (true), or stop?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf\n\nto decide whether to delete a node or not.\n\nNotes\n\nThe function is acropetal, meaning it will apply the deletion from leaves to the root to ensure\n\nthat one pass is enough and we don't repeat the process of visiting already visited children.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ndeleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.\n\nThe package provides some pre-made functions for filtering. See for example is_segment!\n\nto re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\ndelete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2\n\n# Delete the leaves:\ndelete_nodes!(mtg, symbol = \"Leaf\")\n# Delete the leaves and internodes:\ndelete_nodes!(mtg, symbol = (\"Leaf\",\"Internode\"))\n\n# Make the mtg match field measurements made only at branching points for the scales 1 + 2:\nmtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.descendants","page":"Home","title":"MTG.descendants","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"#MTG.descendants!","page":"Home","title":"MTG.descendants!","text":"descendants(node::Node,key,<keyword arguments>)\ndescendants!(node::Node,key,<keyword arguments>)\n\nGet attribute values from the descendants (acropetal). The mutating version (descendants!) cache the results in a cached variable named after the hash of the function call. This version is way faster for large trees, but require to clean the chache sometimes (see clean_cache!). It also only works for trees with attributes of subtype of AbstractDict.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\nkey: The key, or attribute name. Make it a Symbol for faster computation time.\n\nKeyword Arguments\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nself = false: is the value for the current node needed ?\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\nrecursivity_level = -1: The maximum number of recursions allowed (considering filters).\n\nE.g. to get the first level children only: recursivity_level = 1, for children + grand-children: recursivity_level = 2. If a negative value is provided (the default), the function returns all valid values from the node to the leaves.\n\ntype::Union{Union,DataType}: The type of the attribute. Makes the function run much\n\nfaster if provided (≈4x faster).\n\nTips\n\nTo get the values of the leaves use isleaf as the filtering function, e.g.: descendants(mtg, :Width; filter_fun = isleaf).\n\nNote\n\nIn most cases, the type argument should be given as a union of Nothing and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\ndescendants(mtg, :Length) # Short to write, but slower to execute\n\n# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes\n# without a `Length` attribute:\ndescendants(mtg, :Length, type = Union{Nothing,Float64})\n\n# Filter by scale:\ndescendants(mtg, :XX, scale = 1, type = Float64)\ndescendants(mtg, :Length, scale = 3, type = Float64)\n\n# Filter by symbol:\ndescendants(mtg, :Length, symbol = \"Leaf\")\ndescendants(mtg, :Length, symbol = (\"Leaf\",\"Internode\"))\n\n# Filter by function, e.g. get the values for the leaves only:\ndescendants(mtg, :Width; filter_fun = isleaf)\n\n# It is possible to cache the results in the mtg. This is wqy faster when using\n# `@mutate_mtg` (note the `!` at the end of the function name):\n@mutate_mtg!(mtg, subtree_length = sum(descendants!(node, :Length, symbol = \"Internode\")), symbol = \"Internode\")\n\nfunction compute_subtree_length(x)\n    length_descendants = filter(x -> x !== nothing, descendants(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? sum(length_descendants) : nothing\nend\n\nfunction compute_subtree_length!(x)\n    length_descendants = filter(x -> x !== nothing, descendants!(x, :Length, symbol = \"Internode\", self = true))\n    length(length_descendants) > 0 ? length_descendants : nothing\nend\n\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length(node), symbol = \"Internode\")\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n@mutate_mtg!(mtg, subtree_length = compute_subtree_length!(node))\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ncompute_subtree_length!(mtg)\nDataFrame(mtg, [:Length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\n\n# You can then clean the cach to avoid using too much memory:\nclean_cache!(mtg)\nmtg[1][1][1].attributes\nmtg[1][1][1][2].attributes\nDataFrame(mtg, [:Length, :subtree_length])\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nnode = mtg\nkey = :Length\nscale = nothing\nsymbol = nothing\nlink = nothing\nall= true\nself = false\nfilter_fun = nothing\nrecursivity_level = -1\ntype = Any\n\n# compute_subtree_length!(mtg)\n\ndescendants!(mtg, :Length, self = true)\nDataFrame(mtg, [:Length, :subtree_length, :_cache_9011cfa452383c48086b78014718eeebab7b12b9])\nDataFrame(mtg, [:Length, :subtree_length, :_cache_403abd80258f45cfa2a64226edcf3c39c44a3302])\n\n\n\n\n\n\n\n","category":"function"},{"location":"#MTG.descendants_!-NTuple{10, Any}","page":"Home","title":"MTG.descendants_!","text":"Fast version of descendants_ that mutates the mtg nodes to cache the information.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.expand_node!-Tuple{Any, Any}","page":"Home","title":"MTG.expand_node!","text":"Expand MTG line\n\nExpand the elements denoted by the syntactic sugar \"<<\", \"<.<\", \"++\" or \"+.+\"\n\nArguments\n\nx::Array{String}: A split MTG line (e.g. c(\"/P1\",\"/A1\"))\nline::Array{Int64,1}: The current line index (mutated) in the file. Only\n\nused as information when erroring.\n\nReturns\n\nA Tuple of:\n\nthe split MTG line with all nodes explicitly\nthe nodes with common attributes (when using <.< or +.+)\n\nExamples\n\nx = split(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\",r\"(?<=.)(?=[</+])\");\nnodes, shared = MTG.expand_node!(x,1)\n(AbstractString[\"/A1\", \"+U85\", \"/U86\", \"<U87\", \"<U88\", \"<U89\", \"<U90\", \"<U91\", \"<U92\", \"<U93\", \"<U94\", \"<U95\", \"<U96\", \"<U97\", \"+U98\", \"+U99\", \"+U100\"], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_classes-Tuple{Any}","page":"Home","title":"MTG.get_classes","text":"get_classes(mtg)\n\nCompute the mtg classes based on its content. Usefull after having mutating the mtg nodes.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_description-Tuple{Any}","page":"Home","title":"MTG.get_description","text":"get_description(mtg)\n\nReturns nothing, because we can't really predict the description section from an mtg.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_features-Tuple{Any}","page":"Home","title":"MTG.get_features","text":"get_features(mtg)\n\nCompute the mtg features based on its attributes. Usefull after having computed new attributes in the mtg.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_leading_tabs-Tuple{Any}","page":"Home","title":"MTG.get_leading_tabs","text":"get_leading_tabs(node)\n\nGet the number of tabulation the node should have when writting it to a file based on the topology of its parent.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_printing-Tuple{Node}","page":"Home","title":"MTG.get_printing","text":"get_printing(node::Node; leading::AbstractString = \"\")\n\nFormat the printing of the tree according to link: follow or branching\n\n\n\n\n\n","category":"method"},{"location":"#MTG.get_reference-Tuple{Any}","page":"Home","title":"MTG.get_reference","text":"get_reference(node)\n\nGet the preceding \"^\" keyword if needed, i.e. in case we refer to the parent node in the same mtg file column.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.getroot-Tuple{Node}","page":"Home","title":"MTG.getroot","text":"Find the root node of a tree, given any node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.insert_node!-Tuple{Any, Any, Any}","page":"Home","title":"MTG.insert_node!","text":"insert_node!(node, template, max_id)\n\nInsert a node as the new parent of node.\n\nArguments\n\nnode::Node: The node at which to insert a node as a parent.\ntemplate::Node: A template node used as the inserted nodes.\nmax_id::Vector{Int64}: The maximum id of the mtg as a vector of 1 value, used to compute\n\nthe name of the inserted node. It is incremented in the function.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\ntemplate = MTG.MutableNodeMTG(\"/\", \"Shoot\", 0, 1)\nmax_id = parse(Int, MTG.max_name(mtg)[6:end])\nmtg = insert_node!(mtg[1][1], template, max_id)\nmtg\n\n\n\n\n\n","category":"method"},{"location":"#MTG.insert_nodes!-Tuple{Any, Any}","page":"Home","title":"MTG.insert_nodes!","text":"insert_nodes!(mtg::Node,template,<keyword arguments>)\n\nInsert new nodes in the mtg following filters rules. It is important to note that it always return the root node, whether it is the old one or a new inserted one, so the user is encouraged to assign the results to an object.\n\nArguments\n\nMandatory arguments\n\nnode::Node: The node to start at.\ntemplate::Node: A template node used for all inserted nodes.\n\nKeyword Arguments (filters)\n\nscale = nothing: The scale at which to insert. Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol at which to insert. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node at which to insert. Usually a Tuple-alike of Char.\nall::Bool = true: Continue after the first insertion (true), or stop.\nfilter_fun = nothing: Any function taking a node as input, e.g. isleaf to decide\n\nwhere to insert.\n\nNotes\n\nThe nodes are always inserted before a filtered node because we can't decide if a new node would\n\nbe considered a new child or a new parent of the children otherwise.\n\nThe function does not do anything fancy, it let the user take care of its own rules when\n\ninserting nodes. So if you insert a branching node, the whole subtree will be branched.\n\nExamples\n\n# Importing the mtg from the github repo:\nmtg = read_mtg(download(\"https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg\"))\n\nmtg = insert_nodes!(mtg, MTG.MutableNodeMTG(\"/\", \"Shoot\", 0, 1), scale = 2) # Will insert new nodes before all scale 2\nmtg\n\n\n\n\n\n","category":"method"},{"location":"#MTG.is_filtered-NTuple{5, Any}","page":"Home","title":"MTG.is_filtered","text":"is_filtered(node, scale, symbol, link, filter_fun)\n\nIs a node filtered in ? Returns true if the node is kept, false if it is filtered-out.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.is_segment!-Tuple{Any}","page":"Home","title":"MTG.is_segment!","text":"is_segment(node)\n\nChecks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.\n\nThe function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.\n\nSee delete_nodes! for an example of application.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.isleaf-Tuple{Node}","page":"Home","title":"MTG.isleaf","text":"isleaf(node::Node)\n\nTest whether a node is a leaf or not.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.isroot-Tuple{Node}","page":"Home","title":"MTG.isroot","text":"isroot(node::Node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"#MTG.issection-Tuple{Any, Any}","page":"Home","title":"MTG.issection","text":"issection(string,section)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nArguments\n\nstring::String: The string to test.\nsection::String: The section to test.\n\nissection(\"CODE :\", \"CODE\")\n\n\n\n\n\n","category":"method"},{"location":"#MTG.issection-Tuple{Any}","page":"Home","title":"MTG.issection","text":"issection(string)\n\nIs a section\n\nIs a string part of an MTG section ? Returns true if it does, false otherwise.\n\nissection(\"CODE :\")\n\n\n\n\n\n","category":"method"},{"location":"#MTG.max_name-Tuple{Any}","page":"Home","title":"MTG.max_name","text":"max_name(mtg)\n\nReturns the maximum name of the mtg based on its index\n\n\n\n\n\n","category":"method"},{"location":"#MTG.new_name-Tuple{Any, Any}","page":"Home","title":"MTG.new_name","text":"new_name(mtg)\nnew_name(mtg,max_name)\n\nMake a new unique identifier by incrementing on the maximum name (names are names+index). Hint: prefer using max_name = max_name(mtg) and then new_name(mtg,max_name) for performance if you do it repeatidely.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.next_line!-Tuple{Any, Any}","page":"Home","title":"MTG.next_line!","text":"next_line!(f,line)\n\nRead line\n\nRead the next line in the IO stream, strip the comments, the missing values and increment the line index.\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nwhitespace::Bool: remove leading whitespaces.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.nleaves","page":"Home","title":"MTG.nleaves","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"#MTG.nleaves!","page":"Home","title":"MTG.nleaves!","text":"nleaves(node)\nnleaves!(node)\n\nGet the total number of leaves a node is bearing, i.e. the number of terminal nodes. nleaves! is faster than nleaves but cache the results in a variable so it uses more memory. Please use clean_cache! after calling nleaves! to clean the temporary variables.\n\nExamples\n\n# Importing the mtg from the github repo:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\nnleaves!(mtg)\n\nclean_cache!(mtg)\n\n\n\n\n\n","category":"function"},{"location":"#MTG.nleaves_siblings!-Tuple{Any}","page":"Home","title":"MTG.nleaves_siblings!","text":"nleaves_siblings!(x)\n\nCompute how many leaves the siblings of node x bear.\n\nPlease call clean_cache! after using nleaves_siblings! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}","page":"Home","title":"MTG.node_attributes","text":"Instantiate a attr_type struct with node_attr keys and values\n\nArguments\n\nattr_type::DataType: the type of the structure used to hold the attributes\nnode_attr::String: The node attributes as a Base.Dict\n\n\n\n\n\n","category":"method"},{"location":"#MTG.ordered_children-Tuple{Any}","page":"Home","title":"MTG.ordered_children","text":"ordered_children(node)\n\nReturn the children as an array, ordered first by \"+\"\n\n\n\n\n\n","category":"method"},{"location":"#MTG.parse_MTG_node-Tuple{Any}","page":"Home","title":"MTG.parse_MTG_node","text":"Parse MTG node\n\nParse MTG nodes (called from parse_mtg!())\n\nArguments\n\nl::String: An MTG node (e.g. \"/Individual0\")\n\nReturn\n\nA parsed node in the form of a Dict of three:\n\nthe link\nthe symbol\nand the index\n\n\n\n\n\n","category":"method"},{"location":"#MTG.parse_MTG_node_attr-NTuple{5, Any}","page":"Home","title":"MTG.parse_MTG_node_attr","text":"Parse MTG node attributes names, values and type\n\nArguments\n\nnode_data::String: A splitted mtg node data (attributes)\nattr_type::DataType: the type of the structure used to hold the attributes\nfeatures::DataFrame: The features data.frame\nattr_column_start::Integer: The index of the column of the first attribute\nline::Integer: The current line of the mtg file\nforce::Bool: force data reading even if errors are met during conversion ?\n\nReturn\n\nA list of attributes\n\n\n\n\n\n","category":"method"},{"location":"#MTG.parse_macro_args-Tuple{Any}","page":"Home","title":"MTG.parse_macro_args","text":"parse_macro_args(args)\n\nParse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.\n\nExamples\n\nargs = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))\nMTG.parse_macro_args(args)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.parse_mtg!-NTuple{7, Any}","page":"Home","title":"MTG.parse_mtg!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\")\nclasses::Array: The class section data as returned by parse_section!\ndescription::Array: The description section data as returned by parse_section!\nfeatures::Array: The features section data as returned by parse_section!\nline::Array{Int64,1}: The current line index (mutated). Must be given as line of MTG:\nl::Array{String,1}: the current line\nattr_type::DataType: the type of the structure used to hold the attributes\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed MTG section\n\n\n\n\n\n","category":"method"},{"location":"#MTG.parse_section!-NTuple{5, Any}","page":"Home","title":"MTG.parse_section!","text":"Parse MTG section\n\nArguments\n\nf::IOStream: A buffered IO stream to the mtg file, e.g. f = open(file, \"r\").\nheader::Array{String,1}: A string defining the expected header for the class.\nsection::String: The section name.\nline::Array{Int64,1}: The line number at which f is at the start of the funtion (mutated).\nl::Array{String,1}: the current line\n\nNote\n\nThe buffered IO stream (f) should start at the line of the section.\n\nReturns\n\nThe parsed section of the MTG\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nf = open(file, \"r\")\nline = [0] ; l = [\"\"]; l[1] = MTG.next_line!(f,line)\n\nwhile !MTG.issection(l[1]) || !MTG.issection(l[1],\"CLASSES\")\n    l[1] = MTG.next_line!(f,line)\nend\n\nclasses = MTG.parse_section!(f,[\"SYMBOL\",\"SCALE\",\"DECOMPOSITION\",\"INDEXATION\",\"DEFINITION\"],\"CLASSES\",line,l)\n\nclose(f)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.paste_mtg_node-Tuple{Any}","page":"Home","title":"MTG.paste_mtg_node","text":"paste_mtg_node(node)\n\nParse the mtg node as it should appear in the mtg file.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.pipe_model!-Tuple{Any, Any, Any}","page":"Home","title":"MTG.pipe_model!","text":"pipe_model!(node, var_name, threshold_value)\n\nSame than pipe_model! but uses another variable as the reference down until a threshold value. This is used for example in the case of LiDAR measurements, where we know the cross-section is well measured down to e.g. 2-3cm of diameter, but should be computed below.\n\nThis function allows to compute the cross-section using the pipe model only for some sub-trees with values of :var_name <= threshold_value.\n\nArguments\n\nnode: the mtg, or a specific node at which to start from.\nvar_name: the name of the cross-section attribute name in the nodes\nthreshold_value: the threshold defining the value below which the cross-section will be\n\nre-computed using the pipe model instead of using var_name.\n\nDetails\n\nThe node cross-section is dispatched from parent to children according to he number of leaves (i.e. terminal nodes) each child bear, unless one or more children has a :var_name > threshold_value. In this case the shared cross-section is the one from the parent minus the one of these nodes for which we simply use the measured value. The cross-section of the siblings with :var_name <= threshold_value will be shared as usual using their number of leaves.\n\nWord of caution\n\nUser must ensure that :varname has a value for all nodes in the mtg before calling this version of `pipemodel!`. Nodes with untrusted values should be set to a value below the threshold value to ensure recomputing of their values.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.pipe_model!-Tuple{Any, Any}","page":"Home","title":"MTG.pipe_model!","text":"pipe_model!(node, root_value)\n\nComputes the cross-section of node considering its topological environment and the cross-section at the root node (root_value).\n\nThe pipe model helps compute the cross-section of the nodes in an mtg by following the rule that the sum of the cross-sections of the children of a node is equal to the node cross-section.\n\nThe implementation is as follows: the algorithm first checks how many children a node has. If it has one child only, the child cross-section is equal to the node cross-section. If more children, the node cross-section is shared between the children according to the number of leaves they bear, i.e. the total number of terminal nodes of their sub-tree.\n\nPlease call clean_cache! after using pipe_model! because it creates temporary variables.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.read_mtg","page":"Home","title":"MTG.read_mtg","text":"read_mtg(file, attr_type = Dict, mtg_type = MutableNodeMTG)\n\nRead an MTG file\n\nArguments\n\nfile::String: The path to the MTG file.\nattr_type::DataType = Dict: the type used to hold the attribute values for each node.\nmtg_type = MutableNodeMTG: the type used to hold the mtg encoding for each node (i.e.\n\nlink, symbol, index, scale). See details section below.\n\nDetails\n\nattr_type should be:\n\nNamedTuple if you don't plan to modify the attributes of the mtg, e.g. to use them for\n\nplotting or computing statistics...\n\nMutableNamedTuple if you plan to modify the attributes values but not adding new attributes\n\nvery often, e.g. recompute an attribute value...\n\nDict or similar (e.g. OrderedDict) if you plan to heavily modify the attributes, e.g.\n\nadding/removing attibutes a lot\n\nThe MTG package provides two types for mtg_type, one immutable (NodeMTG), and one mutable (MutableNodeMTG). If you're planning on modifying the mtg encoding of some of your nodes, you should use MutableNodeMTG, and if you don't want to modify anything, use NodeMTG instead as it should be faster.\n\nNote\n\nSee the documentation for the MTG format from the OpenAlea webpage for further details.\n\nReturns\n\nThe MTG data.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:\nmtg = read_mtg(file,Dict);\n\n# We can also read an mtg directly from an excel file from the field:\nfile = \"E:/Agrobranche_Alexis_Bonnet/Biomass_evaluation_LiDAR/0-data/1-xlsx/tree3h.xlsx\"\nmtg = read_mtg(file)\n\n\n\n\n\n","category":"function"},{"location":"#MTG.rewrite_expr!-Tuple{Any, Expr}","page":"Home","title":"MTG.rewrite_expr!","text":"rewrite_expr!(arguments)\n\nRe-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add attributes after the node if it is an attribute.\n\nExamples\n\ntest = :(x = node.name)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.name)\n\ntest = :(x = node.foo)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.attributes[:foo])\n\ntest = :(x = node.MTG.symbol)\nMTG.rewrite_expr!(:mtg,test)\ntest\n# :(mtg.attributes[:x] = mtg.MTG.symbol)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.siblings-Tuple{Node}","page":"Home","title":"MTG.siblings","text":"siblings(node::Node)\n\nReturn the siblings of node as a vector of nodes (or nothing if non-existant).\n\n\n\n\n\n","category":"method"},{"location":"#MTG.split_MTG_elements-Tuple{Any}","page":"Home","title":"MTG.split_MTG_elements","text":"split_MTG_elements(l)\n\nSplit MTG line\n\nSplit the elements (e.g. inter-node, growth unit...) in an MTG line\n\nArguments\n\nl::String: A string for an MTG line (e.g. \"/P1/A1\").\n\nReturn\n\nA vector of elements (keeping their link, e.g. + or <)\n\nsplit(\"/A1+U85/U86<U87<.<U93<U94<.<U96<U97+.+U100\", r\"(?<=.)(?=[</+])\")\n\n\n\n\n\n","category":"method"},{"location":"#MTG.strip_comments","page":"Home","title":"MTG.strip_comments","text":"Strip comments from a string\n\nstriplinecomment{T<:String,U<:String}(a::T, cchars::U=\"#;\")\n\nArguments\n\na::String: the string from which the comments has to be stripped\ncchars::String: the characters that defines comments\n\nFrom https://rosettacode.org/wiki/Stripcommentsfromastring#Julia\n\nwhitespace::Bool: remove leading whitespaces.\n\nstrip_comments(\"test1\")\nstrip_comments(\"test2 # with a comment\")\nstrip_comments(\"# just a comment\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"#MTG.topological_order-Tuple{Any}","page":"Home","title":"MTG.topological_order","text":"topological_order(mtg; ascend = true)\n\nCompute the topological order of an mtg.\n\nArguments\n\nmtg: the mtg, e.g. output from read_mtg()\nascend: If true, the order is computed from the base (acropetal), if false,\n\nit is computed from the tip (basipetal).\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntopological_order(mtg)\nDataFrame(mtg, :topological_order)\n# 7×2 DataFrame\n#  Row │ tree                        topological_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      1\n#    2 │ └─ / 2: Individual                          1\n#    3 │    └─ / 3: Axis                             1\n#    4 │       └─ / 4: Internode                     1\n#    5 │          ├─ + 5: Leaf                       2\n#    6 │          └─ < 6: Internode                  1\n#    7 │             └─ + 7: Leaf                    2\n\ntopological_order(mtg, ascend = false)\nDataFrame(mtg, :topological_order)\n# 7×2 DataFrame\n#  Row │ tree                        topological_order\n#      │ String                      Int64\n# ─────┼───────────────────────────────────────────────\n#    1 │ / 1: $                                      2\n#    2 │ └─ / 2: Individual                          2\n#    3 │    └─ / 3: Axis                             2\n#    4 │       └─ / 4: Internode                     2\n#    5 │          ├─ + 5: Leaf                       1\n#    6 │          └─ < 6: Internode                  2\n#    7 │             └─ + 7: Leaf                    1\n\n\n\n\n\n","category":"method"},{"location":"#MTG.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}","page":"Home","title":"MTG.traverse!","text":"traverse!(node::Node, f::Function[, args...])\ntraverse(node::Node, f::Function[, args...])\n\nTraverse the nodes of a (sub-)tree, given any starting node in the tree, and apply a function which is either mutating (use traverse!) or not (use traverse).\n\nArguments\n\nnode::Node: An MTG node (e.g. the whole mtg returned by read_mtg()).\nf::Function: a function to apply over each node\nargs::Any: any argument to pass to the function\n\nReturns\n\nNothing for traverse! because it mutates the (sub-)tree in-place, or an Array of whatever the function returns.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\ntraverse!(mtg, x -> isleaf(x) ? println(x.name,\" is a leaf\") : nothing)\nnode_5 is a leaf\nnode_7 is a leaf\n\n\n\n\n\n","category":"method"},{"location":"#MTG.unsafe_getindex-Tuple{Node, Symbol}","page":"Home","title":"MTG.unsafe_getindex","text":"Indexing Node attributes from node, e.g. node[:length] or node[\"length\"], but in an unsafe way, meaning it returns nothing when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.\n\n\n\n\n\n","category":"method"},{"location":"#MTG.write_mtg-Tuple{Any, Any}","page":"Home","title":"MTG.write_mtg","text":"write_mtg(file, mtg; kwargs...)\nwrite_mtg(file, mtg, classes, description, features)\n\nWrite an mtg file to disk.\n\nArguments\n\nfile::String: The path to the MTG file to write.\nmtg: the mtg\nclasses: the classes section\ndescription: the description section\nfeatures: the features section\n\nNote\n\nkwargs can be used to give zero, one or two of the classes, description and features instead of all. In this case the missing ones are recomputed using get_classes, get_features or get_description.\n\nExamples\n\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\nwrite_mtg(\"test.mtg\",mtg)\n\n\n\n\n\n","category":"method"},{"location":"#MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"MTG.@mutate_mtg!","text":"@mutate_mtg!(node, args...,kwargs...)\n\nMutate the mtg nodes in place.\n\nArguments\n\nmtg: the mtg to mutate\nargs...: The computations to apply to the nodes (see examples)\nkwargs...: Optional keyword arguments for traversing and filtering (see details)\n\nDetails\n\nAs for descendants and ancestors, kwargs can be any filter from:\n\nscale = nothing: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.\nsymbol = nothing: The symbol to filter-in. Usually a Tuple-alike of Strings.\nlink = nothing: The link with the previous node to filter-in. Usually a Tuple-alike of Char.\nall::Bool = true: Return all filtered-in nodes (true), or stop at the first node that\n\nis filtered out (false).\n\nfilter_fun = nothing: Any filtering function taking a node as input, e.g. isleaf.\ntraversal: The type of tree traversal. By default it is using AbstractTrees.PreOrderDFS.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_mtg!(mtg, scaling = node.scales .+ 2)\n\n# Compute several new attributes, some based on others:\n@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_mtg! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"},{"location":"#MTG.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"MTG.@mutate_node!","text":"@mutate_node!(node, args...)\n\nMutate a single node in place.\n\nArguments\n\nnode: the node to mutate\nargs...: The computations to apply to the node (see examples)\n\nSee also\n\n@mutate_mtg! to mutate all nodes of an mtg.\n\nExamples\n\n# Importing an mtg from the package:\nfile = joinpath(dirname(dirname(pathof(MTG))),\"test\",\"files\",\"simple_plant.mtg\")\nmtg = read_mtg(file)\n\n# Compute a new attribute with the scales and add 2 to its values:\n@mutate_node!(mtg, scaling = node.scales .+ 2)\n\n# The computation is only applied to the root node. To apply it to all nodes,\n# see @mutate_mtg!\n\n# Compute several new attributes, some based on others:\n@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))\n\n# We can also use it without parenthesis:\n\n@mutate_node! mtg x = length(node.name)\n\n\n\n\n\n","category":"macro"}]
}
