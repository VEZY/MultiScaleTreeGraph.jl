<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MTG.jl</title><link rel="canonical" href="https://VEZY.github.io/MTG.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MTG.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MTG.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MTG"><a class="docs-heading-anchor" href="#MTG">MTG</a><a id="MTG-1"></a><a class="docs-heading-anchor-permalink" href="#MTG" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/VEZY/MTG.jl">MTG</a>.</p><ul><li><a href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a></li><li><a href="#MTG.NodeMTG"><code>MTG.NodeMTG</code></a></li><li><a href="#Base.append!-Union{Tuple{T}, Tuple{Node{MTG.NodeMTG, T}, Any}} where T&lt;:MutableNamedTuples.MutableNamedTuple"><code>Base.append!</code></a></li><li><a href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.length-Tuple{Node}"><code>Base.length</code></a></li><li><a href="#Base.print-Tuple{Node}"><code>Base.print</code></a></li><li><a href="#MTG.addchild!-Tuple{Node, String, MTG.NodeMTG, Any}"><code>MTG.addchild!</code></a></li><li><a href="#MTG.ancestors-Tuple{Any, Any}"><code>MTG.ancestors</code></a></li><li><a href="#MTG.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MTG.check_filters</code></a></li><li><a href="#MTG.children-Tuple{Node}"><code>MTG.children</code></a></li><li><a href="#MTG.delete_node!-Tuple{Any}"><code>MTG.delete_node!</code></a></li><li><a href="#MTG.delete_nodes!-Tuple{Any}"><code>MTG.delete_nodes!</code></a></li><li><a href="#MTG.descendants-Tuple{Any, Any}"><code>MTG.descendants</code></a></li><li><a href="#MTG.expand_node!-Tuple{Any, Any}"><code>MTG.expand_node!</code></a></li><li><a href="#MTG.get_leading_tabs-Tuple{Any}"><code>MTG.get_leading_tabs</code></a></li><li><a href="#MTG.get_printing-Tuple{Node}"><code>MTG.get_printing</code></a></li><li><a href="#MTG.get_reference-Tuple{Any}"><code>MTG.get_reference</code></a></li><li><a href="#MTG.getroot-Tuple{Node}"><code>MTG.getroot</code></a></li><li><a href="#MTG.is_filtered-NTuple{5, Any}"><code>MTG.is_filtered</code></a></li><li><a href="#MTG.is_segment!-Tuple{Any}"><code>MTG.is_segment!</code></a></li><li><a href="#MTG.isleaf-Tuple{Node}"><code>MTG.isleaf</code></a></li><li><a href="#MTG.isroot-Tuple{Node}"><code>MTG.isroot</code></a></li><li><a href="#MTG.issection-Tuple{Any}"><code>MTG.issection</code></a></li><li><a href="#MTG.issection-Tuple{Any, Any}"><code>MTG.issection</code></a></li><li><a href="#MTG.max_name-Tuple{Any}"><code>MTG.max_name</code></a></li><li><a href="#MTG.new_name-Tuple{Any, Any}"><code>MTG.new_name</code></a></li><li><a href="#MTG.next_line!-Tuple{Any, Any}"><code>MTG.next_line!</code></a></li><li><a href="#MTG.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MTG.node_attributes</code></a></li><li><a href="#MTG.ordered_children-Tuple{Any}"><code>MTG.ordered_children</code></a></li><li><a href="#MTG.parse_MTG_node-Tuple{Any}"><code>MTG.parse_MTG_node</code></a></li><li><a href="#MTG.parse_MTG_node_attr-NTuple{5, Any}"><code>MTG.parse_MTG_node_attr</code></a></li><li><a href="#MTG.parse_macro_args-Tuple{Any}"><code>MTG.parse_macro_args</code></a></li><li><a href="#MTG.parse_mtg!-NTuple{6, Any}"><code>MTG.parse_mtg!</code></a></li><li><a href="#MTG.parse_section!-NTuple{5, Any}"><code>MTG.parse_section!</code></a></li><li><a href="#MTG.paste_mtg_node-Tuple{Any}"><code>MTG.paste_mtg_node</code></a></li><li><a href="#MTG.read_mtg"><code>MTG.read_mtg</code></a></li><li><a href="#MTG.rewrite_expr!-Tuple{Any, Expr}"><code>MTG.rewrite_expr!</code></a></li><li><a href="#MTG.siblings-Tuple{Node}"><code>MTG.siblings</code></a></li><li><a href="#MTG.split_MTG_elements-Tuple{Any}"><code>MTG.split_MTG_elements</code></a></li><li><a href="#MTG.strip_comments"><code>MTG.strip_comments</code></a></li><li><a href="#MTG.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MTG.traverse!</code></a></li><li><a href="#MTG.unsafe_getindex-Tuple{Node, Symbol}"><code>MTG.unsafe_getindex</code></a></li><li><a href="#MTG.write_mtg-NTuple{5, Any}"><code>MTG.write_mtg</code></a></li><li><a href="#MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MTG.@mutate_mtg!</code></a></li><li><a href="#MTG.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MTG.@mutate_node!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}" href="#DataFrames.DataFrame-Union{Tuple{T}, Tuple{Node, T}} where T&lt;:Union{Tuple, AbstractArray}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DataFrame(mtg::Node,vars::T[,type::Union{Union,DataType}=Any])</code></pre><p>Convert an MTG into a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>mtg::Node</code>: An mtg node (usually the root node).</li><li><code>key</code>: The key, or attribute name. Used to list the variables that must be added to the</li></ul><p><code>DataFrame</code>. It is given either as Symbols (faster) or String, or an Array of (or a Tuple).</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
    read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

DataFrame(mtg, :Length)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/DataFrame.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.NodeMTG" href="#MTG.NodeMTG"><code>MTG.NodeMTG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeMTG(link, symbol, index, scale)</code></pre><p><strong>NodeMTG structure</strong></p><p>Builds an MTG node to hold data about the link to the previous node, the symbol of the node, and its index.</p><p><strong>Note</strong></p><ul><li>The symbol should match the possible values listed in the <code>SYMBOL</code> column of the <code>CLASSES</code> section</li></ul><p>in the mtg file if read from a file.</p><ul><li>The index is totaly free, and can be used as a way to <em>e.g.</em> keep track of the branching order.</li></ul><pre><code class="language-julia">NodeMTG(&quot;&lt;&quot;, &quot;Leaf&quot;, 2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/NodeMTG.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Union{Tuple{T}, Tuple{Node{MTG.NodeMTG, T}, Any}} where T&lt;:MutableNamedTuples.MutableNamedTuple" href="#Base.append!-Union{Tuple{T}, Tuple{Node{MTG.NodeMTG, T}, Any}} where T&lt;:MutableNamedTuples.MutableNamedTuple"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append!(node::Node{NodeMTG, &lt;:MutableNamedTuple}, attr)
append!(node::Node{NodeMTG, &lt;:Dict}, attr)</code></pre><p>Append new attributes to a node attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/append_attributes.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Any}" href="#Base.getindex-Tuple{Node, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/NodeMTG.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{Node, Integer}" href="#Base.getindex-Tuple{Node, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing a Node using an integer will index in its children</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/NodeMTG.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Node}" href="#Base.length-Tuple{Node}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the length of the subtree below the node (including it)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/NodeMTG.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print-Tuple{Node}" href="#Base.print-Tuple{Node}"><code>Base.print</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Print a node to io using an UTF-8 formatted representation of the <code>tree</code>. Most of the code from <a href="https://github.com/vh-d/DataTrees.jl/blob/master/src/printing.jl">DataTrees.jl</a></p><p><strong>Examples</strong></p><pre><code class="language-julia">file = download(&quot;https://raw.githubusercontent.com/VEZY/XploRer/master/inst/extdata/simple_plant.mtg&quot;);
mtg, classes, description, features = read_mtg(file);
mtg
# / 1: $
# └─ / 2: Individual
#    └─ / 3: Axis
#       └─ / 4: Internode
#          ├─ + 5: Leaf
#          └─ &lt; 6: Internode
#             └─ + 7: Leaf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/print_MTG/print.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.addchild!-Tuple{Node, String, MTG.NodeMTG, Any}" href="#MTG.addchild!-Tuple{Node, String, MTG.NodeMTG, Any}"><code>MTG.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new child to a parent node, and add the parent node as the parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.ancestors-Tuple{Any, Any}" href="#MTG.ancestors-Tuple{Any, Any}"><code>MTG.ancestors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ancestors(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the ancestors (basipetal).</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MTG.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
    read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

# Using a leaf node from the mtg:
leaf_node = mtg.children[&quot;node_2&quot;].children[&quot;node_3&quot;].children[&quot;node_4&quot;].children[&quot;node_5&quot;]

ancestors(leaf_node, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
ancestors(leaf_node, :Length, type = Union{Nothing,Float64})

# Filter by scale:
ancestors(leaf_node, :XX, scale = 1, type = Float64)
ancestors(leaf_node, :Length, scale = 3, type = Float64)

# Filter by symbol:
ancestors(leaf_node, :Length, symbol = &quot;Internode&quot;)
ancestors(leaf_node, :Length, symbol = (&quot;Axis&quot;,&quot;Internode&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/ancestors.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.check_filters-Union{Tuple{Any}, Tuple{T}} where T" href="#MTG.check_filters-Union{Tuple{Any}, Tuple{T}} where T"><code>MTG.check_filters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_filters(node; scale = nothing, symbol = nothing, link = nothing)</code></pre><p>Check if the filters are consistant with the mtg onto which they are applied</p><p><strong>Examples</strong></p><pre><code class="language-julia">check_filters(mtg, scale = 1)
check_filters(mtg, scale = (1,2))
check_filters(mtg, scale = (1,2), symbol = &quot;Leaf&quot;, link = &quot;&lt;&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/check_filters.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.children-Tuple{Node}" href="#MTG.children-Tuple{Node}"><code>MTG.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">children(node::Node)</code></pre><p>Return the immediate children of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.delete_node!-Tuple{Any}" href="#MTG.delete_node!-Tuple{Any}"><code>MTG.delete_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete_node!(node)</p><p>Delete a node and re-parent the children to its own parent. If the node is a root and it has only one child, the child becomes the root, if it has several children, it returns an error.</p><p>The function returns the parent node (or the new root if the node is a root)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/delete_nodes.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.delete_nodes!-Tuple{Any}" href="#MTG.delete_nodes!-Tuple{Any}"><code>MTG.delete_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>delete_nodes!(mtg::Node,&lt;keyword arguments&gt;)</p><p>Delete nodes in mtg following filters rules.</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li></ul><p><strong>Keyword Arguments (filters)</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MTG.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li></ul><p><strong>Notes</strong></p><ol><li>The function is acropetal, meaning it will apply the deletion from leaves to the root to ensure</li></ol><p>that one pass is enough and we don&#39;t repeat the process of visiting already visited children.</p><ol><li>The function does not do anything fancy, it let the user take care of its own rules when</li></ol><p>deleting nodes. So if you delete a branching node, the whole subtree will be modified and take the link of the children. This process is left to the user becaue it highly depends on the mtg structure.</p><ol><li>The package provides some pre-made functions for filtering. See for example <a href="#MTG.is_segment!-Tuple{Any}"><code>is_segment!</code></a></li></ol><p>to re-compute the mtg at a given scale to have only nodes at branching points. This is often used to match automatic reconstructions from e.g. LiDAR point cloud with manual measurements.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/A1B1.mtg&quot;))

delete_nodes!(mtg, scale = 2) # Will remove all nodes of scale 2

# Delete the leaves:
delete_nodes!(mtg, symbol = &quot;Leaf&quot;)
# Delete the leaves and internodes:
delete_nodes!(mtg, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))

# Make the mtg match field measurements made only at branching points for the scales 1 + 2:
mtg = delete_nodes!(mtg, filter_fun = is_segment!, scale = 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/delete_nodes.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.descendants-Tuple{Any, Any}" href="#MTG.descendants-Tuple{Any, Any}"><code>MTG.descendants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">descendants(node::Node,key,&lt;keyword arguments&gt;)</code></pre><p>Get attribute values from the descendants (acropetal).</p><p><strong>Arguments</strong></p><p><strong>Mandatory arguments</strong></p><ul><li><code>node::Node</code>: The node to start at.</li><li><code>key</code>: The key, or attribute name. Make it a <code>Symbol</code> for faster computation time.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>self = false</code>: is the value for the current node needed ?</li><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MTG.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>type::Union{Union,DataType}</code>: The type of the attribute. Makes the function run much</li></ul><p>faster if provided (≈4x faster).</p><p><strong>Note</strong></p><p>In most cases, the <code>type</code> argument should be given as a union of <code>Nothing</code> and the data type of the attribute to manage missing or inexistant data, e.g. measurements made at one scale only. See examples for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
    read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

descendants(mtg, :Length) # Short to write, but slower to execute

# Fast version, note that we pass a union of Nothing and Float64 because there are some nodes
# without a `Length` attribute:
descendants(mtg, :Length, type = Union{Nothing,Float64})

# Filter by scale:
descendants(mtg, :XX, scale = 1, type = Float64)
descendants(mtg, :Length, scale = 3, type = Float64)

# Filter by symbol:
descendants(mtg, :Length, symbol = &quot;Leaf&quot;)
descendants(mtg, :Length, symbol = (&quot;Leaf&quot;,&quot;Internode&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/descendants.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.expand_node!-Tuple{Any, Any}" href="#MTG.expand_node!-Tuple{Any, Any}"><code>MTG.expand_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Expand MTG line</strong></p><p>Expand the elements denoted by the syntactic sugar &quot;&lt;&lt;&quot;, &quot;&lt;.&lt;&quot;, &quot;++&quot; or &quot;+.+&quot;</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{String}</code>: A split MTG line (e.g. c(&quot;/P1&quot;,&quot;/A1&quot;))</li><li><code>line::Array{Int64,1}</code>: The current line index (mutated) in the file. Only</li></ul><p>used as information when erroring.</p><p><strong>Returns</strong></p><p>A Tuple of:</p><ul><li>the split MTG line with all nodes explicitly</li><li>the nodes with common attributes (when using <code>&lt;.&lt;</code> or <code>+.+</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">x = split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;,r&quot;(?&lt;=.)(?=[&lt;/+])&quot;);
nodes, shared = MTG.expand_node!(x,1)
(AbstractString[&quot;/A1&quot;, &quot;+U85&quot;, &quot;/U86&quot;, &quot;&lt;U87&quot;, &quot;&lt;U88&quot;, &quot;&lt;U89&quot;, &quot;&lt;U90&quot;, &quot;&lt;U91&quot;, &quot;&lt;U92&quot;, &quot;&lt;U93&quot;, &quot;&lt;U94&quot;, &quot;&lt;U95&quot;, &quot;&lt;U96&quot;, &quot;&lt;U97&quot;, &quot;+U98&quot;, &quot;+U99&quot;, &quot;+U100&quot;], Any[87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/expand_node.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.get_leading_tabs-Tuple{Any}" href="#MTG.get_leading_tabs-Tuple{Any}"><code>MTG.get_leading_tabs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_leading_tabs(node)</code></pre><p>Get the number of tabulation the node should have when writting it to a file based on the topology of its parent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/write_mtg/write_mtg.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.get_printing-Tuple{Node}" href="#MTG.get_printing-Tuple{Node}"><code>MTG.get_printing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_printing(node::Node; leading::AbstractString = &quot;&quot;)</code></pre><p>Format the printing of the tree according to link: follow or branching</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/print_MTG/print.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.get_reference-Tuple{Any}" href="#MTG.get_reference-Tuple{Any}"><code>MTG.get_reference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_reference(node)</code></pre><p>Get the preceding &quot;^&quot; keyword if needed, <em>i.e.</em> in case we refer to the parent node in the same mtg file column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/write_mtg/write_mtg.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.getroot-Tuple{Node}" href="#MTG.getroot-Tuple{Node}"><code>MTG.getroot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the root node of a tree, given any node in the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.is_filtered-NTuple{5, Any}" href="#MTG.is_filtered-NTuple{5, Any}"><code>MTG.is_filtered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_filtered(node, scale, symbol, link, filter_fun)</code></pre><p>Is a node filtered in ? Returns <code>true</code> if the node is kept, <code>false</code> if it is filtered-out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/check_filters.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.is_segment!-Tuple{Any}" href="#MTG.is_segment!-Tuple{Any}"><code>MTG.is_segment!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_segment(node)</code></pre><p>Checks if a node (n) has only one child (n+1). This is usefull to simplify a complex mtg to become an mtg with nodes only at the branching points, has it is often measured on the field.</p><p>The function also takes care of passing the link of the node (n) to its child (n+1) if the node (n) branches or decompose its parent (n-1). This allows a conservation of the relationships as they previously were in the mtg.</p><p>See <a href="#MTG.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> for an example of application.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/filter/filter-funs.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.isleaf-Tuple{Node}" href="#MTG.isleaf-Tuple{Node}"><code>MTG.isleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isleaf(node::Node)</code></pre><p>Test whether a node is a leaf or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.isroot-Tuple{Node}" href="#MTG.isroot-Tuple{Node}"><code>MTG.isroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isroot(node::Node)</code></pre><p>Return <code>true</code> if <code>node</code> is the root node (meaning, it has no parent).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.issection-Tuple{Any, Any}" href="#MTG.issection-Tuple{Any, Any}"><code>MTG.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issection(string,section)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>string::String</code>: The string to test.</li><li><code>section::String</code>: The section to test.</li></ul><pre><code class="language-julia">issection(&quot;CODE :&quot;, &quot;CODE&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/utils-string.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.issection-Tuple{Any}" href="#MTG.issection-Tuple{Any}"><code>MTG.issection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issection(string)</code></pre><p><strong>Is a section</strong></p><p>Is a string part of an MTG section ? Returns <code>true</code> if it does, <code>false</code> otherwise.</p><pre><code class="language-julia">issection(&quot;CODE :&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/utils-string.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.max_name-Tuple{Any}" href="#MTG.max_name-Tuple{Any}"><code>MTG.max_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">max_name(mtg)</code></pre><p>Returns the maximum name of the mtg based on its index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.new_name-Tuple{Any, Any}" href="#MTG.new_name-Tuple{Any, Any}"><code>MTG.new_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">new_name(mtg)
new_name(mtg,max_name)</code></pre><p>Make a new unique identifier by incrementing on the maximum name (names are names+index). Hint: prefer using <code>max_name = max_name(mtg)</code> and then <code>new_name(mtg,max_name)</code> for performance if you do it repeatidely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.next_line!-Tuple{Any, Any}" href="#MTG.next_line!-Tuple{Any, Any}"><code>MTG.next_line!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">next_line!(f,line)</code></pre><p><strong>Read line</strong></p><p>Read the next line in the IO stream, strip the comments, and increment the line index.</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/utils-string.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}" href="#MTG.node_attributes-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Union{NamedTuple, MutableNamedTuples.MutableNamedTuple}"><code>MTG.node_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Instantiate a <code>attr_type</code> struct with <code>node_attr</code> keys and values</p><p><strong>Arguments</strong></p><ul><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>node_attr::String</code>: The node attributes as a <a href="@ref"><code>Base.Dict</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/parse_mtg.jl#L268-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.ordered_children-Tuple{Any}" href="#MTG.ordered_children-Tuple{Any}"><code>MTG.ordered_children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ordered_children(node)</code></pre><p>Return the children as an array, ordered first by &quot;+&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.parse_MTG_node-Tuple{Any}" href="#MTG.parse_MTG_node-Tuple{Any}"><code>MTG.parse_MTG_node</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Parse MTG node</strong></p><p>Parse MTG nodes (called from <code>parse_mtg!()</code>)</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: An MTG node (e.g. &quot;/Individual0&quot;)</li></ul><p><strong>Return</strong></p><p>A parsed node in the form of a Dict of three:</p><ul><li>the link</li><li>the symbol</li><li>and the index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/parse_mtg.jl#L158-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.parse_MTG_node_attr-NTuple{5, Any}" href="#MTG.parse_MTG_node_attr-NTuple{5, Any}"><code>MTG.parse_MTG_node_attr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG node attributes names, values and type</p><p><strong>Arguments</strong></p><ul><li><code>node_data::String</code>: A splitted mtg node data (attributes)</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li><li><code>features::DataFrame</code>: The features data.frame</li><li><code>attr_column_start::Integer</code>: The index of the column of the first attribute</li><li><code>line::Integer</code>: The current line of the mtg file</li><li><code>force::Bool</code>: force data reading even if errors are met during conversion ?</li></ul><p><strong>Return</strong></p><p>A list of attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/parse_mtg.jl#L195-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.parse_macro_args-Tuple{Any}" href="#MTG.parse_macro_args-Tuple{Any}"><code>MTG.parse_macro_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_macro_args(args)</code></pre><p>Parse filters and arguments given as a collection of expressions. This function is used to get the filters as keyword arguments in macros.</p><p><strong>Examples</strong></p><pre><code class="language-julia">args = (:(x = length(node.name)), :(y = node.x + 2), :(scale = 2))
MTG.parse_args_filters(args)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/check_filters.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.parse_mtg!-NTuple{6, Any}" href="#MTG.parse_mtg!-NTuple{6, Any}"><code>MTG.parse_mtg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code></li><li><code>classes::Array</code>: The class section data as returned by <code>parse_section!</code></li><li><code>description::Array</code>: The description section data as returned by <code>parse_section!</code></li><li><code>features::Array</code>: The features section data as returned by <code>parse_section!</code></li><li><code>line::Array{Int64,1}</code>: The current line index (mutated). Must be given as line of <code>MTG:</code></li><li><code>l::Array{String,1}</code>: the current line</li><li><code>attr_type::DataType</code>: the type of the structure used to hold the attributes</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed MTG section</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/parse_mtg.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.parse_section!-NTuple{5, Any}" href="#MTG.parse_section!-NTuple{5, Any}"><code>MTG.parse_section!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse MTG section</p><p><strong>Arguments</strong></p><ul><li><code>f::IOStream</code>: A buffered IO stream to the mtg file, <em>e.g.</em> <code>f = open(file, &quot;r&quot;)</code>.</li><li><code>header::Array{String,1}</code>: A string defining the expected header for the class.</li><li><code>section::String</code>: The section name.</li><li><code>line::Array{Int64,1}</code>: The line number at which f is at the start of the funtion (mutated).</li><li><code>l::Array{String,1}</code>: the current line</li></ul><p><strong>Note</strong></p><p>The buffered IO stream (<code>f</code>) should start at the line of the section.</p><p><strong>Returns</strong></p><p>The parsed section of the MTG</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = download(&quot;https://raw.githubusercontent.com/VEZY/XploRer/master/inst/extdata/simple_plant.mtg&quot;);
f = open(file, &quot;r&quot;)
line = [0] ; l = [&quot;&quot;]; l[1] = MTG.next_line!(f,line)

while !MTG.issection(l[1]) || !MTG.issection(l[1],&quot;CLASSES&quot;)
    l[1] = MTG.next_line!(f,line)
end

classes = MTG.parse_section!(f,[&quot;SYMBOL&quot;,&quot;SCALE&quot;,&quot;DECOMPOSITION&quot;,&quot;INDEXATION&quot;,&quot;DEFINITION&quot;],&quot;CLASSES&quot;,line,l)

close(f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/parse_section.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.paste_mtg_node-Tuple{Any}" href="#MTG.paste_mtg_node-Tuple{Any}"><code>MTG.paste_mtg_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">paste_mtg_node(node)</code></pre><p>Parse the mtg node as it should appear in the mtg file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/write_mtg/write_mtg.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.read_mtg" href="#MTG.read_mtg"><code>MTG.read_mtg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_mtg(file,attr_type::DataType = Dict)</code></pre><p>Read an MTG file</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file.</li><li><code>attr_type::DataType</code>: the type used to hold the attribute values for each node.</li></ul><p><strong>Details</strong></p><p><code>attr_type</code> should be:</p><ul><li><code>NamedTuple</code> if you don&#39;t plan to modify the attributes of the mtg, <em>e.g.</em> to use them for</li></ul><p>plotting or computing statistics...</p><ul><li><code>MutableNamedTuple</code> if you plan to modify the attributes values but not adding new attributes</li></ul><p>very often, <em>e.g.</em> recompute an attribute value...</p><ul><li><code>Dict</code> if you plan to modify heavily the attributes, <em>e.g.</em> adding/removing attibutes a lot</li></ul><p><strong>Note</strong></p><p>See the documentation for the MTG format from the <a href="http://openalea.gforge.inria.fr/doc/vplants/newmtg/doc/_build/html/user/intro.html#mtg-a-plant-architecture-databases">OpenAlea webpage</a> for further details.</p><p><strong>Returns</strong></p><p>A named list of four sections: the MTG classes, description, features, and MTG. The MTG is a [data.tree] data structure.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mtg,classes,description,features = read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

# Or using another `MutableNamedTuple` for the attributes to be able to add one if needed:
mtg,classes,description,features = read_mtg(file,Dict);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/read_MTG.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.rewrite_expr!-Tuple{Any, Expr}" href="#MTG.rewrite_expr!-Tuple{Any, Expr}"><code>MTG.rewrite_expr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewrite_expr!(arguments)</code></pre><p>Re-write the call to the variables of a node in an expression to match their location: leave it as it is if the variable is a node field, or add <code>attributes</code> after the node if it is an attribute.</p><p><strong>Examples</strong></p><pre><code class="language-none">&gt;julia test = :(x = node.name)
&gt;julia MTG.rewrite_expr!(:mtg,test)
&gt;julia test
:(mtg.attributes[:x] = mtg.name)

&gt;julia test = :(x = node.foo)
&gt;julia MTG.rewrite_expr!(:mtg,test)
&gt;julia test
:(mtg.attributes[:x] = mtg.attributes[:foo])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/mutation.jl#L111-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.siblings-Tuple{Node}" href="#MTG.siblings-Tuple{Node}"><code>MTG.siblings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siblings(node::Node)</code></pre><p>Return the siblings of <code>node</code> as a vector of nodes (or <code>nothing</code> if non-existant).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/Tree_funs.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.split_MTG_elements-Tuple{Any}" href="#MTG.split_MTG_elements-Tuple{Any}"><code>MTG.split_MTG_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split_MTG_elements(l)</code></pre><p><strong>Split MTG line</strong></p><p>Split the elements (e.g. inter-node, growth unit...) in an MTG line</p><p><strong>Arguments</strong></p><ul><li><code>l::String</code>: A string for an MTG line (e.g. &quot;/P1/A1&quot;).</li></ul><p><strong>Return</strong></p><p>A vector of elements (keeping their link, e.g. + or &lt;)</p><pre><code class="language-julia">split(&quot;/A1+U85/U86&lt;U87&lt;.&lt;U93&lt;U94&lt;.&lt;U96&lt;U97+.+U100&quot;, r&quot;(?&lt;=.)(?=[&lt;/+])&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/utils-string.jl#L56-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.strip_comments" href="#MTG.strip_comments"><code>MTG.strip_comments</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Strip comments from a string</p><pre><code class="language-none">striplinecomment{T&lt;:String,U&lt;:String}(a::T, cchars::U=&quot;#;&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: the string from which the comments has to be stripped</li><li><code>cchars::String</code>: the characters that defines comments</li></ul><p>From https://rosettacode.org/wiki/Strip<em>comments</em>from<em>a</em>string#Julia</p><ul><li><code>whitespace::Bool</code>: remove leading whitespaces.</li></ul><pre><code class="language-julia">strip_comments(&quot;test1&quot;)
strip_comments(&quot;test2 # with a comment&quot;)
strip_comments(&quot;# just a comment&quot;)
&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/strip_comments.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}" href="#MTG.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>MTG.traverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">traverse!(node::Node, f::Function, args...)</code></pre><p>Traverse the nodes of a (sub-)tree, given any starting node in the tree.</p><p><strong>Arguments</strong></p><ul><li><code>node::Node</code>: An MTG node (<em>e.g.</em> the whole mtg returned by <code>read_mtg()</code>).</li><li><code>f::Function</code>: a function to apply over each node</li><li><code>args::Any</code>: any argument to pass to the function</li></ul><p><strong>Returns</strong></p><p>Nothing, mutates the (sub-)tree.</p><p><strong>Examples</strong></p><pre><code class="language-julia">file = download(&quot;https://raw.githubusercontent.com/VEZY/XploRer/master/inst/extdata/simple_plant.mtg&quot;);
mtg,classes,description,features = read_mtg(file);
traverse!(mtg, x -&gt; isleaf(x) ? println(x.name,&quot; is a leaf&quot;) : nothing)
node_5 is a leaf
node_7 is a leaf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/traverse.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.unsafe_getindex-Tuple{Node, Symbol}" href="#MTG.unsafe_getindex-Tuple{Node, Symbol}"><code>MTG.unsafe_getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indexing Node attributes from node, e.g. node[:length] or node[&quot;length&quot;], but in an unsafe way, meaning it returns <code>nothing</code> when the key is not found instead of returning an error. It is primarily used when traversing the tree, so if a node does not have a field, it does not return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/read_MTG/NodeMTG.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.write_mtg-NTuple{5, Any}" href="#MTG.write_mtg-NTuple{5, Any}"><code>MTG.write_mtg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_mtg(file, mtg, classes, description, features)</code></pre><p>Write an mtg file to disk.</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: The path to the MTG file to write.</li><li><code>mtg</code>: the mtg</li><li><code>classes</code>: the classes section</li><li><code>description</code>: the description section</li><li><code>features</code>: the features section</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/write_mtg/write_mtg.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}" href="#MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>MTG.@mutate_mtg!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@mutate_mtg!(node, args...,kwargs...)</code></pre><p>Mutate the mtg nodes in place.</p><p><strong>Arguments</strong></p><ul><li><code>mtg</code>: the mtg to mutate</li><li><code>args...</code>: The computations to apply to the nodes (see examples)</li><li><code>kwargs...</code>: Optional keyword arguments for traversing and filtering (see details)</li></ul><p><strong>Details</strong></p><p>As for <a href="#MTG.descendants-Tuple{Any, Any}"><code>descendants</code></a> and <a href="#MTG.ancestors-Tuple{Any, Any}"><code>ancestors</code></a>, kwargs can be any filter from:</p><ul><li><code>scale = nothing</code>: The scale to filter-in (i.e. to keep). Usually a Tuple-alike of integers.</li><li><code>symbol = nothing</code>: The symbol to filter-in. Usually a Tuple-alike of Strings.</li><li><code>link = nothing</code>: The link with the previous node to filter-in. Usually a Tuple-alike of Char.</li><li><code>all::Bool = true</code>: Return all filtered-in nodes (<code>true</code>), or stop at the first node that</li></ul><p>is filtered out (<code>false</code>).</p><ul><li><code>filter_fun = nothing</code>: Any filtering function taking a node as input, e.g. <a href="#MTG.isleaf-Tuple{Node}"><code>isleaf</code></a>.</li><li><code>traversal</code>: The type of tree traversal. By default it is using <code>AbstractTrees.PreOrderDFS</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
    read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

# Compute a new attribute with the scales and add 2 to its values:
@mutate_mtg!(mtg, scaling = node.scales .+ 2)

# Compute several new attributes, some based on others:
@mutate_mtg!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_mtg! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/mutation.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTG.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}" href="#MTG.@mutate_node!-Tuple{Any, Vararg{Any, N} where N}"><code>MTG.@mutate_node!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@mutate_node!(node, args...)</code></pre><p>Mutate a single node in place.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: the node to mutate</li><li><code>args...</code>: The computations to apply to the node (see examples)</li></ul><p><strong>See also</strong></p><p><a href="#MTG.@mutate_mtg!-Tuple{Any, Vararg{Any, N} where N}"><code>@mutate_mtg!</code></a> to mutate all nodes of an mtg.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Importing the mtg from the github repo:
mtg,classes,description,features =
    read_mtg(download(&quot;https://raw.githubusercontent.com/VEZY/MTG.jl/master/test/files/simple_plant.mtg&quot;))

# Compute a new attribute with the scales and add 2 to its values:
@mutate_node!(mtg, scaling = node.scales .+ 2)

# The computation is only applied to the root node. To apply it to all nodes,
# see @mutate_mtg!

# Compute several new attributes, some based on others:
@mutate_node!(mtg, x = length(node.name), y = node.x + 2, z = sum(node.y))

# We can also use it without parenthesis:

@mutate_node! mtg x = length(node.name)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VEZY/MTG.jl/blob/1eeb7c340951c3c260213fc96f2ddb5f8d2932ea/src/compute_MTG/mutation.jl#L69-L103">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 14 May 2021 11:10">Friday 14 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
