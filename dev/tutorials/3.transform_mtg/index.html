<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transform an MTG · MultiScaleTreeGraph.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/MultiScaleTreeGraph.jl/tutorials/3.transform_mtg/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultiScaleTreeGraph.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/">Getting started</a></li><li><span class="tocitem">The MTG format</span><ul><li><a class="tocitem" href="../../the_mtg/mtg_concept/">Concept</a></li><li><a class="tocitem" href="../../the_mtg/mtg_format/">File format</a></li><li><a class="tocitem" href="../../the_mtg/our_implementation/">Our implementation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../0.read_write/">Read and Write MTGs</a></li><li><a class="tocitem" href="../1.manipulate_node/">Accessing node data</a></li><li><a class="tocitem" href="../2.descendants_ancestors_filters/">Node attributes</a></li><li class="is-active"><a class="tocitem" href>Transform an MTG</a><ul class="internal"><li><a class="tocitem" href="#A-note-on-anonymous-functions"><span>A note on anonymous functions</span></a></li><li><a class="tocitem" href="#Introduction-to-MTG-transforming"><span>Introduction to MTG transforming</span></a></li><li><a class="tocitem" href="#Form-1:-Rename-an-attribute"><span>Form 1: Rename an attribute</span></a></li><li><a class="tocitem" href="#Form-2:-Compute-new-attributes-based-on-other-attributes"><span>Form 2: Compute new attributes based on other attributes</span></a></li><li><a class="tocitem" href="#Form-3:-Compute-a-new-attribute-based-on-node-values"><span>Form 3: Compute a new attribute based on node values</span></a></li><li><a class="tocitem" href="#Form-4:-Apply-a-function-to-nodes"><span>Form 4: Apply a function to nodes</span></a></li><li><a class="tocitem" href="#Select-an-MTG"><span>Select an MTG</span></a></li><li><a class="tocitem" href="#Traverse-an-MTG"><span>Traverse an MTG</span></a></li><li><a class="tocitem" href="#Mutate-an-MTG"><span>Mutate an MTG</span></a></li><li><a class="tocitem" href="#Helpers"><span>Helpers</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../4.convert_mtg/">Converting MTGs</a></li><li><a class="tocitem" href="../5.plotting/">Plotting</a></li><li><a class="tocitem" href="../6.add_remove_nodes/">Add/remove nodes</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Transform an MTG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transform an MTG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/master/docs/src/tutorials/3.transform_mtg.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Transform-an-MTG"><a class="docs-heading-anchor" href="#Transform-an-MTG">Transform an MTG</a><a id="Transform-an-MTG-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-an-MTG" title="Permalink"></a></h1><h2 id="A-note-on-anonymous-functions"><a class="docs-heading-anchor" href="#A-note-on-anonymous-functions">A note on anonymous functions</a><a id="A-note-on-anonymous-functions-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-anonymous-functions" title="Permalink"></a></h2><p>A lot of examples in this tutorial use anonymous functions. These functions are just a way to quickly define a function. For example a function that adds 1 to its input argument would usually be declared as follows:</p><pre><code class="language-julia hljs">function plus_one(x)
    x + 1
end</code></pre><p>Here we have a name for our function: &quot;plus_one&quot;. But sometimes we don&#39;t need to name our function because its only usage is to be passed to another function. In this case we can declare an anonymous function like so:</p><pre><code class="language-julia hljs">x -&gt; x + 1</code></pre><p>This is exactly the same function, but without a name.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We use <code>x</code> here because it is more or less of a standard, but we could use any other argument name. You&#39;ll see that we use <code>node</code> instead when referring to an MTG node (<code>node -&gt; node.name</code>), and <code>x</code> when we refer to a node attribute (<code>x -&gt; x + 1</code>).</p></div></div><h2 id="Introduction-to-MTG-transforming"><a class="docs-heading-anchor" href="#Introduction-to-MTG-transforming">Introduction to MTG transforming</a><a id="Introduction-to-MTG-transforming-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-MTG-transforming" title="Permalink"></a></h2><p>MTGs can be very large, and it quickly becomes impossible to manually change the attribute values of the nodes.</p><p>Instead, you can compute new attributes for all nodes in an MTG using <a href="../../api/#DataFrames.transform!"><code>transform!</code></a>.</p><p>The syntax of <a href="../../api/#DataFrames.transform!"><code>transform!</code></a> is very close to the one from <a href="https://dataframes.juliadata.org/stable/"><code>DataFrames.jl</code></a>. It has several forms that allow to perform computations either on the node or the node attributes directly.</p><p>Here is a summary of the different forms you can use:</p><ol><li>a <code>:var_name =&gt; :new_var_name</code> pair. This form is used to rename an attribute name</li><li>a <code>:var_name =&gt; function =&gt; :new_var_name</code> or <code>[:var_name1, :var_name2...] =&gt; function =&gt; :new_var_name</code>. The variables are declared as a <code>Symbol</code> or a <code>String</code> (or a vector of), and they are passed as positional arguments to <code>function</code>. The new variable name is optional, and is automatically generated if not provided by concatenating the source column name(s) and the function name if any, this form would be used as: <code>:var_name =&gt; function</code>.</li><li>a <code>function =&gt; :new_var_name</code> form that applies a function to a node and puts the results in a new attribute. This form is usually applied when searching ancestors or descendants values.</li><li>a <code>function</code> form that applies a mutating function to a node, without expecting any output. This form is used when using a function that already mutates the node, without the need to return anything, <em>e.g.</em> <a href="../../api/#MultiScaleTreeGraph.branching_order!-Tuple{Any}"><code>branching_order!</code></a>.</li></ol><p>This tutorial is a deep dive into these different forms.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All examples use the mutating version <a href="../../api/#DataFrames.transform!"><code>transform!</code></a>, but there is a non-mutating version too (<a href="../../api/#DataFrames.transform"><code>transform</code></a>). It is used likewise but returns a modified copy of the <code>mtg</code>, which is a little bit slower.</p></div></div><h2 id="Form-1:-Rename-an-attribute"><a class="docs-heading-anchor" href="#Form-1:-Rename-an-attribute">Form 1: Rename an attribute</a><a id="Form-1:-Rename-an-attribute-1"></a><a class="docs-heading-anchor-permalink" href="#Form-1:-Rename-an-attribute" title="Permalink"></a></h2><p>Renaming an attribute in an MTG is very simple. It uses the exact same syntax as <code>DataFrames.jl</code>. First, let&#39;s check which attributes are available in the MTG:</p><pre><code class="language-julia hljs">get_attributes(mtg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Symbol}:
 :scales
 :description
 :symbols
 :FileName
 :YY
 :ZZ
 :XX
 :Length
 :Width
 :XEuler</code></pre><p>Let&#39;s rename <code>:Width</code> to remove the capital letter and make it all lowercase:</p><pre><code class="language-julia hljs">transform!(mtg, :Width =&gt; :width)</code></pre><p>Let&#39;s check if the attribute name changed:</p><pre><code class="language-julia hljs">print(get_attributes(mtg))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[:scales, :description, :symbols, :FileName, :YY, :ZZ, :XX, :Length, :width, :XEuler]</code></pre><p>Yes it did!</p><p>The equivalent call with the non-mutating version of transform is:</p><pre><code class="language-julia hljs">new_mtg = transform(mtg, :Width =&gt; :width)

print(get_attributes(new_mtg))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[:scales, :description, :symbols, :FileName, :YY, :ZZ, :XX, :Length, :width, :XEuler]</code></pre><h2 id="Form-2:-Compute-new-attributes-based-on-other-attributes"><a class="docs-heading-anchor" href="#Form-2:-Compute-new-attributes-based-on-other-attributes">Form 2: Compute new attributes based on other attributes</a><a id="Form-2:-Compute-new-attributes-based-on-other-attributes-1"></a><a class="docs-heading-anchor-permalink" href="#Form-2:-Compute-new-attributes-based-on-other-attributes" title="Permalink"></a></h2><p>We can also compute a new attribute based on another one. For example we could need the length in meters instead of centimetres. To do so, we can compute it as follows:</p><pre><code class="language-julia hljs">transform!(mtg, :Length =&gt; (x -&gt; x / 10) =&gt; :length_m, ignore_nothing = true)</code></pre><p>The magic happens in the <code>:Length =&gt; (x -&gt; x / 10) =&gt; :length_m</code> expression. <code>transform!</code> takes the <code>:Length</code> variable as input (LHS, Left-hand side of the expression), and use it as the argument for the anonymous function given in the middle of the expression: <code>x -&gt; x / 10</code>. Then it puts the output of the function into a new variable named <code>:length_m</code> (RHS, Right-hand side of the expression)</p><p>In fewer words, we divide the <code>:Length</code> attribute by 10 for every node in the MTG, and put the results in a new attribute called <code>:length_m</code>.</p><p>We use <code>ignore_nothing = true</code> to tell <code>transform!</code> not to process the nodes with a value of <code>nothing</code> for the input variable (<code>:Length</code>). Otherwise our computation would error because the function we use do not handle <code>nothing</code> values well: <code>nothing / 10</code> returns an error.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The anonymous function must be surrounded by parenthesis (like in <code>DataFrames.jl</code>)</p></div></div><p>Let&#39;s check if we can find <code>:length_m</code> in the list of our MTG attributes:</p><pre><code class="language-julia hljs">print(get_attributes(mtg))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[:scales, :description, :symbols, :FileName, :YY, :ZZ, :XX, :Length, :length_m, :width, :XEuler]</code></pre><p>We can also get its values by using <a href="../../api/#MultiScaleTreeGraph.descendants"><code>descendants</code></a> on the root node:</p><pre><code class="language-julia hljs">descendants(mtg, :length_m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Any}:
  nothing
  nothing
 0.4
 1.0
 0.6
 1.2</code></pre><p>We can also get the values in the form of a DataFrame instead:</p><pre><code class="language-julia hljs">DataFrame(mtg, :length_m)</code></pre><div class="data-frame"><p>7 rows × 8 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>length_m</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, AbstractString}">Abstrac…?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: $</td><td>1</td><td>$</td><td>0</td><td>0</td><td><em>missing</em></td><td>/</td><td><em>missing</em></td></tr><tr><th>2</th><td>└─ / 2: Individual</td><td>2</td><td>Individual</td><td>1</td><td>0</td><td>1</td><td>/</td><td><em>missing</em></td></tr><tr><th>3</th><td>   └─ / 3: Axis</td><td>3</td><td>Axis</td><td>2</td><td>0</td><td>2</td><td>/</td><td><em>missing</em></td></tr><tr><th>4</th><td>      └─ / 4: Internode</td><td>4</td><td>Internode</td><td>3</td><td>0</td><td>3</td><td>/</td><td>0.4</td></tr><tr><th>5</th><td>         ├─ + 5: Leaf</td><td>5</td><td>Leaf</td><td>3</td><td>0</td><td>4</td><td>+</td><td>1.0</td></tr><tr><th>6</th><td>         └─ &lt; 6: Internode</td><td>6</td><td>Internode</td><td>3</td><td>1</td><td>4</td><td>&lt;</td><td>0.6</td></tr><tr><th>7</th><td>            └─ + 7: Leaf</td><td>7</td><td>Leaf</td><td>3</td><td>0</td><td>6</td><td>+</td><td>1.2</td></tr></tbody></table></div><p>We can also provide several input variables if we need:</p><pre><code class="language-julia hljs">transform!(mtg, [:Length, :width] =&gt; ((x,y) -&gt; π * x * y^2) =&gt; :volume_cm3, ignore_nothing = true)</code></pre><p>Here we provide the input attributes as a Vector of Symbols (could be String also), and given them to an anonymous function that takes two arguments as inputs. Our attributes are given to the anonymous function in order, <em>i.e</em> positional arguments. Then we name our new attribute <code>:volume_cm3</code>. Again, we use <code>ignore_nothing = true</code> to remove the nodes with <code>nothing</code> values for the input attributes <code>:Length</code> and <code>:width</code>.</p><p>Let&#39;s see the results:</p><pre><code class="language-julia hljs">DataFrame(mtg, [:Length, :width, :volume_cm3])</code></pre><div class="data-frame"><p>7 rows × 10 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>Length</th><th>width</th><th>volume_cm3</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, AbstractString}">Abstrac…?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th><th title="Union{Missing, Float64}">Float64?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: $</td><td>1</td><td>$</td><td>0</td><td>0</td><td><em>missing</em></td><td>/</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td></tr><tr><th>2</th><td>└─ / 2: Individual</td><td>2</td><td>Individual</td><td>1</td><td>0</td><td>1</td><td>/</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td></tr><tr><th>3</th><td>   └─ / 3: Axis</td><td>3</td><td>Axis</td><td>2</td><td>0</td><td>2</td><td>/</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td></tr><tr><th>4</th><td>      └─ / 4: Internode</td><td>4</td><td>Internode</td><td>3</td><td>0</td><td>3</td><td>/</td><td>4.0</td><td>1.0</td><td>12.5664</td></tr><tr><th>5</th><td>         ├─ + 5: Leaf</td><td>5</td><td>Leaf</td><td>3</td><td>0</td><td>4</td><td>+</td><td>10.0</td><td>6.0</td><td>1130.97</td></tr><tr><th>6</th><td>         └─ &lt; 6: Internode</td><td>6</td><td>Internode</td><td>3</td><td>1</td><td>4</td><td>&lt;</td><td>6.0</td><td><em>missing</em></td><td><em>missing</em></td></tr><tr><th>7</th><td>            └─ + 7: Leaf</td><td>7</td><td>Leaf</td><td>3</td><td>0</td><td>6</td><td>+</td><td>12.0</td><td>7.0</td><td>1847.26</td></tr></tbody></table></div><p>The new name of the attribute (the RHS) is optional though. We could write our first example as:</p><pre><code class="language-julia hljs">transform!(mtg, :Length =&gt; (x -&gt; x / 10), ignore_nothing = true)</code></pre><p>In this case the name of the new attribute is automatically computed based on the input variable name and the name of the function. If the function is anonymous, which is the case in our example, it uses the default &quot;function&quot; name instead. Our new variable name is then called <code>:Length_function</code>.</p><p>If we used a function with a name such as <code>log</code> instead of an anonymous function, the new attribute name would be <code>:Length_log</code>. Here&#39;s an example with the <code>log</code> function:</p><pre><code class="language-julia hljs">transform!(mtg, :Length =&gt; log, ignore_nothing = true)

print(get_attributes(mtg))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[:scales, :description, :symbols, :FileName, :YY, :ZZ, :XX, :Length_function, :volume_cm3, :Length, :length_m, :Length_log, :width, :XEuler]</code></pre><h2 id="Form-3:-Compute-a-new-attribute-based-on-node-values"><a class="docs-heading-anchor" href="#Form-3:-Compute-a-new-attribute-based-on-node-values">Form 3: Compute a new attribute based on node values</a><a id="Form-3:-Compute-a-new-attribute-based-on-node-values-1"></a><a class="docs-heading-anchor-permalink" href="#Form-3:-Compute-a-new-attribute-based-on-node-values" title="Permalink"></a></h2><p>We can compute a new attribute by providing a function directly as the right-hand side instead of an attribute name like so:</p><pre><code class="language-julia hljs">transform!(mtg, (node -&gt; node.MTG.symbol) =&gt; :Symbol)</code></pre><p>Here we just copied the MTG symbol onto the attributes of the nodes. In this form, it is mandatory to provide a name for the newly created variable, else the function is considered to not return anything (see next form: <a href="#Form-4:-Apply-a-function-to-nodes">Form 4: Apply a function to nodes</a>).</p><p>Because this form expects a function that works on nodes directly, it is now possible to use the <a href="../../api/#MultiScaleTreeGraph.descendants"><code>descendants</code></a> and <a href="../../api/#MultiScaleTreeGraph.ancestors-Tuple{Any, Any}"><code>ancestors</code></a> functions. For example we can compute the total length of the subtree of each node in an MTG (<em>i.e.</em> the length of all children of a node) as follows:</p><pre><code class="language-julia hljs">function get_length_descendants(x)
    nodes_lengths = descendants(x, :Length, ignore_nothing = true)
    if length(nodes_lengths) == 0
        return nothing
    else
        return sum(nodes_lengths)
    end
end

transform!(mtg, get_length_descendants =&gt; :length_subtree)

descendants(mtg, :length_subtree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Any}:
 32.0
 32.0
 28.0
   nothing
 12.0
   nothing</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This form cannot use <code>ignore_nothing = true</code> because it does not know which attributes to look for before-hand. You&#39;ll have to use the <code>filter_fun</code> argument or handle <code>nothing</code> values inside your function instead.</p></div></div><p>Here we first declared a new function to get the length of all descendants of a node (<code>get_length_descendants</code>), and then compute the sum only if one or more values for length were found. Then we pass this function to <code>transform!</code> and define our new attribute name as <code>:length_subtree</code>. We define the function first for clarity because it needs to handle <code>nothing</code> values properly before the call to <code>sum</code>.</p><p>An alternative way to write this would be to first get the vector of length for each node, and then to compute the sum like so:</p><pre><code class="language-julia hljs">transform!(
    mtg,
    (node -&gt; descendants(node, :Length, ignore_nothing = true)) =&gt; :length_subtree2,
    :length_subtree2 =&gt; (x -&gt; length(x) == 0 ? nothing : sum(x)) =&gt; :length_subtree2
)</code></pre><p>Because <code>transform!</code> computes the expressions sequentially, we can re-use a computation from the last expression. This is exactly what we are doing here. First we get the values of the length of all descendants of each node, and put the result in a new attribute <code>:length_subtree2</code>. Then we re-use the data from this attribute to compute its sum, but only if the length of the data is not <code>0</code>, and put the result back to the same attribute <code>:length_subtree2</code>.</p><p>We can test if both calls returns the same output:</p><pre><code class="language-julia hljs">all(descendants(mtg, :length_subtree2) .== descendants(mtg, :length_subtree))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Yes they are!</p><h2 id="Form-4:-Apply-a-function-to-nodes"><a class="docs-heading-anchor" href="#Form-4:-Apply-a-function-to-nodes">Form 4: Apply a function to nodes</a><a id="Form-4:-Apply-a-function-to-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Form-4:-Apply-a-function-to-nodes" title="Permalink"></a></h2><p>We can also apply a function that performs a computation on the node like Form 3, but does not return a new attribute value. For example it can be useful to use a printing function to help us debug another function call. Here&#39;s an example where we want to print the name of the nodes that are leaf nodes:</p><pre><code class="language-julia hljs">transform!(mtg, node -&gt; isleaf(node) ? println(node.name,&quot; is a leaf&quot;) : nothing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">node_5 is a leaf
node_7 is a leaf</code></pre><p>We can also use this form to mutate the MTG of a node (which is not possible with Form 2). Here&#39;s an example where we change the &quot;Internode&quot; symbol into &quot;I&quot;:</p><pre><code class="language-julia hljs">transform!(mtg, node -&gt; node.MTG.symbol = &quot;I&quot;, symbol = &quot;Internode&quot;)

mtg</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: $
└─ / 2: Individual
   └─ / 3: Axis
      └─ / 4: I
         ├─ + 5: Leaf
         └─ &lt; 6: I
            └─ + 7: Leaf
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you change the values of the MTG field of the nodes, you can update the header of the MTG stored in the root node. For example here we updated the symbols, so we should do:</p><pre><code class="language- hljs">mtg[:symbols] = get_classes(mtg).SYMBOL
mtg[:description] = get_description(mtg)</code></pre><p>Note that it is not important for writing back to disc as they are automatically updated anyway.</p></div></div><h2 id="Select-an-MTG"><a class="docs-heading-anchor" href="#Select-an-MTG">Select an MTG</a><a id="Select-an-MTG-1"></a><a class="docs-heading-anchor-permalink" href="#Select-an-MTG" title="Permalink"></a></h2><p>As in DataFrames, <code>MultiScaleTreeGraph.jl</code> provides a <a href="../../api/#DataFrames.select!-Tuple{Node, Vararg{Any, N} where N}"><code>select!</code></a> function for deleting all attributes not explicitly provided as arguments to the selection. The selection can also apply transformations on the fly following the same format used in <a href="../../api/#DataFrames.transform!"><code>transform!</code></a>, with one more Form though: just the name of the variable to select.</p><p>For example we can compute the new length in meters, and keep only this result along with the width as follows:</p><pre><code class="language-julia hljs">mtg_select = deepcopy(mtg)

select!(mtg_select, :Length =&gt; (x -&gt; x / 10) =&gt; :length_m, :Width, ignore_nothing = true)

DataFrame(mtg_select)</code></pre><div class="data-frame"><p>7 rows × 8 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>length_m</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, AbstractString}">Abstrac…?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: $</td><td>1</td><td>$</td><td>0</td><td>0</td><td><em>missing</em></td><td>/</td><td><em>missing</em></td></tr><tr><th>2</th><td>└─ / 2: Individual</td><td>2</td><td>Individual</td><td>1</td><td>0</td><td>1</td><td>/</td><td><em>missing</em></td></tr><tr><th>3</th><td>   └─ / 3: Axis</td><td>3</td><td>Axis</td><td>2</td><td>0</td><td>2</td><td>/</td><td><em>missing</em></td></tr><tr><th>4</th><td>      └─ / 4: I</td><td>4</td><td>I</td><td>3</td><td>0</td><td>3</td><td>/</td><td>0.4</td></tr><tr><th>5</th><td>         ├─ + 5: Leaf</td><td>5</td><td>Leaf</td><td>3</td><td>0</td><td>4</td><td>+</td><td>1.0</td></tr><tr><th>6</th><td>         └─ &lt; 6: I</td><td>6</td><td>I</td><td>3</td><td>1</td><td>4</td><td>&lt;</td><td>0.6</td></tr><tr><th>7</th><td>            └─ + 7: Leaf</td><td>7</td><td>Leaf</td><td>3</td><td>0</td><td>6</td><td>+</td><td>1.2</td></tr></tbody></table></div><p>There is also a non-mutating version of the function:</p><pre><code class="language-julia hljs">mtg_select = select(mtg, :Length =&gt; (x -&gt; x / 10) =&gt; :length_m, :Width, ignore_nothing = true)

DataFrame(mtg_select)</code></pre><div class="data-frame"><p>7 rows × 8 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>length_m</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, AbstractString}">Abstrac…?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: $</td><td>1</td><td>$</td><td>0</td><td>0</td><td><em>missing</em></td><td>/</td><td><em>missing</em></td></tr><tr><th>2</th><td>└─ / 2: Individual</td><td>2</td><td>Individual</td><td>1</td><td>0</td><td>1</td><td>/</td><td><em>missing</em></td></tr><tr><th>3</th><td>   └─ / 3: Axis</td><td>3</td><td>Axis</td><td>2</td><td>0</td><td>2</td><td>/</td><td><em>missing</em></td></tr><tr><th>4</th><td>      └─ / 4: I</td><td>4</td><td>I</td><td>3</td><td>0</td><td>3</td><td>/</td><td>0.4</td></tr><tr><th>5</th><td>         ├─ + 5: Leaf</td><td>5</td><td>Leaf</td><td>3</td><td>0</td><td>4</td><td>+</td><td>1.0</td></tr><tr><th>6</th><td>         └─ &lt; 6: I</td><td>6</td><td>I</td><td>3</td><td>1</td><td>4</td><td>&lt;</td><td>0.6</td></tr><tr><th>7</th><td>            └─ + 7: Leaf</td><td>7</td><td>Leaf</td><td>3</td><td>0</td><td>6</td><td>+</td><td>1.2</td></tr></tbody></table></div><h2 id="Traverse-an-MTG"><a class="docs-heading-anchor" href="#Traverse-an-MTG">Traverse an MTG</a><a id="Traverse-an-MTG-1"></a><a class="docs-heading-anchor-permalink" href="#Traverse-an-MTG" title="Permalink"></a></h2><p><a href="../../api/#DataFrames.transform!"><code>transform!</code></a> and <a href="../../api/#DataFrames.select!-Tuple{Node, Vararg{Any, N} where N}"><code>select!</code></a> use <a href="../../api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>traverse!</code></a> under the hood to apply a function call to each node of an MTG. <a href="../../api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>traverse!</code></a> is just a little bit less easy to use as it only accepts Form 4. We can obtain the exact same results as the last example of <a href="../../api/#DataFrames.transform!"><code>transform!</code></a> using the same call with <a href="../../api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>traverse!</code></a>. Let&#39;s change the <code>Leaf</code> symbol into <code>L</code>:</p><pre><code class="language-julia hljs">traverse!(mtg, node -&gt; node.MTG.symbol = &quot;L&quot;, symbol = &quot;Leaf&quot;)

mtg</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: $
└─ / 2: Individual
   └─ / 3: Axis
      └─ / 4: I
         ├─ + 5: L
         └─ &lt; 6: I
            └─ + 7: L
</code></pre><p>A benefit of <a href="../../api/#MultiScaleTreeGraph.traverse!-Tuple{Node, Function, Vararg{Any, N} where N}"><code>traverse!</code></a> is it can be used with a <code>do...end</code> block notation for complex sets of instructions:</p><pre><code class="language-julia hljs">traverse!(mtg) do x
    if isleaf(x)
         println(x.name,&quot; is a leaf&quot;)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">node_5 is a leaf
node_7 is a leaf</code></pre><h2 id="Mutate-an-MTG"><a class="docs-heading-anchor" href="#Mutate-an-MTG">Mutate an MTG</a><a id="Mutate-an-MTG-1"></a><a class="docs-heading-anchor-permalink" href="#Mutate-an-MTG" title="Permalink"></a></h2><p>For users coming from R, we also provide the <code>@mutate_mtg!</code> macro that is similar to <a href="../../api/#DataFrames.transform!"><code>transform!</code></a> but uses a more <code>tidyverse</code>-alike syntax. All values coming from the MTG node must be preceded by a <code>node.</code>, as with the <code>.data$</code> in the <code>tidyverse</code>. The names of the attributes are shortened to just <code>node.attr_name</code> instead of <code>node.attributes.attr_name</code> though. Here&#39;s an example usage:</p><pre><code class="language-julia hljs">@mutate_mtg!(mtg, volume = π * 2 * node.Length, symbol = &quot;I&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: The symbol argument should be one of: SubString{String}[&quot;\$&quot;, &quot;Individual&quot;, &quot;Axis&quot;, &quot;Internode&quot;, &quot;Leaf&quot;], and you provided I.
└ @ MultiScaleTreeGraph ~/work/MultiScaleTreeGraph.jl/MultiScaleTreeGraph.jl/src/compute_MTG/check_filters.jl:40</code></pre><p>We see that we first name the new attribute and assign the result of the computation. Constants are provided as is, and values coming from the nodes are prefixes by <code>node.</code>.</p><h2 id="Helpers"><a class="docs-heading-anchor" href="#Helpers">Helpers</a><a id="Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers" title="Permalink"></a></h2><p>You can use helper functions provided by <code>MultiScaleTreeGraph.jl</code> for:</p><ul><li>Filtering nodes: <a href="../../api/#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>isroot</code></a>, <a href="../../api/#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a></li><li>Compute the number of leaf nodes in the subtree of a node: <a href="../../api/#MultiScaleTreeGraph.nleaves"><code>nleaves</code></a></li><li>Apply the <a href="../../api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>pipe_model!</code></a> to the MTG to compute the cross-section of all nodes based on an initial cross-section.</li></ul><p>The pipe model is used in plant physiology (especially on trees) and is built around the coarse hypothesis that each leaf in a plant is (to some extent) connected to the roots via a &quot;pipe&quot; of constant cross-sectional area. The concepts of the pipe model are detailed in Lehnebach et al. (2018).</p><p>This package provides an implementation of the pipe model, used as follows:</p><pre><code class="language-julia hljs">first_cross_section = 0.34 # the initial cross-section of the plant

transform!(mtg, (node -&gt; pipe_model!(node, first_cross_section)) =&gt; :cross_section_pipe)
DataFrame(mtg, :cross_section_pipe)</code></pre><div class="data-frame"><p>7 rows × 8 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>cross_section_pipe</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, AbstractString}">Abstrac…?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: $</td><td>1</td><td>$</td><td>0</td><td>0</td><td><em>missing</em></td><td>/</td><td>0.34</td></tr><tr><th>2</th><td>└─ / 2: Individual</td><td>2</td><td>Individual</td><td>1</td><td>0</td><td>1</td><td>/</td><td>0.34</td></tr><tr><th>3</th><td>   └─ / 3: Axis</td><td>3</td><td>Axis</td><td>2</td><td>0</td><td>2</td><td>/</td><td>0.34</td></tr><tr><th>4</th><td>      └─ / 4: I</td><td>4</td><td>I</td><td>3</td><td>0</td><td>3</td><td>/</td><td>0.34</td></tr><tr><th>5</th><td>         ├─ + 5: L</td><td>5</td><td>L</td><td>3</td><td>0</td><td>4</td><td>+</td><td>0.113333</td></tr><tr><th>6</th><td>         └─ &lt; 6: I</td><td>6</td><td>I</td><td>3</td><td>1</td><td>4</td><td>&lt;</td><td>0.226667</td></tr><tr><th>7</th><td>            └─ + 7: L</td><td>7</td><td>L</td><td>3</td><td>0</td><td>6</td><td>+</td><td>0.226667</td></tr></tbody></table></div><p>For more information about the implementation, you can check the documentation of the function: <a href="../../api/#MultiScaleTreeGraph.pipe_model!-Tuple{Any, Any, Any}"><code>pipe_model!</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>R. Lehnebach, R. Beyer, V. Letort, et P. Heuret, « The pipe model theory half a century on: a review », Annals of Botany, vol. 121, nᵒ 5, p. 773‑795, avr. 2018, doi: 10.1093/aob/mcx194.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2.descendants_ancestors_filters/">« Node attributes</a><a class="docs-footer-nextpage" href="../4.convert_mtg/">Converting MTGs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 6 January 2022 17:32">Thursday 6 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
