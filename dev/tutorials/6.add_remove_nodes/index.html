<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Add/remove nodes · MultiScaleTreeGraph.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/MultiScaleTreeGraph.jl/tutorials/6.add_remove_nodes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultiScaleTreeGraph.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/">Getting started</a></li><li><span class="tocitem">The MTG format</span><ul><li><a class="tocitem" href="../../the_mtg/mtg_concept/">Concept</a></li><li><a class="tocitem" href="../../the_mtg/mtg_format/">File format</a></li><li><a class="tocitem" href="../../the_mtg/our_implementation/">Our implementation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../0.read_write/">Read and Write MTGs</a></li><li><a class="tocitem" href="../1.manipulate_node/">Manipulate nodes</a></li><li><a class="tocitem" href="../2.descendants_ancestors_filters/">Computing</a></li><li><a class="tocitem" href="../3.transform_mtg/">Transform an MTG</a></li><li><a class="tocitem" href="../4.convert_mtg/">Converting MTGs</a></li><li><a class="tocitem" href="../5.plotting/">Plotting</a></li><li class="is-active"><a class="tocitem" href>Add/remove nodes</a><ul class="internal"><li><a class="tocitem" href="#Make-an-MTG-manually"><span>Make an MTG manually</span></a></li><li><a class="tocitem" href="#Insert/remove-nodes-programmatically"><span>Insert/remove nodes programmatically</span></a></li><li><a class="tocitem" href="#Delete-nodes"><span>Delete nodes</span></a></li><li><a class="tocitem" href="#Add-nodes"><span>Add nodes</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Add/remove nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Add/remove nodes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/master/docs/src/tutorials/6.add_remove_nodes.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Add/remove-nodes"><a class="docs-heading-anchor" href="#Add/remove-nodes">Add/remove nodes</a><a id="Add/remove-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Add/remove-nodes" title="Permalink"></a></h1><h2 id="Make-an-MTG-manually"><a class="docs-heading-anchor" href="#Make-an-MTG-manually">Make an MTG manually</a><a id="Make-an-MTG-manually-1"></a><a class="docs-heading-anchor-permalink" href="#Make-an-MTG-manually" title="Permalink"></a></h2><p>It is very easy to add or remove nodes in an MTG. Actually, we can even construct an MTG completely manually.</p><h3 id="Root-node"><a class="docs-heading-anchor" href="#Root-node">Root node</a><a id="Root-node-1"></a><a class="docs-heading-anchor-permalink" href="#Root-node" title="Permalink"></a></h3><p>Create the root node:</p><pre><code class="language-julia hljs">mtg = Node(&quot;node_1&quot;, MutableNodeMTG(&quot;/&quot;, &quot;Plant&quot;, 0, 1), Dict{Symbol,Any}(:species =&gt; &quot;Grassy-plant&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
</code></pre><p>The first argument to <a href="../../api/#MultiScaleTreeGraph.Node"><code>Node</code></a> is the name. For the root node we usually use &quot;node_1&quot;. The second argument is a <a href="../../api/#MultiScaleTreeGraph.MutableNodeMTG"><code>MutableNodeMTG</code></a> (or a <a href="../../api/#MultiScaleTreeGraph.NodeMTG"><code>NodeMTG</code></a>) that defines the topology of the node: its link to its parent (the root node always decomposes), its symbol, its index and its scale. The third and last argument is used to add attributes to the MTG.</p><h3 id="Node-name"><a class="docs-heading-anchor" href="#Node-name">Node name</a><a id="Node-name-1"></a><a class="docs-heading-anchor-permalink" href="#Node-name" title="Permalink"></a></h3><p>The names of the nodes must be unique and indexed. This package provides a function that guaranties a new name is unique in the MTG:</p><pre><code class="language-julia hljs">new_name = MultiScaleTreeGraph.new_name(mtg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;node_2&quot;</code></pre><h3 id="Adding-children-nodes"><a class="docs-heading-anchor" href="#Adding-children-nodes">Adding children nodes</a><a id="Adding-children-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-children-nodes" title="Permalink"></a></h3><p>To create a child node, we use a different method of <a href="../../api/#MultiScaleTreeGraph.Node"><code>Node</code></a>. This method is close to the one we used for the root, except there is a new argument at the second position: the parent node. Here we use the root node as the parent (<code>mtg</code>), and the unique name (<code>new_name</code>) as the child name.</p><pre><code class="language-julia hljs">IN1 = Node(new_name, mtg, MutableNodeMTG(&quot;/&quot;, &quot;Internode&quot;, 0, 2), Dict{Symbol,Any}(:diameter =&gt; 0.1, :length =&gt; 0.5))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 2: Internode
</code></pre><p>Now the MTG has two nodes:</p><pre><code class="language-julia hljs">mtg</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
└─ / 2: Internode
</code></pre><p>We can continue like this indefinitely. For example we can add a leaf to the first internode:</p><pre><code class="language-julia hljs">Node(MultiScaleTreeGraph.new_name(mtg), IN1, MutableNodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 0, 2), Dict{Symbol,Any}(:area =&gt; 0.2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">+ 3: Leaf
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a node has no children, there is no need to keep track of it in an object.</p></div></div><p>And an internode following the first internode:</p><pre><code class="language-julia hljs">IN2 = Node(MultiScaleTreeGraph.new_name(mtg), IN1, MutableNodeMTG(&quot;&lt;&quot;, &quot;Internode&quot;, 1, 2), Dict{Symbol,Any}(:diameter =&gt; 0.15, :length =&gt; 0.3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&lt; 4: Internode
</code></pre><p>And a leaf to it:</p><pre><code class="language-julia hljs">Node(MultiScaleTreeGraph.new_name(mtg), IN2, MutableNodeMTG(&quot;+&quot;, &quot;Leaf&quot;, 1, 2), Dict{Symbol,Any}(:area =&gt; 0.2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">+ 5: Leaf
</code></pre><p>And here is our resulting MTG:</p><pre><code class="language-julia hljs">mtg</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
└─ / 2: Internode
   ├─ + 3: Leaf
   └─ &lt; 4: Internode
      └─ + 5: Leaf
</code></pre><p>And the attributes:</p><pre><code class="language-julia hljs">DataFrame(mtg, get_attributes(mtg))</code></pre><div class="data-frame"><p>5 rows × 11 columns</p><table class="data-frame"><thead><tr><th></th><th>tree</th><th>id</th><th>symbol</th><th>scale</th><th>index</th><th>parent_id</th><th>link</th><th>species</th><th>diameter</th><th>length</th><th>area</th></tr><tr><th></th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, Int64}">Int64?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, String}">String?</th><th title="Union{Missing, Float64}">Float64?</th><th title="Union{Missing, Float64}">Float64?</th><th title="Union{Missing, Float64}">Float64?</th></tr></thead><tbody><tr><th>1</th><td>/ 1: Plant</td><td>1</td><td>Plant</td><td>1</td><td>0</td><td><em>missing</em></td><td>/</td><td>Grassy-plant</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td></tr><tr><th>2</th><td>└─ / 2: Internode</td><td>2</td><td>Internode</td><td>2</td><td>0</td><td>1</td><td>/</td><td><em>missing</em></td><td>0.1</td><td>0.5</td><td><em>missing</em></td></tr><tr><th>3</th><td>   ├─ + 3: Leaf</td><td>3</td><td>Leaf</td><td>2</td><td>0</td><td>2</td><td>+</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td><td>0.2</td></tr><tr><th>4</th><td>   └─ &lt; 4: Internode</td><td>4</td><td>Internode</td><td>2</td><td>1</td><td>2</td><td>&lt;</td><td><em>missing</em></td><td>0.15</td><td>0.3</td><td><em>missing</em></td></tr><tr><th>5</th><td>      └─ + 5: Leaf</td><td>5</td><td>Leaf</td><td>2</td><td>1</td><td>4</td><td>+</td><td><em>missing</em></td><td><em>missing</em></td><td><em>missing</em></td><td>0.2</td></tr></tbody></table></div><h3 id="Delete-a-node"><a class="docs-heading-anchor" href="#Delete-a-node">Delete a node</a><a id="Delete-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-a-node" title="Permalink"></a></h3><p>It is possible to remove a single node in an MTG using <a href="../../api/#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>delete_node!</code></a>. For example if we want to delete the second internode (&quot;node_4&quot;):</p><pre><code class="language-julia hljs">mtg_del = deepcopy(mtg)

delete_node!(get_node(mtg_del, &quot;node_4&quot;))

mtg_del</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
└─ / 2: Internode
   ├─ + 3: Leaf
   └─ + 5: Leaf
</code></pre><p>As we can see the new MTG has only one internode now, and the children of the second internode are now the children of its parents, the first internode.</p><p>But what if we deleted the first internode?</p><pre><code class="language-julia hljs">mtg_del = deepcopy(mtg)

delete_node!(get_node(mtg_del, &quot;node_2&quot;))

mtg_del</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
├─ + 3: Leaf
└─ / 4: Internode
   └─ + 5: Leaf
</code></pre><p>We see there is a warning now. This is because we don&#39;t really know what should be the new link for a branching child replacing a decomposing node. So by default we don&#39;t make any assumption and keep the scale of the child as it is, in the hope the user will look into it.</p><p>In our example the first leaf is now branching from the plant, while it should decompose it because it is not of the same scale. But a leaf decomposing a Plant has no meaning botanically. The best approach would be to keep an intermediary node, as it was before.</p><p>The user can define its own rules for the new links using the <code>child_link_fun</code> keyword argument of <a href="../../api/#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>delete_node!</code></a>. It expect a function that takes the child node as input and return its new link.</p><p>For example one could decide to never replace the children link and manage them afterward. In this case we can use the identity function like this:</p><pre><code class="language-julia hljs">mtg_del = deepcopy(mtg)

delete_node!(get_node(mtg_del, &quot;node_2&quot;), child_link_fun = node -&gt; node.MTG.link)

mtg_del</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
├─ + 3: Leaf
└─ &lt; 4: Internode
   └─ + 5: Leaf
</code></pre><p>It didn&#39;t change anything here because the child already kept its own link. But it will differ for other types of parent / children links.</p><h2 id="Insert/remove-nodes-programmatically"><a class="docs-heading-anchor" href="#Insert/remove-nodes-programmatically">Insert/remove nodes programmatically</a><a id="Insert/remove-nodes-programmatically-1"></a><a class="docs-heading-anchor-permalink" href="#Insert/remove-nodes-programmatically" title="Permalink"></a></h2><p>Sometimes we want to remove or add a lot of nodes in an MTG. This is possible to do it programmatically using <a href="../../api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> and <a href="tutorials/@ref"><code>insert_nodes</code></a> respectively.</p><h2 id="Delete-nodes"><a class="docs-heading-anchor" href="#Delete-nodes">Delete nodes</a><a id="Delete-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-nodes" title="Permalink"></a></h2><p>We can remove all nodes that meet specific conditions given by the usual node filters (see <a href="../2.descendants_ancestors_filters/#Filters">Filters</a> for more details). For example one could remove all nodes of scale 2 in an MTG, <em>i.e.</em> all nodes except the Plant in our example:</p><pre><code class="language-julia hljs">mtg_2 = deepcopy(mtg)

delete_nodes!(mtg_2, scale = 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
</code></pre><p>We can also remove nodes with more complex filters, for example all nodes with an index greater or equal to 1:</p><pre><code class="language-julia hljs">mtg_3 = deepcopy(mtg)

delete_nodes!(mtg_3, filter_fun = node -&gt; node.MTG.index &gt;= 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
└─ / 2: Internode
   └─ + 3: Leaf
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="../../api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> always return the root node of the MTG. If the root node of the original MTG is deleted, its child becomes the new root node. If the root had several children, it returns an error. The function always return the root node of the new MTG, so if the root has not been modified, it remains the same, but if it has been deleted, the new root is returned. That is why it is preferable to use <a href="../../api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> has a non-mutating function and re-assign the results to an object if it is planned to remove the root node.</p></div></div><p>As for <a href="../../api/#MultiScaleTreeGraph.delete_node!-Tuple{Any}"><code>delete_node!</code></a> (singular), by default <a href="../../api/#MultiScaleTreeGraph.delete_nodes!-Tuple{Any}"><code>delete_nodes!</code></a> (plural) uses <a href="../../api/#MultiScaleTreeGraph.new_child_link-Tuple{Any}"><code>new_child_link</code></a> to re-link the children of the deleted nodes, but the user can provide a custom function. See the function details to learn more about it.</p><h2 id="Add-nodes"><a class="docs-heading-anchor" href="#Add-nodes">Add nodes</a><a id="Add-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Add-nodes" title="Permalink"></a></h2><p>We can add new nodes in an MTG programmatically using <a href="../../api/#MultiScaleTreeGraph.insert_nodes!-Tuple{Any, Any}"><code>insert_nodes!</code></a>. The function insert new nodes based on a template NodeMTG provided by the user. The new nodes are inserted <strong>before</strong> the the filtered nodes, because it is impossible to decide beforehand if a new node would be considered as a new child or parent of the children otherwise. The name of the inserted node is automatically computed using <a href="tutorials/@ref"><code>new_name</code></a>.</p><p>For example if we need to insert new nodes before each leaf, we would do:</p><pre><code class="language-julia hljs">mtg_4 = deepcopy(mtg)
template = MutableNodeMTG(&quot;+&quot;, &quot;Flower&quot;, 0, 2)
insert_nodes!(mtg_4, template, symbol = &quot;Leaf&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: Plant
└─ / 2: Internode
   ├─ + 6: Flower
   │  └─ + 3: Leaf
   └─ &lt; 4: Internode
      └─ + 7: Flower
         └─ + 5: Leaf
</code></pre><p>The function does not do anything fancy, its sole job is to insert a new node at a given position with a template <code>NodeMTG</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../5.plotting/">« Plotting</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 1 December 2021 15:56">Wednesday 1 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
