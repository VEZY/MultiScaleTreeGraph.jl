<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computing · MultiScaleTreeGraph.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://VEZY.github.io/MultiScaleTreeGraph.jl/tutorials/2.descendants_ancestors_filters/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MultiScaleTreeGraph.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/">Getting started</a></li><li><span class="tocitem">The MTG format</span><ul><li><a class="tocitem" href="../../the_mtg/mtg_concept/">Concept</a></li><li><a class="tocitem" href="../../the_mtg/mtg_format/">File format</a></li><li><a class="tocitem" href="../../the_mtg/our_implementation/">Our implementation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../0.read_write/">Read and Write MTGs</a></li><li><a class="tocitem" href="../1.manipulate_node/">Manipulate nodes</a></li><li class="is-active"><a class="tocitem" href>Computing</a><ul class="internal"><li><a class="tocitem" href="#Descendants"><span>Descendants</span></a></li><li><a class="tocitem" href="#Ancestors"><span>Ancestors</span></a></li><li><a class="tocitem" href="#Filters"><span>Filters</span></a></li><li><a class="tocitem" href="#Transform-values"><span>Transform values</span></a></li><li><a class="tocitem" href="#Helpers"><span>Helpers</span></a></li></ul></li><li><a class="tocitem" href="../3.transform_mtg/">Transform an MTG</a></li><li><a class="tocitem" href="../4.convert_mtg/">Converting MTGs</a></li><li><a class="tocitem" href="../5.plotting/">Plotting</a></li><li><a class="tocitem" href="../6.add_remove_nodes/">Add/remove nodes</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Computing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/MultiScaleTreeGraph.jl/blob/master/docs/src/tutorials/2.descendants_ancestors_filters.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computing"><a class="docs-heading-anchor" href="#Computing">Computing</a><a id="Computing-1"></a><a class="docs-heading-anchor-permalink" href="#Computing" title="Permalink"></a></h1><p>An MTG can hold a lot of information, usually measured locally at one given scale. It is often interesting to compute new attributes based on the topological environment of the nodes.</p><p>For example one could be interested in computing how many leaves a plant has in total.</p><p>Let&#39;s first read our example MTG:</p><pre><code class="language-julia hljs">using MultiScaleTreeGraph

file = joinpath(dirname(dirname(pathof(MultiScaleTreeGraph))),&quot;test&quot;,&quot;files&quot;,&quot;simple_plant.mtg&quot;)
mtg = read_mtg(file)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/ 1: $
└─ / 2: Individual
   └─ / 3: Axis
      └─ / 4: Internode
         ├─ + 5: Leaf
         └─ &lt; 6: Internode
            └─ + 7: Leaf
</code></pre><h2 id="Descendants"><a class="docs-heading-anchor" href="#Descendants">Descendants</a><a id="Descendants-1"></a><a class="docs-heading-anchor-permalink" href="#Descendants" title="Permalink"></a></h2><p>It is very easy to get the values of an attribute for all descendants of a node. For example to get the length attributes we would do:</p><pre><code class="language-julia hljs">descendants(mtg, :Length)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Any}:
   nothing
   nothing
  4.0
 10.0
  6.0
 12.0</code></pre><p>The <code>descendants</code> function visits every children nodes recursively until finding a leaf node. The function visits the branching nodes first.</p><h2 id="Ancestors"><a class="docs-heading-anchor" href="#Ancestors">Ancestors</a><a id="Ancestors-1"></a><a class="docs-heading-anchor-permalink" href="#Ancestors" title="Permalink"></a></h2><p>To get the values of an attribute from the ancestors of a node, we would similarly do:</p><pre><code class="language-julia hljs">node_5 = get_node(mtg, &quot;node_5&quot;)
ancestors(node_5, :Length)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 4.0
  nothing
  nothing
  nothing</code></pre><h2 id="Filters"><a class="docs-heading-anchor" href="#Filters">Filters</a><a id="Filters-1"></a><a class="docs-heading-anchor-permalink" href="#Filters" title="Permalink"></a></h2><p>Sometimes we only want the values of descendants or ancestors based on a given information. It is possible to filter out nodes based on their scale, symbol, link, or really anything by using the keyword arguments.</p><h3 id="Filter-by-scale"><a class="docs-heading-anchor" href="#Filter-by-scale">Filter by scale</a><a id="Filter-by-scale-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-by-scale" title="Permalink"></a></h3><p>For example if we want the length of all descendants of the root node of our MTG that are of scale 3 (leaves &amp; internodes), we would simply do:</p><pre><code class="language-julia hljs">descendants(mtg, :Length, scale = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
  4.0
 10.0
  6.0
 12.0</code></pre><h3 id="Filter-by-symbol"><a class="docs-heading-anchor" href="#Filter-by-symbol">Filter by symbol</a><a id="Filter-by-symbol-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-by-symbol" title="Permalink"></a></h3><p>If we need only the leaves, we would filter by their symbol (<em>i.e.</em> &quot;Leaf&quot;):</p><pre><code class="language-julia hljs">descendants(mtg, :Length, symbol = &quot;Leaf&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 10.0
 12.0</code></pre><h3 id="Filter-by-anything"><a class="docs-heading-anchor" href="#Filter-by-anything">Filter by anything</a><a id="Filter-by-anything-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-by-anything" title="Permalink"></a></h3><p>And if we want to filter depending on an arbitrary value, we can use the <code>filter_fun</code> argument. For example if we want the length of the nodes, but only the ones with a width greater than 1, will would do like so:</p><pre><code class="language-julia hljs">descendants(mtg, :Length, filter_fun = x -&gt; x[:Width] === nothing ? false : x[:Width] &gt; 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 10.0
 12.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function passed to <code>filter_fun</code> must take a node as input, not attributes directly. This is because we want to be able to access any information the user could need. By using nodes as inputs we can even filter on a node parent or children, on a combination of its topological information, or by any of its attributes.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default if a node does not have an attribute, trying to get its value returns <code>nothing</code>. So if one uses attributes in the function passed to <code>filter_fun</code>, the function must handle missing values. This is what we do here by first testing if <code>x[:Width]</code> is <code>nothing</code> (in which case we return <code>false</code> to filter out the node), and then apply our test on the value of the node width.</p></div></div><h3 id="Filter-helpers"><a class="docs-heading-anchor" href="#Filter-helpers">Filter helpers</a><a id="Filter-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-helpers" title="Permalink"></a></h3><p>There are three other arguments to help filtering nodes.</p><p>The first one is <code>all</code>. It is used to stop the search for new nodes as soon as one node does not correspond to the filters the user asked for.</p><p>It is generally used to get all nodes that are following a node for example. You can find an example usage <a href="https://github.com/VEZY/Biomass_evaluation_LiDAR/blob/98576d0d2e9b9cfc9588451cc2bce42df68a6c87/1-code/functions.jl#L54">here</a> if you need one.</p><p>The second one is the <code>self</code> argument. It is used to return the value of the node on which we call the function if its <code>true</code>, and only the ancestors / descendants if <code>false</code> (the default).</p><p>The third one is the <code>recursivity_level</code>, that is used to control the depth of the search for the  ancestors / descendants. It is set to <code>-1</code> by default, which does not apply any filter on the depth. It is generally used to get <em>e.g.</em> only the children values of a node (<code>recursivity_level = 1</code>).</p><p>The fourth one is <code>ignore_nothing</code>. It is used to not return the values of a node if it is <code>nothing</code>. Note that it is applied <strong>after</strong> the filter, so <code>filter_fun</code> still has to handle <code>nothing</code> values.</p><h2 id="Transform-values"><a class="docs-heading-anchor" href="#Transform-values">Transform values</a><a id="Transform-values-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-values" title="Permalink"></a></h2><h3 id="Assign-attributes-to-a-node"><a class="docs-heading-anchor" href="#Assign-attributes-to-a-node">Assign attributes to a node</a><a id="Assign-attributes-to-a-node-1"></a><a class="docs-heading-anchor-permalink" href="#Assign-attributes-to-a-node" title="Permalink"></a></h3><p>It is possible to change the values of attributes in a node. For example one could be interested to compute the total length of all nodes for the scene in our example MTG. In this case we can do:</p><pre><code class="language-julia hljs">mtg[:Length] = sum(descendants(mtg, :Length, ignore_nothing = true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32.0</code></pre><h3 id="Compute-attributes-in-an-MTG"><a class="docs-heading-anchor" href="#Compute-attributes-in-an-MTG">Compute attributes in an MTG</a><a id="Compute-attributes-in-an-MTG-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-attributes-in-an-MTG" title="Permalink"></a></h3><p>Now MTGs can be very large, and it quickly becomes cumbersome to manually visit each node to change its value.</p><p>Instead, you can compute new attributes for all nodes in an MTG using <a href="../../api/#DataFrames.transform"><code>transform</code></a>. Head to the next tutorial for more information: <a href="../3.transform_mtg/#Transform-an-MTG">Transform an MTG</a>.</p><h2 id="Helpers"><a class="docs-heading-anchor" href="#Helpers">Helpers</a><a id="Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers" title="Permalink"></a></h2><p>Some helper functions can be useful when filtering nodes. For example you can use <a href="../../api/#MultiScaleTreeGraph.isroot-Tuple{Node}"><code>isroot</code></a> to test if a node is the root node of the MTG. This is particularly useful when searching for ancestor values, but need a special treatment for the root node.</p><p>Similarly, you can use <a href="../../api/#MultiScaleTreeGraph.isleaf-Tuple{Node}"><code>isleaf</code></a> to filter the leaf nodes of an MTG.</p><p>You also have <a href="../../api/#MultiScaleTreeGraph.nleaves"><code>nleaves</code></a> to compute the number of leaf nodes on the sub-tree of a given node.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1.manipulate_node/">« Manipulate nodes</a><a class="docs-footer-nextpage" href="../3.transform_mtg/">Transform an MTG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 2 December 2021 15:41">Thursday 2 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
